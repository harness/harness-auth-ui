/* Generated by restful-react */

import React from "react";
import { Mutate, MutateProps, useMutate, UseMutateProps } from "restful-react";
export const SPEC_VERSION = "2.0";
export interface AccountDTO {
  identifier?: string;
  name?: string;
  companyName?: string;
  cluster?: string;
  defaultExperience?: "NG" | "CG";
  authenticationMechanism?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
  serviceAccountConfig?: ServiceAccountConfig;
  nextGenEnabled?: boolean;
}

export interface Response {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: { [key: string]: any };
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseAccountDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: AccountDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceAccountConfig {
  apiKeyLimit?: number;
  tokenLimit?: number;
}

export interface Failure {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  code?:
    | "DEFAULT_ERROR_CODE"
    | "INVALID_ARGUMENT"
    | "INVALID_EMAIL"
    | "DOMAIN_NOT_ALLOWED_TO_REGISTER"
    | "USER_ALREADY_REGISTERED"
    | "USER_INVITATION_DOES_NOT_EXIST"
    | "USER_DOES_NOT_EXIST"
    | "USER_INVITE_OPERATION_FAILED"
    | "USER_DISABLED"
    | "ACCOUNT_DOES_NOT_EXIST"
    | "INACTIVE_ACCOUNT"
    | "ACCOUNT_MIGRATED"
    | "USER_DOMAIN_NOT_ALLOWED"
    | "MAX_FAILED_ATTEMPT_COUNT_EXCEEDED"
    | "RESOURCE_NOT_FOUND"
    | "ROLE_DOES_NOT_EXIST"
    | "EMAIL_NOT_VERIFIED"
    | "EMAIL_VERIFICATION_TOKEN_NOT_FOUND"
    | "INVALID_TOKEN"
    | "REVOKED_TOKEN"
    | "INVALID_CAPTCHA_TOKEN"
    | "NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS"
    | "EXPIRED_TOKEN"
    | "TOKEN_ALREADY_REFRESHED_ONCE"
    | "ACCESS_DENIED"
    | "NG_ACCESS_DENIED"
    | "INVALID_CREDENTIAL"
    | "INVALID_CREDENTIALS_THIRD_PARTY"
    | "INVALID_KEY"
    | "INVALID_CONNECTOR_TYPE"
    | "INVALID_KEYPATH"
    | "INVALID_VARIABLE"
    | "UNKNOWN_HOST"
    | "UNREACHABLE_HOST"
    | "INVALID_PORT"
    | "SSH_SESSION_TIMEOUT"
    | "SOCKET_CONNECTION_ERROR"
    | "CONNECTION_ERROR"
    | "SOCKET_CONNECTION_TIMEOUT"
    | "CONNECTION_TIMEOUT"
    | "SSH_CONNECTION_ERROR"
    | "USER_GROUP_ERROR"
    | "INVALID_EXECUTION_ID"
    | "ERROR_IN_GETTING_CHANNEL_STREAMS"
    | "UNEXPECTED"
    | "UNKNOWN_ERROR"
    | "UNKNOWN_EXECUTOR_TYPE_ERROR"
    | "DUPLICATE_STATE_NAMES"
    | "TRANSITION_NOT_LINKED"
    | "TRANSITION_TO_INCORRECT_STATE"
    | "TRANSITION_TYPE_NULL"
    | "STATES_WITH_DUP_TRANSITIONS"
    | "BARRIERS_NOT_RUNNING_CONCURRENTLY"
    | "NON_FORK_STATES"
    | "NON_REPEAT_STATES"
    | "INITIAL_STATE_NOT_DEFINED"
    | "FILE_INTEGRITY_CHECK_FAILED"
    | "INVALID_URL"
    | "FILE_DOWNLOAD_FAILED"
    | "PLATFORM_SOFTWARE_DELETE_ERROR"
    | "INVALID_CSV_FILE"
    | "INVALID_REQUEST"
    | "SCHEMA_VALIDATION_FAILED"
    | "FILTER_CREATION_ERROR"
    | "INVALID_YAML_ERROR"
    | "PLAN_CREATION_ERROR"
    | "INVALID_INFRA_STATE"
    | "PIPELINE_ALREADY_TRIGGERED"
    | "NON_EXISTING_PIPELINE"
    | "DUPLICATE_COMMAND_NAMES"
    | "INVALID_PIPELINE"
    | "COMMAND_DOES_NOT_EXIST"
    | "DUPLICATE_ARTIFACTSTREAM_NAMES"
    | "DUPLICATE_HOST_NAMES"
    | "STATE_NOT_FOR_TYPE"
    | "STATE_MACHINE_ISSUE"
    | "STATE_DISCONTINUE_FAILED"
    | "STATE_PAUSE_FAILED"
    | "PAUSE_ALL_ALREADY"
    | "RESUME_ALL_ALREADY"
    | "ROLLBACK_ALREADY"
    | "ABORT_ALL_ALREADY"
    | "EXPIRE_ALL_ALREADY"
    | "RETRY_FAILED"
    | "UNKNOWN_ARTIFACT_TYPE"
    | "UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE"
    | "INIT_TIMEOUT"
    | "LICENSE_EXPIRED"
    | "NOT_LICENSED"
    | "REQUEST_TIMEOUT"
    | "WORKFLOW_ALREADY_TRIGGERED"
    | "JENKINS_ERROR"
    | "INVALID_ARTIFACT_SOURCE"
    | "INVALID_ARTIFACT_SERVER"
    | "INVALID_CLOUD_PROVIDER"
    | "UPDATE_NOT_ALLOWED"
    | "DELETE_NOT_ALLOWED"
    | "APPDYNAMICS_CONFIGURATION_ERROR"
    | "APM_CONFIGURATION_ERROR"
    | "SPLUNK_CONFIGURATION_ERROR"
    | "ELK_CONFIGURATION_ERROR"
    | "LOGZ_CONFIGURATION_ERROR"
    | "SUMO_CONFIGURATION_ERROR"
    | "INSTANA_CONFIGURATION_ERROR"
    | "APPDYNAMICS_ERROR"
    | "STACKDRIVER_ERROR"
    | "STACKDRIVER_CONFIGURATION_ERROR"
    | "NEWRELIC_CONFIGURATION_ERROR"
    | "NEWRELIC_ERROR"
    | "DYNA_TRACE_CONFIGURATION_ERROR"
    | "DYNA_TRACE_ERROR"
    | "CLOUDWATCH_ERROR"
    | "CLOUDWATCH_CONFIGURATION_ERROR"
    | "PROMETHEUS_CONFIGURATION_ERROR"
    | "DATA_DOG_CONFIGURATION_ERROR"
    | "SERVICE_GUARD_CONFIGURATION_ERROR"
    | "ENCRYPTION_NOT_CONFIGURED"
    | "UNAVAILABLE_DELEGATES"
    | "WORKFLOW_EXECUTION_IN_PROGRESS"
    | "PIPELINE_EXECUTION_IN_PROGRESS"
    | "AWS_ACCESS_DENIED"
    | "AWS_CLUSTER_NOT_FOUND"
    | "AWS_SERVICE_NOT_FOUND"
    | "IMAGE_NOT_FOUND"
    | "ILLEGAL_ARGUMENT"
    | "IMAGE_TAG_NOT_FOUND"
    | "DELEGATE_NOT_AVAILABLE"
    | "INVALID_YAML_PAYLOAD"
    | "AUTHENTICATION_ERROR"
    | "AUTHORIZATION_ERROR"
    | "UNRECOGNIZED_YAML_FIELDS"
    | "COULD_NOT_MAP_BEFORE_YAML"
    | "MISSING_BEFORE_YAML"
    | "MISSING_YAML"
    | "NON_EMPTY_DELETIONS"
    | "GENERAL_YAML_ERROR"
    | "GENERAL_YAML_INFO"
    | "YAML_GIT_SYNC_ERROR"
    | "GIT_CONNECTION_ERROR"
    | "GIT_ERROR"
    | "ARTIFACT_SERVER_ERROR"
    | "ENCRYPT_DECRYPT_ERROR"
    | "SECRET_MANAGEMENT_ERROR"
    | "SECRET_NOT_FOUND"
    | "KMS_OPERATION_ERROR"
    | "GCP_KMS_OPERATION_ERROR"
    | "VAULT_OPERATION_ERROR"
    | "AWS_SECRETS_MANAGER_OPERATION_ERROR"
    | "AZURE_KEY_VAULT_OPERATION_ERROR"
    | "CYBERARK_OPERATION_ERROR"
    | "UNSUPPORTED_OPERATION_EXCEPTION"
    | "FEATURE_UNAVAILABLE"
    | "GENERAL_ERROR"
    | "BASELINE_CONFIGURATION_ERROR"
    | "SAML_IDP_CONFIGURATION_NOT_AVAILABLE"
    | "INVALID_AUTHENTICATION_MECHANISM"
    | "INVALID_SAML_CONFIGURATION"
    | "INVALID_OAUTH_CONFIGURATION"
    | "INVALID_LDAP_CONFIGURATION"
    | "USER_GROUP_SYNC_FAILURE"
    | "USER_GROUP_ALREADY_EXIST"
    | "INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION"
    | "EXPLANATION"
    | "HINT"
    | "NOT_WHITELISTED_IP"
    | "INVALID_TOTP_TOKEN"
    | "EMAIL_FAILED"
    | "SSL_HANDSHAKE_FAILED"
    | "NO_APPS_ASSIGNED"
    | "INVALID_INFRA_CONFIGURATION"
    | "TEMPLATES_LINKED"
    | "USER_HAS_NO_PERMISSIONS"
    | "USER_NOT_AUTHORIZED"
    | "USER_ALREADY_PRESENT"
    | "INVALID_USAGE_RESTRICTION"
    | "USAGE_RESTRICTION_ERROR"
    | "STATE_EXECUTION_INSTANCE_NOT_FOUND"
    | "DELEGATE_TASK_RETRY"
    | "KUBERNETES_YAML_ERROR"
    | "SAVE_FILE_INTO_GCP_STORAGE_FAILED"
    | "READ_FILE_FROM_GCP_STORAGE_FAILED"
    | "FILE_NOT_FOUND_ERROR"
    | "USAGE_LIMITS_EXCEEDED"
    | "EVENT_PUBLISH_FAILED"
    | "JIRA_ERROR"
    | "EXPRESSION_EVALUATION_FAILED"
    | "KUBERNETES_VALUES_ERROR"
    | "KUBERNETES_CLUSTER_ERROR"
    | "INCORRECT_SIGN_IN_MECHANISM"
    | "OAUTH_LOGIN_FAILED"
    | "INVALID_TERRAFORM_TARGETS_REQUEST"
    | "TERRAFORM_EXECUTION_ERROR"
    | "FILE_READ_FAILED"
    | "FILE_SIZE_EXCEEDS_LIMIT"
    | "CLUSTER_NOT_FOUND"
    | "MARKETPLACE_TOKEN_NOT_FOUND"
    | "INVALID_MARKETPLACE_TOKEN"
    | "INVALID_TICKETING_SERVER"
    | "SERVICENOW_ERROR"
    | "PASSWORD_EXPIRED"
    | "USER_LOCKED"
    | "PASSWORD_STRENGTH_CHECK_FAILED"
    | "ACCOUNT_DISABLED"
    | "INVALID_ACCOUNT_PERMISSION"
    | "PAGERDUTY_ERROR"
    | "HEALTH_ERROR"
    | "SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED"
    | "DOMAIN_WHITELIST_FILTER_CHECK_FAILED"
    | "INVALID_DASHBOARD_UPDATE_REQUEST"
    | "DUPLICATE_FIELD"
    | "INVALID_AZURE_VAULT_CONFIGURATION"
    | "USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS"
    | "INVALID_ROLLBACK"
    | "DATA_COLLECTION_ERROR"
    | "SUMO_DATA_COLLECTION_ERROR"
    | "DEPLOYMENT_GOVERNANCE_ERROR"
    | "BATCH_PROCESSING_ERROR"
    | "GRAPHQL_ERROR"
    | "FILE_CREATE_ERROR"
    | "ILLEGAL_STATE"
    | "GIT_DIFF_COMMIT_NOT_IN_ORDER"
    | "FAILED_TO_ACQUIRE_PERSISTENT_LOCK"
    | "FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK"
    | "POD_NOT_FOUND_ERROR"
    | "COMMAND_EXECUTION_ERROR"
    | "REGISTRY_EXCEPTION"
    | "ENGINE_INTERRUPT_PROCESSING_EXCEPTION"
    | "ENGINE_IO_EXCEPTION"
    | "ENGINE_OUTCOME_EXCEPTION"
    | "ENGINE_SWEEPING_OUTPUT_EXCEPTION"
    | "CACHE_NOT_FOUND_EXCEPTION"
    | "ENGINE_ENTITY_UPDATE_EXCEPTION"
    | "SHELL_EXECUTION_EXCEPTION"
    | "TEMPLATE_NOT_FOUND"
    | "AZURE_SERVICE_EXCEPTION"
    | "AZURE_CLIENT_EXCEPTION"
    | "GIT_UNSEEN_REMOTE_HEAD_COMMIT"
    | "TIMEOUT_ENGINE_EXCEPTION"
    | "NO_AVAILABLE_DELEGATES"
    | "NO_INSTALLED_DELEGATES"
    | "DUPLICATE_DELEGATE_EXCEPTION"
    | "GCP_MARKETPLACE_EXCEPTION"
    | "MISSING_DEFAULT_GOOGLE_CREDENTIALS"
    | "INCORRECT_DEFAULT_GOOGLE_CREDENTIALS"
    | "OPTIMISTIC_LOCKING_EXCEPTION"
    | "NG_PIPELINE_EXECUTION_EXCEPTION"
    | "NG_PIPELINE_CREATE_EXCEPTION"
    | "RESOURCE_NOT_FOUND_EXCEPTION"
    | "PMS_INITIALIZE_SDK_EXCEPTION"
    | "UNEXPECTED_SNIPPET_EXCEPTION"
    | "UNEXPECTED_SCHEMA_EXCEPTION"
    | "CONNECTOR_VALIDATION_EXCEPTION"
    | "TIMESCALE_NOT_AVAILABLE"
    | "MIGRATION_EXCEPTION"
    | "REQUEST_PROCESSING_INTERRUPTED"
    | "GCP_SECRET_MANAGER_OPERATION_ERROR"
    | "GCP_SECRET_OPERATION_ERROR"
    | "GIT_OPERATION_ERROR"
    | "TASK_FAILURE_ERROR"
    | "INSTANCE_STATS_PROCESS_ERROR"
    | "INSTANCE_STATS_MIGRATION_ERROR"
    | "DEPLOYMENT_MIGRATION_ERROR"
    | "INSTANCE_STATS_AGGREGATION_ERROR"
    | "UNRESOLVED_EXPRESSIONS_ERROR"
    | "KRYO_HANDLER_NOT_FOUND_ERROR"
    | "DELEGATE_ERROR_HANDLER_EXCEPTION"
    | "UNEXPECTED_TYPE_ERROR"
    | "EXCEPTION_HANDLER_NOT_FOUND"
    | "CONNECTOR_NOT_FOUND_EXCEPTION"
    | "GCP_SERVER_ERROR"
    | "HTTP_RESPONSE_EXCEPTION"
    | "SCM_NOT_FOUND_ERROR"
    | "SCM_CONFLICT_ERROR"
    | "SCM_UNPROCESSABLE_ENTITY"
    | "PROCESS_EXECUTION_EXCEPTION"
    | "SCM_UNAUTHORIZED"
    | "DATA"
    | "CONTEXT"
    | "PR_CREATION_ERROR"
    | "URL_NOT_REACHABLE"
    | "URL_NOT_PROVIDED"
    | "ENGINE_EXPRESSION_EVALUATION_ERROR"
    | "ENGINE_FUNCTOR_ERROR"
    | "JIRA_CLIENT_ERROR"
    | "SCM_NOT_MODIFIED"
    | "JIRA_STEP_ERROR"
    | "BUCKET_SERVER_ERROR";
  message?: string;
  correlationId?: string;
  errors?: ValidationError[];
}

export interface ValidationError {
  fieldId?: string;
  error?: string;
}

export interface Error {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  code?:
    | "DEFAULT_ERROR_CODE"
    | "INVALID_ARGUMENT"
    | "INVALID_EMAIL"
    | "DOMAIN_NOT_ALLOWED_TO_REGISTER"
    | "USER_ALREADY_REGISTERED"
    | "USER_INVITATION_DOES_NOT_EXIST"
    | "USER_DOES_NOT_EXIST"
    | "USER_INVITE_OPERATION_FAILED"
    | "USER_DISABLED"
    | "ACCOUNT_DOES_NOT_EXIST"
    | "INACTIVE_ACCOUNT"
    | "ACCOUNT_MIGRATED"
    | "USER_DOMAIN_NOT_ALLOWED"
    | "MAX_FAILED_ATTEMPT_COUNT_EXCEEDED"
    | "RESOURCE_NOT_FOUND"
    | "ROLE_DOES_NOT_EXIST"
    | "EMAIL_NOT_VERIFIED"
    | "EMAIL_VERIFICATION_TOKEN_NOT_FOUND"
    | "INVALID_TOKEN"
    | "REVOKED_TOKEN"
    | "INVALID_CAPTCHA_TOKEN"
    | "NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS"
    | "EXPIRED_TOKEN"
    | "TOKEN_ALREADY_REFRESHED_ONCE"
    | "ACCESS_DENIED"
    | "NG_ACCESS_DENIED"
    | "INVALID_CREDENTIAL"
    | "INVALID_CREDENTIALS_THIRD_PARTY"
    | "INVALID_KEY"
    | "INVALID_CONNECTOR_TYPE"
    | "INVALID_KEYPATH"
    | "INVALID_VARIABLE"
    | "UNKNOWN_HOST"
    | "UNREACHABLE_HOST"
    | "INVALID_PORT"
    | "SSH_SESSION_TIMEOUT"
    | "SOCKET_CONNECTION_ERROR"
    | "CONNECTION_ERROR"
    | "SOCKET_CONNECTION_TIMEOUT"
    | "CONNECTION_TIMEOUT"
    | "SSH_CONNECTION_ERROR"
    | "USER_GROUP_ERROR"
    | "INVALID_EXECUTION_ID"
    | "ERROR_IN_GETTING_CHANNEL_STREAMS"
    | "UNEXPECTED"
    | "UNKNOWN_ERROR"
    | "UNKNOWN_EXECUTOR_TYPE_ERROR"
    | "DUPLICATE_STATE_NAMES"
    | "TRANSITION_NOT_LINKED"
    | "TRANSITION_TO_INCORRECT_STATE"
    | "TRANSITION_TYPE_NULL"
    | "STATES_WITH_DUP_TRANSITIONS"
    | "BARRIERS_NOT_RUNNING_CONCURRENTLY"
    | "NON_FORK_STATES"
    | "NON_REPEAT_STATES"
    | "INITIAL_STATE_NOT_DEFINED"
    | "FILE_INTEGRITY_CHECK_FAILED"
    | "INVALID_URL"
    | "FILE_DOWNLOAD_FAILED"
    | "PLATFORM_SOFTWARE_DELETE_ERROR"
    | "INVALID_CSV_FILE"
    | "INVALID_REQUEST"
    | "SCHEMA_VALIDATION_FAILED"
    | "FILTER_CREATION_ERROR"
    | "INVALID_YAML_ERROR"
    | "PLAN_CREATION_ERROR"
    | "INVALID_INFRA_STATE"
    | "PIPELINE_ALREADY_TRIGGERED"
    | "NON_EXISTING_PIPELINE"
    | "DUPLICATE_COMMAND_NAMES"
    | "INVALID_PIPELINE"
    | "COMMAND_DOES_NOT_EXIST"
    | "DUPLICATE_ARTIFACTSTREAM_NAMES"
    | "DUPLICATE_HOST_NAMES"
    | "STATE_NOT_FOR_TYPE"
    | "STATE_MACHINE_ISSUE"
    | "STATE_DISCONTINUE_FAILED"
    | "STATE_PAUSE_FAILED"
    | "PAUSE_ALL_ALREADY"
    | "RESUME_ALL_ALREADY"
    | "ROLLBACK_ALREADY"
    | "ABORT_ALL_ALREADY"
    | "EXPIRE_ALL_ALREADY"
    | "RETRY_FAILED"
    | "UNKNOWN_ARTIFACT_TYPE"
    | "UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE"
    | "INIT_TIMEOUT"
    | "LICENSE_EXPIRED"
    | "NOT_LICENSED"
    | "REQUEST_TIMEOUT"
    | "WORKFLOW_ALREADY_TRIGGERED"
    | "JENKINS_ERROR"
    | "INVALID_ARTIFACT_SOURCE"
    | "INVALID_ARTIFACT_SERVER"
    | "INVALID_CLOUD_PROVIDER"
    | "UPDATE_NOT_ALLOWED"
    | "DELETE_NOT_ALLOWED"
    | "APPDYNAMICS_CONFIGURATION_ERROR"
    | "APM_CONFIGURATION_ERROR"
    | "SPLUNK_CONFIGURATION_ERROR"
    | "ELK_CONFIGURATION_ERROR"
    | "LOGZ_CONFIGURATION_ERROR"
    | "SUMO_CONFIGURATION_ERROR"
    | "INSTANA_CONFIGURATION_ERROR"
    | "APPDYNAMICS_ERROR"
    | "STACKDRIVER_ERROR"
    | "STACKDRIVER_CONFIGURATION_ERROR"
    | "NEWRELIC_CONFIGURATION_ERROR"
    | "NEWRELIC_ERROR"
    | "DYNA_TRACE_CONFIGURATION_ERROR"
    | "DYNA_TRACE_ERROR"
    | "CLOUDWATCH_ERROR"
    | "CLOUDWATCH_CONFIGURATION_ERROR"
    | "PROMETHEUS_CONFIGURATION_ERROR"
    | "DATA_DOG_CONFIGURATION_ERROR"
    | "SERVICE_GUARD_CONFIGURATION_ERROR"
    | "ENCRYPTION_NOT_CONFIGURED"
    | "UNAVAILABLE_DELEGATES"
    | "WORKFLOW_EXECUTION_IN_PROGRESS"
    | "PIPELINE_EXECUTION_IN_PROGRESS"
    | "AWS_ACCESS_DENIED"
    | "AWS_CLUSTER_NOT_FOUND"
    | "AWS_SERVICE_NOT_FOUND"
    | "IMAGE_NOT_FOUND"
    | "ILLEGAL_ARGUMENT"
    | "IMAGE_TAG_NOT_FOUND"
    | "DELEGATE_NOT_AVAILABLE"
    | "INVALID_YAML_PAYLOAD"
    | "AUTHENTICATION_ERROR"
    | "AUTHORIZATION_ERROR"
    | "UNRECOGNIZED_YAML_FIELDS"
    | "COULD_NOT_MAP_BEFORE_YAML"
    | "MISSING_BEFORE_YAML"
    | "MISSING_YAML"
    | "NON_EMPTY_DELETIONS"
    | "GENERAL_YAML_ERROR"
    | "GENERAL_YAML_INFO"
    | "YAML_GIT_SYNC_ERROR"
    | "GIT_CONNECTION_ERROR"
    | "GIT_ERROR"
    | "ARTIFACT_SERVER_ERROR"
    | "ENCRYPT_DECRYPT_ERROR"
    | "SECRET_MANAGEMENT_ERROR"
    | "SECRET_NOT_FOUND"
    | "KMS_OPERATION_ERROR"
    | "GCP_KMS_OPERATION_ERROR"
    | "VAULT_OPERATION_ERROR"
    | "AWS_SECRETS_MANAGER_OPERATION_ERROR"
    | "AZURE_KEY_VAULT_OPERATION_ERROR"
    | "CYBERARK_OPERATION_ERROR"
    | "UNSUPPORTED_OPERATION_EXCEPTION"
    | "FEATURE_UNAVAILABLE"
    | "GENERAL_ERROR"
    | "BASELINE_CONFIGURATION_ERROR"
    | "SAML_IDP_CONFIGURATION_NOT_AVAILABLE"
    | "INVALID_AUTHENTICATION_MECHANISM"
    | "INVALID_SAML_CONFIGURATION"
    | "INVALID_OAUTH_CONFIGURATION"
    | "INVALID_LDAP_CONFIGURATION"
    | "USER_GROUP_SYNC_FAILURE"
    | "USER_GROUP_ALREADY_EXIST"
    | "INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION"
    | "EXPLANATION"
    | "HINT"
    | "NOT_WHITELISTED_IP"
    | "INVALID_TOTP_TOKEN"
    | "EMAIL_FAILED"
    | "SSL_HANDSHAKE_FAILED"
    | "NO_APPS_ASSIGNED"
    | "INVALID_INFRA_CONFIGURATION"
    | "TEMPLATES_LINKED"
    | "USER_HAS_NO_PERMISSIONS"
    | "USER_NOT_AUTHORIZED"
    | "USER_ALREADY_PRESENT"
    | "INVALID_USAGE_RESTRICTION"
    | "USAGE_RESTRICTION_ERROR"
    | "STATE_EXECUTION_INSTANCE_NOT_FOUND"
    | "DELEGATE_TASK_RETRY"
    | "KUBERNETES_YAML_ERROR"
    | "SAVE_FILE_INTO_GCP_STORAGE_FAILED"
    | "READ_FILE_FROM_GCP_STORAGE_FAILED"
    | "FILE_NOT_FOUND_ERROR"
    | "USAGE_LIMITS_EXCEEDED"
    | "EVENT_PUBLISH_FAILED"
    | "JIRA_ERROR"
    | "EXPRESSION_EVALUATION_FAILED"
    | "KUBERNETES_VALUES_ERROR"
    | "KUBERNETES_CLUSTER_ERROR"
    | "INCORRECT_SIGN_IN_MECHANISM"
    | "OAUTH_LOGIN_FAILED"
    | "INVALID_TERRAFORM_TARGETS_REQUEST"
    | "TERRAFORM_EXECUTION_ERROR"
    | "FILE_READ_FAILED"
    | "FILE_SIZE_EXCEEDS_LIMIT"
    | "CLUSTER_NOT_FOUND"
    | "MARKETPLACE_TOKEN_NOT_FOUND"
    | "INVALID_MARKETPLACE_TOKEN"
    | "INVALID_TICKETING_SERVER"
    | "SERVICENOW_ERROR"
    | "PASSWORD_EXPIRED"
    | "USER_LOCKED"
    | "PASSWORD_STRENGTH_CHECK_FAILED"
    | "ACCOUNT_DISABLED"
    | "INVALID_ACCOUNT_PERMISSION"
    | "PAGERDUTY_ERROR"
    | "HEALTH_ERROR"
    | "SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED"
    | "DOMAIN_WHITELIST_FILTER_CHECK_FAILED"
    | "INVALID_DASHBOARD_UPDATE_REQUEST"
    | "DUPLICATE_FIELD"
    | "INVALID_AZURE_VAULT_CONFIGURATION"
    | "USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS"
    | "INVALID_ROLLBACK"
    | "DATA_COLLECTION_ERROR"
    | "SUMO_DATA_COLLECTION_ERROR"
    | "DEPLOYMENT_GOVERNANCE_ERROR"
    | "BATCH_PROCESSING_ERROR"
    | "GRAPHQL_ERROR"
    | "FILE_CREATE_ERROR"
    | "ILLEGAL_STATE"
    | "GIT_DIFF_COMMIT_NOT_IN_ORDER"
    | "FAILED_TO_ACQUIRE_PERSISTENT_LOCK"
    | "FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK"
    | "POD_NOT_FOUND_ERROR"
    | "COMMAND_EXECUTION_ERROR"
    | "REGISTRY_EXCEPTION"
    | "ENGINE_INTERRUPT_PROCESSING_EXCEPTION"
    | "ENGINE_IO_EXCEPTION"
    | "ENGINE_OUTCOME_EXCEPTION"
    | "ENGINE_SWEEPING_OUTPUT_EXCEPTION"
    | "CACHE_NOT_FOUND_EXCEPTION"
    | "ENGINE_ENTITY_UPDATE_EXCEPTION"
    | "SHELL_EXECUTION_EXCEPTION"
    | "TEMPLATE_NOT_FOUND"
    | "AZURE_SERVICE_EXCEPTION"
    | "AZURE_CLIENT_EXCEPTION"
    | "GIT_UNSEEN_REMOTE_HEAD_COMMIT"
    | "TIMEOUT_ENGINE_EXCEPTION"
    | "NO_AVAILABLE_DELEGATES"
    | "NO_INSTALLED_DELEGATES"
    | "DUPLICATE_DELEGATE_EXCEPTION"
    | "GCP_MARKETPLACE_EXCEPTION"
    | "MISSING_DEFAULT_GOOGLE_CREDENTIALS"
    | "INCORRECT_DEFAULT_GOOGLE_CREDENTIALS"
    | "OPTIMISTIC_LOCKING_EXCEPTION"
    | "NG_PIPELINE_EXECUTION_EXCEPTION"
    | "NG_PIPELINE_CREATE_EXCEPTION"
    | "RESOURCE_NOT_FOUND_EXCEPTION"
    | "PMS_INITIALIZE_SDK_EXCEPTION"
    | "UNEXPECTED_SNIPPET_EXCEPTION"
    | "UNEXPECTED_SCHEMA_EXCEPTION"
    | "CONNECTOR_VALIDATION_EXCEPTION"
    | "TIMESCALE_NOT_AVAILABLE"
    | "MIGRATION_EXCEPTION"
    | "REQUEST_PROCESSING_INTERRUPTED"
    | "GCP_SECRET_MANAGER_OPERATION_ERROR"
    | "GCP_SECRET_OPERATION_ERROR"
    | "GIT_OPERATION_ERROR"
    | "TASK_FAILURE_ERROR"
    | "INSTANCE_STATS_PROCESS_ERROR"
    | "INSTANCE_STATS_MIGRATION_ERROR"
    | "DEPLOYMENT_MIGRATION_ERROR"
    | "INSTANCE_STATS_AGGREGATION_ERROR"
    | "UNRESOLVED_EXPRESSIONS_ERROR"
    | "KRYO_HANDLER_NOT_FOUND_ERROR"
    | "DELEGATE_ERROR_HANDLER_EXCEPTION"
    | "UNEXPECTED_TYPE_ERROR"
    | "EXCEPTION_HANDLER_NOT_FOUND"
    | "CONNECTOR_NOT_FOUND_EXCEPTION"
    | "GCP_SERVER_ERROR"
    | "HTTP_RESPONSE_EXCEPTION"
    | "SCM_NOT_FOUND_ERROR"
    | "SCM_CONFLICT_ERROR"
    | "SCM_UNPROCESSABLE_ENTITY"
    | "PROCESS_EXECUTION_EXCEPTION"
    | "SCM_UNAUTHORIZED"
    | "DATA"
    | "CONTEXT"
    | "PR_CREATION_ERROR"
    | "URL_NOT_REACHABLE"
    | "URL_NOT_PROVIDED"
    | "ENGINE_EXPRESSION_EVALUATION_ERROR"
    | "ENGINE_FUNCTOR_ERROR"
    | "JIRA_CLIENT_ERROR"
    | "SCM_NOT_MODIFIED"
    | "JIRA_STEP_ERROR"
    | "BUCKET_SERVER_ERROR";
  message?: string;
  correlationId?: string;
  detailedMessage?: string;
  responseMessages?: ResponseMessage[];
}

export interface ResponseMessage {
  code?:
    | "DEFAULT_ERROR_CODE"
    | "INVALID_ARGUMENT"
    | "INVALID_EMAIL"
    | "DOMAIN_NOT_ALLOWED_TO_REGISTER"
    | "USER_ALREADY_REGISTERED"
    | "USER_INVITATION_DOES_NOT_EXIST"
    | "USER_DOES_NOT_EXIST"
    | "USER_INVITE_OPERATION_FAILED"
    | "USER_DISABLED"
    | "ACCOUNT_DOES_NOT_EXIST"
    | "INACTIVE_ACCOUNT"
    | "ACCOUNT_MIGRATED"
    | "USER_DOMAIN_NOT_ALLOWED"
    | "MAX_FAILED_ATTEMPT_COUNT_EXCEEDED"
    | "RESOURCE_NOT_FOUND"
    | "ROLE_DOES_NOT_EXIST"
    | "EMAIL_NOT_VERIFIED"
    | "EMAIL_VERIFICATION_TOKEN_NOT_FOUND"
    | "INVALID_TOKEN"
    | "REVOKED_TOKEN"
    | "INVALID_CAPTCHA_TOKEN"
    | "NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS"
    | "EXPIRED_TOKEN"
    | "TOKEN_ALREADY_REFRESHED_ONCE"
    | "ACCESS_DENIED"
    | "NG_ACCESS_DENIED"
    | "INVALID_CREDENTIAL"
    | "INVALID_CREDENTIALS_THIRD_PARTY"
    | "INVALID_KEY"
    | "INVALID_CONNECTOR_TYPE"
    | "INVALID_KEYPATH"
    | "INVALID_VARIABLE"
    | "UNKNOWN_HOST"
    | "UNREACHABLE_HOST"
    | "INVALID_PORT"
    | "SSH_SESSION_TIMEOUT"
    | "SOCKET_CONNECTION_ERROR"
    | "CONNECTION_ERROR"
    | "SOCKET_CONNECTION_TIMEOUT"
    | "CONNECTION_TIMEOUT"
    | "SSH_CONNECTION_ERROR"
    | "USER_GROUP_ERROR"
    | "INVALID_EXECUTION_ID"
    | "ERROR_IN_GETTING_CHANNEL_STREAMS"
    | "UNEXPECTED"
    | "UNKNOWN_ERROR"
    | "UNKNOWN_EXECUTOR_TYPE_ERROR"
    | "DUPLICATE_STATE_NAMES"
    | "TRANSITION_NOT_LINKED"
    | "TRANSITION_TO_INCORRECT_STATE"
    | "TRANSITION_TYPE_NULL"
    | "STATES_WITH_DUP_TRANSITIONS"
    | "BARRIERS_NOT_RUNNING_CONCURRENTLY"
    | "NON_FORK_STATES"
    | "NON_REPEAT_STATES"
    | "INITIAL_STATE_NOT_DEFINED"
    | "FILE_INTEGRITY_CHECK_FAILED"
    | "INVALID_URL"
    | "FILE_DOWNLOAD_FAILED"
    | "PLATFORM_SOFTWARE_DELETE_ERROR"
    | "INVALID_CSV_FILE"
    | "INVALID_REQUEST"
    | "SCHEMA_VALIDATION_FAILED"
    | "FILTER_CREATION_ERROR"
    | "INVALID_YAML_ERROR"
    | "PLAN_CREATION_ERROR"
    | "INVALID_INFRA_STATE"
    | "PIPELINE_ALREADY_TRIGGERED"
    | "NON_EXISTING_PIPELINE"
    | "DUPLICATE_COMMAND_NAMES"
    | "INVALID_PIPELINE"
    | "COMMAND_DOES_NOT_EXIST"
    | "DUPLICATE_ARTIFACTSTREAM_NAMES"
    | "DUPLICATE_HOST_NAMES"
    | "STATE_NOT_FOR_TYPE"
    | "STATE_MACHINE_ISSUE"
    | "STATE_DISCONTINUE_FAILED"
    | "STATE_PAUSE_FAILED"
    | "PAUSE_ALL_ALREADY"
    | "RESUME_ALL_ALREADY"
    | "ROLLBACK_ALREADY"
    | "ABORT_ALL_ALREADY"
    | "EXPIRE_ALL_ALREADY"
    | "RETRY_FAILED"
    | "UNKNOWN_ARTIFACT_TYPE"
    | "UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE"
    | "INIT_TIMEOUT"
    | "LICENSE_EXPIRED"
    | "NOT_LICENSED"
    | "REQUEST_TIMEOUT"
    | "WORKFLOW_ALREADY_TRIGGERED"
    | "JENKINS_ERROR"
    | "INVALID_ARTIFACT_SOURCE"
    | "INVALID_ARTIFACT_SERVER"
    | "INVALID_CLOUD_PROVIDER"
    | "UPDATE_NOT_ALLOWED"
    | "DELETE_NOT_ALLOWED"
    | "APPDYNAMICS_CONFIGURATION_ERROR"
    | "APM_CONFIGURATION_ERROR"
    | "SPLUNK_CONFIGURATION_ERROR"
    | "ELK_CONFIGURATION_ERROR"
    | "LOGZ_CONFIGURATION_ERROR"
    | "SUMO_CONFIGURATION_ERROR"
    | "INSTANA_CONFIGURATION_ERROR"
    | "APPDYNAMICS_ERROR"
    | "STACKDRIVER_ERROR"
    | "STACKDRIVER_CONFIGURATION_ERROR"
    | "NEWRELIC_CONFIGURATION_ERROR"
    | "NEWRELIC_ERROR"
    | "DYNA_TRACE_CONFIGURATION_ERROR"
    | "DYNA_TRACE_ERROR"
    | "CLOUDWATCH_ERROR"
    | "CLOUDWATCH_CONFIGURATION_ERROR"
    | "PROMETHEUS_CONFIGURATION_ERROR"
    | "DATA_DOG_CONFIGURATION_ERROR"
    | "SERVICE_GUARD_CONFIGURATION_ERROR"
    | "ENCRYPTION_NOT_CONFIGURED"
    | "UNAVAILABLE_DELEGATES"
    | "WORKFLOW_EXECUTION_IN_PROGRESS"
    | "PIPELINE_EXECUTION_IN_PROGRESS"
    | "AWS_ACCESS_DENIED"
    | "AWS_CLUSTER_NOT_FOUND"
    | "AWS_SERVICE_NOT_FOUND"
    | "IMAGE_NOT_FOUND"
    | "ILLEGAL_ARGUMENT"
    | "IMAGE_TAG_NOT_FOUND"
    | "DELEGATE_NOT_AVAILABLE"
    | "INVALID_YAML_PAYLOAD"
    | "AUTHENTICATION_ERROR"
    | "AUTHORIZATION_ERROR"
    | "UNRECOGNIZED_YAML_FIELDS"
    | "COULD_NOT_MAP_BEFORE_YAML"
    | "MISSING_BEFORE_YAML"
    | "MISSING_YAML"
    | "NON_EMPTY_DELETIONS"
    | "GENERAL_YAML_ERROR"
    | "GENERAL_YAML_INFO"
    | "YAML_GIT_SYNC_ERROR"
    | "GIT_CONNECTION_ERROR"
    | "GIT_ERROR"
    | "ARTIFACT_SERVER_ERROR"
    | "ENCRYPT_DECRYPT_ERROR"
    | "SECRET_MANAGEMENT_ERROR"
    | "SECRET_NOT_FOUND"
    | "KMS_OPERATION_ERROR"
    | "GCP_KMS_OPERATION_ERROR"
    | "VAULT_OPERATION_ERROR"
    | "AWS_SECRETS_MANAGER_OPERATION_ERROR"
    | "AZURE_KEY_VAULT_OPERATION_ERROR"
    | "CYBERARK_OPERATION_ERROR"
    | "UNSUPPORTED_OPERATION_EXCEPTION"
    | "FEATURE_UNAVAILABLE"
    | "GENERAL_ERROR"
    | "BASELINE_CONFIGURATION_ERROR"
    | "SAML_IDP_CONFIGURATION_NOT_AVAILABLE"
    | "INVALID_AUTHENTICATION_MECHANISM"
    | "INVALID_SAML_CONFIGURATION"
    | "INVALID_OAUTH_CONFIGURATION"
    | "INVALID_LDAP_CONFIGURATION"
    | "USER_GROUP_SYNC_FAILURE"
    | "USER_GROUP_ALREADY_EXIST"
    | "INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION"
    | "EXPLANATION"
    | "HINT"
    | "NOT_WHITELISTED_IP"
    | "INVALID_TOTP_TOKEN"
    | "EMAIL_FAILED"
    | "SSL_HANDSHAKE_FAILED"
    | "NO_APPS_ASSIGNED"
    | "INVALID_INFRA_CONFIGURATION"
    | "TEMPLATES_LINKED"
    | "USER_HAS_NO_PERMISSIONS"
    | "USER_NOT_AUTHORIZED"
    | "USER_ALREADY_PRESENT"
    | "INVALID_USAGE_RESTRICTION"
    | "USAGE_RESTRICTION_ERROR"
    | "STATE_EXECUTION_INSTANCE_NOT_FOUND"
    | "DELEGATE_TASK_RETRY"
    | "KUBERNETES_YAML_ERROR"
    | "SAVE_FILE_INTO_GCP_STORAGE_FAILED"
    | "READ_FILE_FROM_GCP_STORAGE_FAILED"
    | "FILE_NOT_FOUND_ERROR"
    | "USAGE_LIMITS_EXCEEDED"
    | "EVENT_PUBLISH_FAILED"
    | "JIRA_ERROR"
    | "EXPRESSION_EVALUATION_FAILED"
    | "KUBERNETES_VALUES_ERROR"
    | "KUBERNETES_CLUSTER_ERROR"
    | "INCORRECT_SIGN_IN_MECHANISM"
    | "OAUTH_LOGIN_FAILED"
    | "INVALID_TERRAFORM_TARGETS_REQUEST"
    | "TERRAFORM_EXECUTION_ERROR"
    | "FILE_READ_FAILED"
    | "FILE_SIZE_EXCEEDS_LIMIT"
    | "CLUSTER_NOT_FOUND"
    | "MARKETPLACE_TOKEN_NOT_FOUND"
    | "INVALID_MARKETPLACE_TOKEN"
    | "INVALID_TICKETING_SERVER"
    | "SERVICENOW_ERROR"
    | "PASSWORD_EXPIRED"
    | "USER_LOCKED"
    | "PASSWORD_STRENGTH_CHECK_FAILED"
    | "ACCOUNT_DISABLED"
    | "INVALID_ACCOUNT_PERMISSION"
    | "PAGERDUTY_ERROR"
    | "HEALTH_ERROR"
    | "SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED"
    | "DOMAIN_WHITELIST_FILTER_CHECK_FAILED"
    | "INVALID_DASHBOARD_UPDATE_REQUEST"
    | "DUPLICATE_FIELD"
    | "INVALID_AZURE_VAULT_CONFIGURATION"
    | "USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS"
    | "INVALID_ROLLBACK"
    | "DATA_COLLECTION_ERROR"
    | "SUMO_DATA_COLLECTION_ERROR"
    | "DEPLOYMENT_GOVERNANCE_ERROR"
    | "BATCH_PROCESSING_ERROR"
    | "GRAPHQL_ERROR"
    | "FILE_CREATE_ERROR"
    | "ILLEGAL_STATE"
    | "GIT_DIFF_COMMIT_NOT_IN_ORDER"
    | "FAILED_TO_ACQUIRE_PERSISTENT_LOCK"
    | "FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK"
    | "POD_NOT_FOUND_ERROR"
    | "COMMAND_EXECUTION_ERROR"
    | "REGISTRY_EXCEPTION"
    | "ENGINE_INTERRUPT_PROCESSING_EXCEPTION"
    | "ENGINE_IO_EXCEPTION"
    | "ENGINE_OUTCOME_EXCEPTION"
    | "ENGINE_SWEEPING_OUTPUT_EXCEPTION"
    | "CACHE_NOT_FOUND_EXCEPTION"
    | "ENGINE_ENTITY_UPDATE_EXCEPTION"
    | "SHELL_EXECUTION_EXCEPTION"
    | "TEMPLATE_NOT_FOUND"
    | "AZURE_SERVICE_EXCEPTION"
    | "AZURE_CLIENT_EXCEPTION"
    | "GIT_UNSEEN_REMOTE_HEAD_COMMIT"
    | "TIMEOUT_ENGINE_EXCEPTION"
    | "NO_AVAILABLE_DELEGATES"
    | "NO_INSTALLED_DELEGATES"
    | "DUPLICATE_DELEGATE_EXCEPTION"
    | "GCP_MARKETPLACE_EXCEPTION"
    | "MISSING_DEFAULT_GOOGLE_CREDENTIALS"
    | "INCORRECT_DEFAULT_GOOGLE_CREDENTIALS"
    | "OPTIMISTIC_LOCKING_EXCEPTION"
    | "NG_PIPELINE_EXECUTION_EXCEPTION"
    | "NG_PIPELINE_CREATE_EXCEPTION"
    | "RESOURCE_NOT_FOUND_EXCEPTION"
    | "PMS_INITIALIZE_SDK_EXCEPTION"
    | "UNEXPECTED_SNIPPET_EXCEPTION"
    | "UNEXPECTED_SCHEMA_EXCEPTION"
    | "CONNECTOR_VALIDATION_EXCEPTION"
    | "TIMESCALE_NOT_AVAILABLE"
    | "MIGRATION_EXCEPTION"
    | "REQUEST_PROCESSING_INTERRUPTED"
    | "GCP_SECRET_MANAGER_OPERATION_ERROR"
    | "GCP_SECRET_OPERATION_ERROR"
    | "GIT_OPERATION_ERROR"
    | "TASK_FAILURE_ERROR"
    | "INSTANCE_STATS_PROCESS_ERROR"
    | "INSTANCE_STATS_MIGRATION_ERROR"
    | "DEPLOYMENT_MIGRATION_ERROR"
    | "INSTANCE_STATS_AGGREGATION_ERROR"
    | "UNRESOLVED_EXPRESSIONS_ERROR"
    | "KRYO_HANDLER_NOT_FOUND_ERROR"
    | "DELEGATE_ERROR_HANDLER_EXCEPTION"
    | "UNEXPECTED_TYPE_ERROR"
    | "EXCEPTION_HANDLER_NOT_FOUND"
    | "CONNECTOR_NOT_FOUND_EXCEPTION"
    | "GCP_SERVER_ERROR"
    | "HTTP_RESPONSE_EXCEPTION"
    | "SCM_NOT_FOUND_ERROR"
    | "SCM_CONFLICT_ERROR"
    | "SCM_UNPROCESSABLE_ENTITY"
    | "PROCESS_EXECUTION_EXCEPTION"
    | "SCM_UNAUTHORIZED"
    | "DATA"
    | "CONTEXT"
    | "PR_CREATION_ERROR"
    | "URL_NOT_REACHABLE"
    | "URL_NOT_PROVIDED"
    | "ENGINE_EXPRESSION_EVALUATION_ERROR"
    | "ENGINE_FUNCTOR_ERROR"
    | "JIRA_CLIENT_ERROR"
    | "SCM_NOT_MODIFIED"
    | "JIRA_STEP_ERROR"
    | "BUCKET_SERVER_ERROR";
  level?: "INFO" | "ERROR";
  message?: string;
  exception?: Throwable;
  failureTypes?: (
    | "EXPIRED"
    | "DELEGATE_PROVISIONING"
    | "CONNECTIVITY"
    | "AUTHENTICATION"
    | "VERIFICATION_FAILURE"
    | "APPLICATION_ERROR"
    | "AUTHORIZATION_ERROR"
    | "TIMEOUT_ERROR"
  )[];
}

export interface StackTraceElement {
  methodName?: string;
  fileName?: string;
  lineNumber?: number;
  className?: string;
  nativeMethod?: boolean;
}

export interface Throwable {
  cause?: Throwable;
  stackTrace?: StackTraceElement[];
  message?: string;
  localizedMessage?: string;
  suppressed?: Throwable[];
}

export interface ResponseStepCategory {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: StepCategory;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface StepCategory {
  name?: string;
  stepsData?: StepData[];
  stepCategories?: StepCategory[];
}

export interface StepData {
  type?:
    | "APPLY"
    | "SCALE"
    | "STAGE_DEPLOYMENT"
    | "K8sRollingDeploy"
    | "K8sRollingRollback"
    | "K8sBGSwapServices"
    | "K8sDelete"
    | "K8sCanaryDelete"
    | "K8sCanaryDeploy"
    | "TerraformApply"
    | "TerraformPlan"
    | "TerraformDestroy"
    | "TerraformRollback"
    | "CREATE_STACK"
    | "DELETE_STACK"
    | "SHELL_SCRIPT_PROVISIONER"
    | "JIRA"
    | "SERVICENOW"
    | "EMAIL"
    | "BARRIERS"
    | "ShellScript"
    | "NEW_RELIC_DEPLOYMENT_MAKER"
    | "TEMPLATIZED_SECRET_MANAGER";
  name?: string;
}

export interface ResponseString {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: string;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseMapServiceDefinitionTypeListExecutionStrategyType {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: {
    [key: string]: ("Basic" | "Canary" | "BlueGreen" | "Rolling" | "Default")[];
  };
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListServiceDefinitionType {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: "Kubernetes"[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ConnectorValidationResult {
  status?: "SUCCESS" | "FAILURE" | "PARTIAL" | "UNKNOWN";
  errors?: ErrorDetail[];
  errorSummary?: string;
  testedAt?: number;
  delegateId?: string;
}

export interface ErrorDetail {
  reason?: string;
  message?: string;
  code?: number;
}

export interface ResponseConnectorValidationResult {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorValidationResult;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type AppDynamicsConnectorDTO = ConnectorConfigDTO & {
  username?: string;
  accountname: string;
  controllerUrl: string;
  delegateSelectors?: string[];
  passwordRef?: string;
  clientSecretRef?: string;
  clientId?: string;
  authType?: "UsernamePassword" | "ApiClientToken";
};

export interface ArtifactoryAuthCredentials {
  [key: string]: any;
}

export interface ArtifactoryAuthentication {
  type: "UsernamePassword" | "Anonymous";
  spec?: ArtifactoryAuthCredentials;
}

export type ArtifactoryConnector = ConnectorConfigDTO & {
  artifactoryServerUrl: string;
  auth?: ArtifactoryAuthentication;
  delegateSelectors?: string[];
};

export type ArtifactoryUsernamePasswordAuth = ArtifactoryAuthCredentials & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export interface AwsCodeCommitAuthenticationDTO {
  type: "HTTPS";
  spec: AwsCodeCommitCredentialsDTO;
}

export type AwsCodeCommitConnectorDTO = ConnectorConfigDTO & {
  url: string;
  authentication: AwsCodeCommitAuthenticationDTO;
  delegateSelectors?: string[];
  type: "Repo" | "Region";
};

export interface AwsCodeCommitCredentialsDTO {
  [key: string]: any;
}

export type AwsCodeCommitHttpsCredentialsDTO = AwsCodeCommitCredentialsDTO & {
  type: "AWSCredentials";
  spec: AwsCodeCommitHttpsCredentialsSpecDTO;
};

export interface AwsCodeCommitHttpsCredentialsSpecDTO {
  [key: string]: any;
}

export type AwsCodeCommitSecretKeyAccessKeyDTO = AwsCodeCommitHttpsCredentialsSpecDTO & {
  accessKey?: string;
  accessKeyRef?: string;
  secretKeyRef: string;
};

export type AwsConnector = ConnectorConfigDTO & {
  credential: AwsCredential;
  delegateSelectors?: string[];
};

export interface AwsCredential {
  crossAccountAccess?: CrossAccountAccess;
  type: "InheritFromDelegate" | "ManualConfig" | "Irsa";
  spec?: AwsCredentialSpec;
}

export interface AwsCredentialSpec {
  [key: string]: any;
}

export interface AwsCurAttributes {
  reportName: string;
  s3BucketName: string;
  region?: string;
  s3Prefix?: string;
}

export interface AwsKmsConnectorCredential {
  type: "AssumeIAMRole" | "AssumeSTSRole" | "ManualConfig";
  spec?: AwsKmsCredentialSpec;
}

export type AwsKmsConnectorDTO = ConnectorConfigDTO & {
  credential?: AwsKmsConnectorCredential;
  kmsArn: string;
  region?: string;
  delegateSelectors?: string[];
  default?: boolean;
};

export interface AwsKmsCredentialSpec {
  [key: string]: any;
}

export type AwsKmsCredentialSpecAssumeIAM = AwsKmsCredentialSpec & {
  delegateSelectors: string[];
};

export type AwsKmsCredentialSpecAssumeSTS = AwsKmsCredentialSpec & {
  delegateSelectors: string[];
  roleArn: string;
  externalName?: string;
  assumeStsRoleDuration?: number;
};

export type AwsKmsCredentialSpecManualConfig = AwsKmsCredentialSpec & {
  accessKey: string;
  secretKey: string;
};

export type AwsManualConfigSpec = AwsCredentialSpec & {
  accessKey?: string;
  accessKeyRef?: string;
  secretKeyRef: string;
};

export type AwsSMCredentialSpecAssumeIAM = AwsSecretManagerCredentialSpec & {
  [key: string]: any;
};

export type AwsSMCredentialSpecAssumeSTS = AwsSecretManagerCredentialSpec & {
  roleArn: string;
  externalId?: string;
  assumeStsRoleDuration?: number;
};

export type AwsSMCredentialSpecManualConfig = AwsSecretManagerCredentialSpec & {
  accessKey: string;
  secretKey: string;
};

export interface AwsSecretManagerCredential {
  type: "AssumeIAMRole" | "AssumeSTSRole" | "ManualConfig";
  spec?: AwsSecretManagerCredentialSpec;
}

export interface AwsSecretManagerCredentialSpec {
  [key: string]: any;
}

export type AwsSecretManagerDTO = ConnectorConfigDTO & {
  credential: AwsSecretManagerCredential;
  region: string;
  secretNamePrefix?: string;
  delegateSelectors?: string[];
  default?: boolean;
};

export type AzureKeyVaultConnectorDTO = ConnectorConfigDTO & {
  clientId: string;
  secretKey: string;
  tenantId: string;
  vaultName: string;
  subscription: string;
  azureEnvironmentType?: "AZURE" | "AZURE_US_GOVERNMENT";
  delegateSelectors?: string[];
  default?: boolean;
};

export interface BillingExportSpec {
  storageAccountName: string;
  containerName: string;
  directoryName: string;
  reportName: string;
  subscriptionId: string;
}

export interface BitbucketApiAccess {
  type: "UsernameToken";
  spec: BitbucketApiAccessSpecDTO;
}

export interface BitbucketApiAccessSpecDTO {
  [key: string]: any;
}

export interface BitbucketAuthentication {
  type: "Http" | "Ssh";
  spec: BitbucketCredentialsDTO;
}

export type BitbucketConnector = ConnectorConfigDTO & {
  url: string;
  validationRepo?: string;
  authentication: BitbucketAuthentication;
  apiAccess?: BitbucketApiAccess;
  delegateSelectors?: string[];
  type: "Account" | "Repo";
};

export interface BitbucketCredentialsDTO {
  [key: string]: any;
}

export type BitbucketHttpCredentials = BitbucketCredentialsDTO & {
  type: "UsernamePassword";
  spec: BitbucketHttpCredentialsSpecDTO;
};

export interface BitbucketHttpCredentialsSpecDTO {
  [key: string]: any;
}

export type BitbucketSshCredentials = BitbucketCredentialsDTO & {
  sshKeyRef: string;
};

export type BitbucketUsernamePassword = BitbucketHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type BitbucketUsernameTokenApiAccess = BitbucketApiAccessSpecDTO & {
  username?: string;
  usernameRef?: string;
  tokenRef: string;
};

export type CEAwsConnector = ConnectorConfigDTO & {
  crossAccountAccess: CrossAccountAccess;
  curAttributes?: AwsCurAttributes;
  awsAccountId?: string;
  featuresEnabled?: ("BILLING" | "OPTIMIZATION" | "VISIBILITY")[];
};

export type CEAzureConnector = ConnectorConfigDTO & {
  featuresEnabled?: ("BILLING" | "OPTIMIZATION" | "VISIBILITY")[];
  tenantId: string;
  subscriptionId: string;
  billingExportSpec?: BillingExportSpec;
};

export type CEKubernetesClusterConfig = ConnectorConfigDTO & {
  connectorRef: string;
  featuresEnabled?: ("BILLING" | "OPTIMIZATION" | "VISIBILITY")[];
};

export interface ConnectorActivityDetails {
  lastActivityTime?: number;
}

export interface ConnectorConfigDTO {
  [key: string]: any;
}

export interface ConnectorConnectivityDetails {
  status?: "SUCCESS" | "FAILURE" | "PARTIAL" | "UNKNOWN";
  errorSummary?: string;
  errors?: ErrorDetail[];
  testedAt?: number;
  lastTestedAt?: number;
  lastConnectedAt?: number;
}

export interface ConnectorInfoDTO {
  name: string;
  identifier: string;
  description?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  tags?: {
    [key: string]: string;
  };
  type:
    | "K8sCluster"
    | "Git"
    | "Splunk"
    | "AppDynamics"
    | "Prometheus"
    | "Dynatrace"
    | "Vault"
    | "AzureKeyVault"
    | "DockerRegistry"
    | "Local"
    | "AwsKms"
    | "GcpKms"
    | "AwsSecretManager"
    | "Gcp"
    | "Aws"
    | "Artifactory"
    | "Jira"
    | "Nexus"
    | "Github"
    | "Gitlab"
    | "Bitbucket"
    | "Codecommit"
    | "CEAws"
    | "CEAzure"
    | "GcpCloudCost"
    | "CEK8sCluster"
    | "HttpHelmRepo"
    | "NewRelic"
    | "Datadog"
    | "SumoLogic"
    | "PagerDuty";
  spec: ConnectorConfigDTO;
}

export interface ConnectorResponse {
  connector?: ConnectorInfoDTO;
  createdAt?: number;
  lastModifiedAt?: number;
  status?: ConnectorConnectivityDetails;
  activityDetails?: ConnectorActivityDetails;
  harnessManaged?: boolean;
  gitDetails?: EntityGitDetails;
}

export interface CrossAccountAccess {
  crossAccountRoleArn: string;
  externalId?: string;
}

export type DatadogConnectorDTO = ConnectorConfigDTO & {
  url: string;
  applicationKeyRef: string;
  apiKeyRef: string;
  delegateSelectors?: string[];
};

export interface DockerAuthCredentialsDTO {
  [key: string]: any;
}

export interface DockerAuthenticationDTO {
  type: "UsernamePassword" | "Anonymous";
  spec?: DockerAuthCredentialsDTO;
}

export type DockerConnectorDTO = ConnectorConfigDTO & {
  dockerRegistryUrl: string;
  providerType: "DockerHub" | "Harbor" | "Quay" | "Other";
  auth?: DockerAuthenticationDTO;
  delegateSelectors?: string[];
};

export type DockerUserNamePasswordDTO = DockerAuthCredentialsDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type DynatraceConnectorDTO = ConnectorConfigDTO & {
  url: string;
  apiTokenRef: string;
  delegateSelectors?: string[];
};

export interface EntityGitDetails {
  objectId?: string;
  branch?: string;
  repoIdentifier?: string;
  rootFolder?: string;
  filePath?: string;
}

export interface GcpBillingExportSpec {
  datasetId: string;
}

export type GcpCloudCostConnector = ConnectorConfigDTO & {
  featuresEnabled?: ("BILLING" | "OPTIMIZATION" | "VISIBILITY")[];
  projectId: string;
  serviceAccountEmail: string;
  billingExportSpec?: GcpBillingExportSpec;
};

export type GcpConnector = ConnectorConfigDTO & {
  credential?: GcpConnectorCredential;
  delegateSelectors?: string[];
};

export interface GcpConnectorCredential {
  type: "InheritFromDelegate" | "ManualConfig";
  spec?: GcpCredentialSpec;
}

export interface GcpCredentialSpec {
  [key: string]: any;
}

export type GcpKmsConnectorDTO = ConnectorConfigDTO & {
  projectId?: string;
  region?: string;
  keyRing?: string;
  keyName?: string;
  credentials: string;
  delegateSelectors?: string[];
  default?: boolean;
};

export type GcpManualDetails = GcpCredentialSpec & {
  secretKeyRef: string;
};

export interface GitAuthenticationDTO {
  [key: string]: any;
}

export type GitConfigDTO = ConnectorConfigDTO & {
  url: string;
  validationRepo?: string;
  branchName?: string;
  delegateSelectors?: string[];
  type: "Http" | "Ssh";
  connectionType: "Account" | "Repo";
  spec: GitAuthenticationDTO;
};

export type GitHTTPAuthenticationDTO = GitAuthenticationDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type GitSSHAuthenticationDTO = GitAuthenticationDTO & {
  sshKeyRef: string;
};

export interface GithubApiAccess {
  type: "GithubApp" | "Token";
  spec?: GithubApiAccessSpecDTO;
}

export interface GithubApiAccessSpecDTO {
  [key: string]: any;
}

export type GithubAppSpec = GithubApiAccessSpecDTO & {
  installationId: string;
  applicationId: string;
  privateKeyRef: string;
};

export interface GithubAuthentication {
  type: "Http" | "Ssh";
  spec: GithubCredentialsDTO;
}

export type GithubConnector = ConnectorConfigDTO & {
  url: string;
  validationRepo?: string;
  authentication: GithubAuthentication;
  apiAccess?: GithubApiAccess;
  delegateSelectors?: string[];
  type: "Account" | "Repo";
};

export interface GithubCredentialsDTO {
  [key: string]: any;
}

export type GithubHttpCredentials = GithubCredentialsDTO & {
  type: "UsernamePassword" | "UsernameToken";
  spec: GithubHttpCredentialsSpecDTO;
};

export interface GithubHttpCredentialsSpecDTO {
  [key: string]: any;
}

export type GithubSshCredentials = GithubCredentialsDTO & {
  sshKeyRef: string;
};

export type GithubTokenSpec = GithubApiAccessSpecDTO & {
  tokenRef: string;
};

export type GithubUsernamePassword = GithubHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type GithubUsernameToken = GithubHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  tokenRef: string;
};

export interface GitlabApiAccess {
  type: "Token";
  spec?: GitlabApiAccessSpecDTO;
}

export interface GitlabApiAccessSpecDTO {
  [key: string]: any;
}

export interface GitlabAuthentication {
  type: "Http" | "Ssh";
  spec: GitlabCredentialsDTO;
}

export type GitlabConnector = ConnectorConfigDTO & {
  url: string;
  validationRepo?: string;
  authentication: GitlabAuthentication;
  apiAccess?: GitlabApiAccess;
  delegateSelectors?: string[];
  type: "Account" | "Repo";
};

export interface GitlabCredentialsDTO {
  [key: string]: any;
}

export type GitlabHttpCredentials = GitlabCredentialsDTO & {
  type: "UsernamePassword" | "UsernameToken" | "Kerberos";
  spec: GitlabHttpCredentialsSpecDTO;
};

export interface GitlabHttpCredentialsSpecDTO {
  [key: string]: any;
}

export type GitlabKerberos = GitlabHttpCredentialsSpecDTO & {
  kerberosKeyRef: string;
};

export type GitlabSshCredentials = GitlabCredentialsDTO & {
  sshKeyRef: string;
};

export type GitlabTokenSpec = GitlabApiAccessSpecDTO & {
  tokenRef: string;
};

export type GitlabUsernamePassword = GitlabHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type GitlabUsernameToken = GitlabHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  tokenRef: string;
};

export interface HttpHelmAuthCredentialsDTO {
  [key: string]: any;
}

export interface HttpHelmAuthenticationDTO {
  type: "UsernamePassword" | "Anonymous";
  spec?: HttpHelmAuthCredentialsDTO;
}

export type HttpHelmConnectorDTO = ConnectorConfigDTO & {
  helmRepoUrl: string;
  auth?: HttpHelmAuthenticationDTO;
  delegateSelectors?: string[];
};

export type HttpHelmUsernamePasswordDTO = HttpHelmAuthCredentialsDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type JiraConnector = ConnectorConfigDTO & {
  jiraUrl: string;
  username?: string;
  usernameRef?: string;
  passwordRef: string;
  delegateSelectors?: string[];
};

export interface KubernetesAuthCredentialDTO {
  [key: string]: any;
}

export interface KubernetesAuthDTO {
  type:
    | "UsernamePassword"
    | "ClientKeyCert"
    | "ServiceAccount"
    | "OpenIdConnect";
  spec: KubernetesAuthCredentialDTO;
}

export type KubernetesClientKeyCertDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string;
  clientCertRef: string;
  clientKeyRef: string;
  clientKeyPassphraseRef?: string;
  clientKeyAlgo?: string;
};

export type KubernetesClusterConfigDTO = ConnectorConfigDTO & {
  credential: KubernetesCredentialDTO;
  delegateSelectors?: string[];
};

export type KubernetesClusterDetailsDTO = KubernetesCredentialSpecDTO & {
  masterUrl: string;
  auth: KubernetesAuthDTO;
};

export interface KubernetesCredentialDTO {
  type: "InheritFromDelegate" | "ManualConfig";
  spec?: KubernetesCredentialSpecDTO;
}

export interface KubernetesCredentialSpecDTO {
  [key: string]: any;
}

export type KubernetesOpenIdConnectDTO = KubernetesAuthCredentialDTO & {
  oidcIssuerUrl?: string;
  oidcUsername?: string;
  oidcUsernameRef?: string;
  oidcClientIdRef: string;
  oidcPasswordRef: string;
  oidcSecretRef?: string;
  oidcScopes?: string;
};

export type KubernetesServiceAccountDTO = KubernetesAuthCredentialDTO & {
  serviceAccountTokenRef: string;
};

export type KubernetesUserNamePasswordDTO = KubernetesAuthCredentialDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type LocalConnectorDTO = ConnectorConfigDTO & {
  default?: boolean;
};

export type NewRelicConnectorDTO = ConnectorConfigDTO & {
  newRelicAccountId: string;
  url: string;
  apiKeyRef: string;
  delegateSelectors?: string[];
};

export interface NexusAuthCredentials {
  [key: string]: any;
}

export interface NexusAuthentication {
  type: "UsernamePassword" | "Anonymous";
  spec?: NexusAuthCredentials;
}

export type NexusConnector = ConnectorConfigDTO & {
  nexusServerUrl: string;
  version: string;
  auth?: NexusAuthentication;
  delegateSelectors?: string[];
};

export type NexusUsernamePasswordAuth = NexusAuthCredentials & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type PagerDutyConnectorDTO = ConnectorConfigDTO & {
  apiTokenRef: string;
  delegateSelectors?: string[];
};

export type PrometheusConnectorDTO = ConnectorConfigDTO & {
  url: string;
  delegateSelectors?: string[];
};

export interface ResponseConnectorResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type SplunkConnectorDTO = ConnectorConfigDTO & {
  splunkUrl: string;
  username?: string;
  accountId: string;
  delegateSelectors?: string[];
  passwordRef: string;
};

export type SumoLogicConnectorDTO = ConnectorConfigDTO & {
  url: string;
  accessIdRef: string;
  accessKeyRef: string;
  delegateSelectors?: string[];
};

export type VaultConnectorDTO = ConnectorConfigDTO & {
  authToken?: string;
  basePath?: string;
  vaultUrl?: string;
  renewalIntervalMinutes?: number;
  secretEngineManuallyConfigured?: boolean;
  secretEngineName?: string;
  appRoleId?: string;
  secretId?: string;
  secretEngineVersion?: number;
  delegateSelectors?: string[];
  accessType?: "APP_ROLE" | "TOKEN";
  default?: boolean;
  readOnly?: boolean;
};

export interface Connector {
  connector?: ConnectorInfoDTO;
}

export interface ResponseBoolean {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: boolean;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Page {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: { [key: string]: any }[];
  pageIndex?: number;
  empty?: boolean;
}

export interface PageConnectorResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ConnectorResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageConnectorResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageConnectorResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface CcmConnectorFilter {
  featuresEnabled?: ("BILLING" | "OPTIMIZATION" | "VISIBILITY")[];
  awsAccountId?: string;
  azureSubscriptionId?: string;
  azureTenantId?: string;
  gcpProjectId?: string;
  k8sConnectorRef?: string;
}

export type ConnectorFilterProperties = FilterProperties & {
  connectorNames?: string[];
  connectorIdentifiers?: string[];
  description?: string;
  types?: (
    | "K8sCluster"
    | "Git"
    | "Splunk"
    | "AppDynamics"
    | "Prometheus"
    | "Dynatrace"
    | "Vault"
    | "AzureKeyVault"
    | "DockerRegistry"
    | "Local"
    | "AwsKms"
    | "GcpKms"
    | "AwsSecretManager"
    | "Gcp"
    | "Aws"
    | "Artifactory"
    | "Jira"
    | "Nexus"
    | "Github"
    | "Gitlab"
    | "Bitbucket"
    | "Codecommit"
    | "CEAws"
    | "CEAzure"
    | "GcpCloudCost"
    | "CEK8sCluster"
    | "HttpHelmRepo"
    | "NewRelic"
    | "Datadog"
    | "SumoLogic"
    | "PagerDuty"
  )[];
  categories?: (
    | "CLOUD_PROVIDER"
    | "SECRET_MANAGER"
    | "CLOUD_COST"
    | "ARTIFACTORY"
    | "CODE_REPO"
    | "MONITORING"
    | "TICKETING"
  )[];
  connectivityStatuses?: ("SUCCESS" | "FAILURE" | "PARTIAL" | "UNKNOWN")[];
  inheritingCredentialsFromDelegate?: boolean;
  ccmConnectorFilter?: CcmConnectorFilter;
};

export interface ConnectorCatalogueItem {
  category?:
    | "CLOUD_PROVIDER"
    | "SECRET_MANAGER"
    | "CLOUD_COST"
    | "ARTIFACTORY"
    | "CODE_REPO"
    | "MONITORING"
    | "TICKETING";
  connectors?: (
    | "K8sCluster"
    | "Git"
    | "Splunk"
    | "AppDynamics"
    | "Prometheus"
    | "Dynatrace"
    | "Vault"
    | "AzureKeyVault"
    | "DockerRegistry"
    | "Local"
    | "AwsKms"
    | "GcpKms"
    | "AwsSecretManager"
    | "Gcp"
    | "Aws"
    | "Artifactory"
    | "Jira"
    | "Nexus"
    | "Github"
    | "Gitlab"
    | "Bitbucket"
    | "Codecommit"
    | "CEAws"
    | "CEAzure"
    | "GcpCloudCost"
    | "CEK8sCluster"
    | "HttpHelmRepo"
    | "NewRelic"
    | "Datadog"
    | "SumoLogic"
    | "PagerDuty"
  )[];
}

export interface ConnectorCatalogueResponse {
  catalogue?: ConnectorCatalogueItem[];
}

export interface ResponseConnectorCatalogueResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorCatalogueResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ConnectorStatistics {
  typeStats?: ConnectorTypeStatistics[];
  statusStats?: ConnectorStatusStatistics[];
}

export interface ConnectorStatusStatistics {
  status?: "SUCCESS" | "FAILURE" | "PARTIAL" | "UNKNOWN";
  count?: number;
}

export interface ConnectorTypeStatistics {
  type?:
    | "K8sCluster"
    | "Git"
    | "Splunk"
    | "AppDynamics"
    | "Prometheus"
    | "Dynatrace"
    | "Vault"
    | "AzureKeyVault"
    | "DockerRegistry"
    | "Local"
    | "AwsKms"
    | "GcpKms"
    | "AwsSecretManager"
    | "Gcp"
    | "Aws"
    | "Artifactory"
    | "Jira"
    | "Nexus"
    | "Github"
    | "Gitlab"
    | "Bitbucket"
    | "Codecommit"
    | "CEAws"
    | "CEAzure"
    | "GcpCloudCost"
    | "CEK8sCluster"
    | "HttpHelmRepo"
    | "NewRelic"
    | "Datadog"
    | "SumoLogic"
    | "PagerDuty";
  count?: number;
}

export interface ResponseConnectorStatistics {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorStatistics;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListConnectorResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorResponse[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface FieldValues {
  fieldValues?: {
    [key: string]: string[];
  };
}

export interface ResponseFieldValues {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: FieldValues;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type AuditFilterProperties = FilterProperties & {
  scopes?: ResourceScopeDTO[];
  resources?: ResourceDTO[];
  modules?: (
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE"
  )[];
  actions?: (
    | "CREATE"
    | "UPDATE"
    | "RESTORE"
    | "DELETE"
    | "UPSERT"
    | "INVITE"
    | "RESEND_INVITE"
    | "REVOKE_INVITE"
    | "ADD_COLLABORATOR"
    | "REMOVE_COLLABORATOR"
    | "ADD_MEMBERSHIP"
    | "REMOVE_MEMBERSHIP"
  )[];
  environments?: Environment[];
  principals?: Principal[];
  startTime?: number;
  endTime?: number;
};

export type DelegateFilterProperties = FilterProperties & {
  status?: "ENABLED" | "WAITING_FOR_APPROVAL" | "DISABLED" | "DELETED";
  description?: string;
  hostName?: string;
  delegateName?: string;
  delegateType?: string;
  delegateGroupIdentifier?: string;
};

export interface DelegateProfileFilterProperties {
  name?: string;
  identifier?: string;
  description?: string;
  approvalRequired?: boolean;
  selectors?: string[];
  tags?: {
    [key: string]: string;
  };
  filterType?:
    | "Connector"
    | "DelegateProfile"
    | "Delegate"
    | "PipelineSetup"
    | "PipelineExecution"
    | "Deployment"
    | "Audit";
}

export interface Environment {
  type: "PreProduction" | "Production";
  identifier: string;
}

export interface FilterDTO {
  name: string;
  identifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  filterProperties: FilterProperties;
  filterVisibility?: "EveryOne" | "OnlyCreator";
}

export interface FilterProperties {
  tags?: {
    [key: string]: string;
  };
  filterType?:
    | "Connector"
    | "DelegateProfile"
    | "Delegate"
    | "PipelineSetup"
    | "PipelineExecution"
    | "Deployment"
    | "Audit";
}

export interface NGTag {
  key: string;
  value: string;
}

export type PipelineFilterProperties = FilterProperties & {
  pipelineTags?: NGTag[];
  pipelineIdentifiers?: string[];
  name?: string;
  description?: string;
  moduleProperties?: {
    [key: string]: { [key: string]: any };
  };
};

export interface Principal {
  identifier: string;
  type: "USER" | "USER_GROUP" | "SERVICE" | "API_KEY" | "SERVICE_ACCOUNT";
}

export interface ResourceDTO {
  type: string;
  identifier: string;
  labels?: {
    [key: string]: string;
  };
}

export interface ResourceScopeDTO {
  accountIdentifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  labels?: {
    [key: string]: string;
  };
}

export interface ResponseFilterDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: FilterDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageFilterDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: FilterDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageFilterDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageFilterDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitBranchDTO {
  branchName?: string;
  branchSyncStatus?: "SYNCED" | "SYNCING" | "UNSYNCED";
}

export interface GitBranchListDTO {
  defaultBranch?: GitBranchDTO;
  branches?: PageGitBranchDTO;
}

export interface PageGitBranchDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: GitBranchDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponseGitBranchListDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GitBranchListDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EntityReference {
  repoIdentifier?: string;
  branch?: string;
  default?: boolean;
  identifier?: string;
  accountIdentifier?: string;
  projectIdentifier?: string;
  orgIdentifier?: string;
}

export interface GitSyncEntityDTO {
  entityName?: string;
  entityType?:
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "FeatureFlagStage"
    | "Template"
    | "Triggers"
    | "MonitoredService";
  entityIdentifier?: string;
  gitConnectorId?: string;
  repoUrl?: string;
  branch?: string;
  folderPath?: string;
  entityGitPath?: string;
  repoProviderType?: "github" | "gitlab" | "bitbucket" | "unknown";
  entityReference?: EntityReference;
  accountId?: string;
}

export interface GitSyncEntityListDTO {
  entityType?:
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "FeatureFlagStage"
    | "Template"
    | "Triggers"
    | "MonitoredService";
  count?: number;
  gitSyncEntities?: GitSyncEntityDTO[];
}

export type IdentifierRef = EntityReference & {
  scope?: "account" | "org" | "project" | "unknown";
  metadata?: {
    [key: string]: string;
  };
  isDefault?: boolean;
};

export type InputSetReference = EntityReference & {
  pipelineIdentifier?: string;
  isDefault?: boolean;
};

export interface ResponseListGitSyncEntityListDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GitSyncEntityListDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitEntityBranchFilterSummaryProperties {
  moduleType?:
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE";
  entityTypes?: (
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "FeatureFlagStage"
    | "Template"
    | "Triggers"
    | "MonitoredService"
  )[];
  searchTerm?: string;
}

export interface GitSyncRepoFiles {
  gitSyncConfigIdentifier?: string;
  gitSyncEntityLists?: GitSyncEntityListDTO[];
}

export interface GitSyncRepoFilesList {
  moduleType?:
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE";
  gitSyncRepoFilesList?: GitSyncRepoFiles[];
}

export interface ResponseGitSyncRepoFilesList {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GitSyncRepoFilesList;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitEntityFilterProperties {
  moduleType?:
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE";
  gitSyncConfigIdentifiers?: string[];
  entityTypes?: (
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "FeatureFlagStage"
    | "Template"
    | "Triggers"
    | "MonitoredService"
  )[];
  searchTerm?: string;
}

export interface PageGitSyncEntityListDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: GitSyncEntityListDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageGitSyncEntityListDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageGitSyncEntityListDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitSyncSettingsDTO {
  accountIdentifier: string;
  projectIdentifier: string;
  organizationIdentifier: string;
  executeOnDelegate: boolean;
}

export interface ResponseGitSyncSettingsDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GitSyncSettingsDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitFileContent {
  content?: string;
  objectId?: string;
}

export interface ResponseGitFileContent {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GitFileContent;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface CreatePRDTO {
  prNumber?: number;
}

export interface ResponseCreatePRDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: CreatePRDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitPRCreateRequest {
  sourceBranch: string;
  targetBranch: string;
  title: string;
  yamlGitConfigRef: string;
  accountIdentifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  useUserFromToken?: boolean;
}

export interface ResponseListString {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: string[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseSaasGitDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SaasGitDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SaasGitDTO {
  saasGit?: boolean;
}

export interface GitSyncConfig {
  identifier?: string;
  name?: string;
  projectIdentifier?: string;
  orgIdentifier?: string;
  gitConnectorRef?: string;
  repo?: string;
  branch?: string;
  gitConnectorType: "Github" | "Gitlab" | "Bitbucket";
  gitSyncFolderConfigDTOs?: GitSyncFolderConfigDTO[];
}

export interface GitSyncFolderConfigDTO {
  rootFolder?: string;
  isDefault?: boolean;
  identifier?: string;
  enabled?: boolean;
}

export interface GitEnabledDTO {
  connectivityMode?: "MANAGER" | "DELEGATE";
  gitSyncEnabled?: boolean;
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: { [key: string]: any };
  responseMessages?: ResponseMessage[];
}

export type CDModuleLicenseDTO = ModuleLicenseDTO & {
  cdLicenseType?: "SERVICES" | "SERVICE_INSTANCES";
  workloads?: number;
  serviceInstances?: number;
};

export type CEModuleLicenseDTO = ModuleLicenseDTO & {
  spendLimit?: number;
};

export type CFModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfUsers?: number;
  numberOfClientMAUs?: number;
};

export type CIModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfCommitters?: number;
};

export type CVModuleLicenseDTO = ModuleLicenseDTO & {};

export interface ModuleLicenseDTO {
  id?: string;
  accountIdentifier?: string;
  moduleType?:
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE";
  edition?: "FREE" | "TEAM" | "ENTERPRISE";
  licenseType?: "TRIAL" | "PAID";
  status?: "ACTIVE" | "DELETED" | "EXPIRED";
  startTime?: number;
  expiryTime?: number;
  createdAt?: number;
  lastModifiedAt?: number;
}

export interface ResponseModuleLicenseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ModuleLicenseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListModuleLicenseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ModuleLicenseDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type CDLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalWorkload?: number;
  totalServiceInstances?: number;
};

export type CELicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalSpendLimit?: number;
};

export type CFLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalClientMAUs?: number;
  totalFeatureFlagUnits?: number;
};

export type CILicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalDevelopers?: number;
};

export type CVLicenseSummaryDTO = LicensesWithSummaryDTO & {};

export interface LicensesWithSummaryDTO {
  edition?: "FREE" | "TEAM" | "ENTERPRISE";
  licenseType?: "TRIAL" | "PAID";
  moduleType?:
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE";
  maxExpiryTime?: number;
}

export interface ResponseLicensesWithSummaryDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: LicensesWithSummaryDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface AccountLicenseDTO {
  accountId?: string;
  moduleLicenses?: {
    [key: string]: ModuleLicenseDTO;
  };
  allModuleLicenses?: {
    [key: string]: ModuleLicenseDTO[];
  };
  createdAt?: number;
  lastUpdatedAt?: number;
}

export interface ResponseAccountLicenseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: AccountLicenseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface StartTrialDTO {
  moduleType:
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE";
}

export interface PageRoleAssignmentResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: RoleAssignmentResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageRoleAssignmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageRoleAssignmentResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RoleAssignment {
  identifier?: string;
  resourceGroupIdentifier: string;
  roleIdentifier: string;
  principal: Principal;
  disabled?: boolean;
  managed?: boolean;
}

export interface RoleAssignmentResponse {
  roleAssignment: RoleAssignment;
  scope: ScopeDTO;
  createdAt?: number;
  lastModifiedAt?: number;
  harnessManaged?: boolean;
}

export interface ScopeDTO {
  accountIdentifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
}

export interface RoleAssignmentFilter {
  resourceGroupFilter?: string[];
  roleFilter?: string[];
  principalTypeFilter?: (
    | "USER"
    | "USER_GROUP"
    | "SERVICE"
    | "API_KEY"
    | "SERVICE_ACCOUNT"
  )[];
  principalFilter?: Principal[];
  harnessManagedFilter?: boolean[];
  disabledFilter?: boolean[];
}

export interface ResponseRoleAssignmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: RoleAssignmentResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListRoleAssignmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: RoleAssignmentResponse[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface BatchRoleAssignmentCreateRequest {
  roleAssignments?: RoleAssignment[];
}

export interface RestResponseBoolean {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: boolean;
  responseMessages?: ResponseMessage[];
}

export type OAuthSettings = NGAuthSettings & {
  filter?: string;
  allowedProviders?: (
    | "AZURE"
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "GOOGLE"
    | "LINKEDIN"
  )[];
};

export interface Account {
  uuid: string;
  appId: string;
  createdBy?: EmbeddedUser;
  createdAt?: number;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt: number;
  companyName: string;
  nextGenEnabled?: boolean;
  accountName: string;
  whitelistedDomains?: string[];
  licenseId?: string;
  dataRetentionDurationMs?: number;
  licenseInfo?: LicenseInfo;
  ceLicenseInfo?: CeLicenseInfo;
  accountEvents?: AccountEvent[];
  subdomainUrl?: string;
  twoFactorAdminEnforced?: boolean;
  forImport?: boolean;
  migratedToClusterUrl?: string;
  defaultExperience?: "NG" | "CG";
  createdFromNG?: boolean;
  localEncryptionEnabled?: boolean;
  delegateConfiguration?: DelegateConfiguration;
  techStacks?: TechStack[];
  oauthEnabled?: boolean;
  accountPreferences?: AccountPreferences;
  cloudCostEnabled?: boolean;
  ceAutoCollectK8sEvents?: boolean;
  trialSignupOptions?: TrialSignupOptions;
  serviceGuardLimit?: number;
  serviceAccountConfig?: ServiceAccountConfig;
  defaults?: {
    [key: string]: string;
  };
  authenticationMechanism?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
  harnessSupportAccessAllowed?: boolean;
  povAccount?: boolean;
}

export interface AccountEvent {
  accountEventType?:
    | "APP_CREATED"
    | "SERVICE_CREATED"
    | "ENV_CREATED"
    | "WORKFLOW_CREATED"
    | "WORKFLOW_DEPLOYED"
    | "PIPELINE_DEPLOYED"
    | "DELEGATE_INSTALLED"
    | "CLOUD_PROVIDER_CREATED"
    | "ARTIFACT_REPO_CREATED"
    | "PIPELINE_CREATED"
    | "ARTIFACT_STREAM_ADDED"
    | "INFRA_MAPPING_ADDED"
    | "INFRA_DEFINITION_ADDED"
    | "CUSTOM";
  customMsg?: string;
  category?: string;
  properties?: {
    [key: string]: string;
  };
}

export interface AccountPermissions {
  permissions?: (
    | "ACCOUNT"
    | "LOGGED_IN"
    | "DELEGATE"
    | "NONE"
    | "APP"
    | "ALL_APP_ENTITIES"
    | "ENV"
    | "SERVICE"
    | "WORKFLOW"
    | "PIPELINE"
    | "DEPLOYMENT"
    | "APPLICATION_CREATE_DELETE"
    | "USER_PERMISSION_MANAGEMENT"
    | "ACCOUNT_MANAGEMENT"
    | "PROVISIONER"
    | "TEMPLATE_MANAGEMENT"
    | "USER_PERMISSION_READ"
    | "AUDIT_VIEWER"
    | "TAG_MANAGEMENT"
    | "CE_ADMIN"
    | "CE_VIEWER"
    | "MANAGE_CLOUD_PROVIDERS"
    | "MANAGE_CONNECTORS"
    | "MANAGE_APPLICATIONS"
    | "MANAGE_APPLICATION_STACKS"
    | "MANAGE_DELEGATES"
    | "MANAGE_ALERT_NOTIFICATION_RULES"
    | "MANAGE_DELEGATE_PROFILES"
    | "MANAGE_CONFIG_AS_CODE"
    | "MANAGE_SECRETS"
    | "MANAGE_SECRET_MANAGERS"
    | "MANAGE_SSH_AND_WINRM"
    | "MANAGE_AUTHENTICATION_SETTINGS"
    | "MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS"
    | "VIEW_USER_AND_USER_GROUPS_AND_API_KEYS"
    | "MANAGE_IP_WHITELIST"
    | "MANAGE_IP_WHITELISTING"
    | "MANAGE_DEPLOYMENT_FREEZES"
    | "ALLOW_DEPLOYMENTS_DURING_FREEZE"
    | "MANAGE_PIPELINE_GOVERNANCE_STANDARDS"
    | "MANAGE_API_KEYS"
    | "MANAGE_TAGS"
    | "MANAGE_CUSTOM_DASHBOARDS"
    | "CREATE_CUSTOM_DASHBOARDS"
    | "MANAGE_RESTRICTED_ACCESS"
  )[];
}

export interface AccountPreferences {
  delegateSecretsCacheTTLInHours?: number;
}

export interface AppPermission {
  permissionType?:
    | "ACCOUNT"
    | "LOGGED_IN"
    | "DELEGATE"
    | "NONE"
    | "APP"
    | "ALL_APP_ENTITIES"
    | "ENV"
    | "SERVICE"
    | "WORKFLOW"
    | "PIPELINE"
    | "DEPLOYMENT"
    | "APPLICATION_CREATE_DELETE"
    | "USER_PERMISSION_MANAGEMENT"
    | "ACCOUNT_MANAGEMENT"
    | "PROVISIONER"
    | "TEMPLATE_MANAGEMENT"
    | "USER_PERMISSION_READ"
    | "AUDIT_VIEWER"
    | "TAG_MANAGEMENT"
    | "CE_ADMIN"
    | "CE_VIEWER"
    | "MANAGE_CLOUD_PROVIDERS"
    | "MANAGE_CONNECTORS"
    | "MANAGE_APPLICATIONS"
    | "MANAGE_APPLICATION_STACKS"
    | "MANAGE_DELEGATES"
    | "MANAGE_ALERT_NOTIFICATION_RULES"
    | "MANAGE_DELEGATE_PROFILES"
    | "MANAGE_CONFIG_AS_CODE"
    | "MANAGE_SECRETS"
    | "MANAGE_SECRET_MANAGERS"
    | "MANAGE_SSH_AND_WINRM"
    | "MANAGE_AUTHENTICATION_SETTINGS"
    | "MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS"
    | "VIEW_USER_AND_USER_GROUPS_AND_API_KEYS"
    | "MANAGE_IP_WHITELIST"
    | "MANAGE_IP_WHITELISTING"
    | "MANAGE_DEPLOYMENT_FREEZES"
    | "ALLOW_DEPLOYMENTS_DURING_FREEZE"
    | "MANAGE_PIPELINE_GOVERNANCE_STANDARDS"
    | "MANAGE_API_KEYS"
    | "MANAGE_TAGS"
    | "MANAGE_CUSTOM_DASHBOARDS"
    | "CREATE_CUSTOM_DASHBOARDS"
    | "MANAGE_RESTRICTED_ACCESS";
  appFilter?: GenericEntityFilter;
  entityFilter?: Filter;
  actions?: (
    | "ALL"
    | "CREATE"
    | "READ"
    | "UPDATE"
    | "DELETE"
    | "EXECUTE"
    | "EXECUTE_WORKFLOW"
    | "EXECUTE_PIPELINE"
    | "EXECUTE_WORKFLOW_ROLLBACK"
    | "DEFAULT"
  )[];
}

export interface AuthenticationSettingsResponse {
  ngAuthSettings?: NGAuthSettings[];
  whitelistedDomains?: string[];
  authenticationMechanism?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
  twoFactorEnabled?: boolean;
}

export interface CeLicenseInfo {
  licenseType?: "FULL_TRIAL" | "LIMITED_TRIAL" | "PAID";
  expiryTime?: number;
}

export interface DelegateConfiguration {
  delegateVersions?: string[];
  action?: "SELF_DESTRUCT";
}

export interface EmbeddedUser {
  uuid?: string;
  name?: string;
  email?: string;
}

export type EnvFilter = Filter & {
  filterTypes?: string[];
};

export interface Filter {
  ids?: string[];
}

export type GenericEntityFilter = Filter & {
  filterType?: string;
};

export type LDAPSettings = NGAuthSettings & {
  connectionSettings: LdapConnectionSettings;
  identifier: string;
  userSettingsList?: LdapUserSettings[];
  groupSettingsList?: LdapGroupSettings[];
};

export interface LdapConnectionSettings {
  host: string;
  port?: number;
  sslEnabled?: boolean;
  referralsEnabled?: boolean;
  maxReferralHops?: number;
  bindDN?: string;
  bindPassword?: string;
  connectTimeout?: number;
  responseTimeout?: number;
  useRecursiveGroupMembershipSearch?: boolean;
}

export interface LdapGroupSettings {
  baseDN?: string;
  searchFilter?: string;
  nameAttr?: string;
  descriptionAttr?: string;
  userMembershipAttr?: string;
  referencedUserAttr?: string;
}

export interface LdapUserSettings {
  baseDN?: string;
  searchFilter?: string;
  emailAttr?: string;
  displayNameAttr?: string;
  groupMembershipAttr?: string;
}

export interface LicenseInfo {
  accountType?: string;
  accountStatus?: string;
  expiryTime?: number;
  licenseUnits?: number;
}

export interface LoginSettings {
  uuid: string;
  accountId: string;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt?: number;
  userLockoutPolicy: UserLockoutPolicy;
  passwordExpirationPolicy: PasswordExpirationPolicy;
  passwordStrengthPolicy: PasswordStrengthPolicy;
}

export interface NGAuthSettings {
  settingsType?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
}

export interface NotificationSettings {
  useIndividualEmails?: boolean;
  sendMailToNewMembers?: boolean;
  emailAddresses: string[];
  slackConfig: SlackNotificationSetting;
  pagerDutyIntegrationKey?: string;
  microsoftTeamsWebhookUrl?: string;
}

export interface PasswordExpirationPolicy {
  enabled?: boolean;
  daysBeforePasswordExpires?: number;
  daysBeforeUserNotifiedOfPasswordExpiration?: number;
}

export interface PasswordStrengthPolicy {
  enabled?: boolean;
  minNumberOfCharacters?: number;
  minNumberOfUppercaseCharacters?: number;
  minNumberOfLowercaseCharacters?: number;
  minNumberOfSpecialCharacters?: number;
  minNumberOfDigits?: number;
}

export interface RestResponseAuthenticationSettingsResponse {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: AuthenticationSettingsResponse;
  responseMessages?: ResponseMessage[];
}

export type SAMLSettings = NGAuthSettings & {
  origin: string;
  identifier: string;
  logoutUrl?: string;
  groupMembershipAttr?: string;
  displayName?: string;
  authorizationEnabled?: boolean;
};

export interface SlackNotificationSetting {
  name?: string;
  outgoingWebhookUrl: string;
}

export interface TechStack {
  category?: string;
  technology?: string;
}

export interface TrialSignupOptions {
  productsSelected?: ("CD" | "CE" | "CI")[];
  assistedOption?: boolean;
}

export interface User {
  uuid: string;
  appId: string;
  createdBy?: EmbeddedUser;
  createdAt?: number;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt: number;
  name?: string;
  givenName?: string;
  familyName?: string;
  email?: string;
  companyName?: string;
  accountName?: string;
  userGroups?: UserGroup[];
  accounts?: Account[];
  pendingAccounts?: Account[];
  supportAccounts?: Account[];
  lastLogin?: number;
  firstLogin?: boolean;
  password?: string[];
  token?: string;
  twoFactorJwtToken?: string;
  emailVerified?: boolean;
  passwordExpired?: boolean;
  userLocked?: boolean;
  statsFetchedOn?: number;
  lastAccountId?: string;
  defaultAccountId?: string;
  lastAppId?: string;
  disabled?: boolean;
  imported?: boolean;
  userLockoutInfo?: UserLockoutInfo;
  twoFactorAuthenticationEnabled?: boolean;
  twoFactorAuthenticationMechanism?: "TOTP";
  oauthProvider?: string;
  reportedSegmentTracks?: string[];
  utmInfo?: UtmInfo;
  accountIds?: string[];
}

export interface UserGroup {
  id?: string;
  accountIdentifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  identifier?: string;
  isSsoLinked?: boolean;
  linkedSsoType?: "SAML" | "LDAP" | "OAUTH";
  linkedSsoId?: string;
  linkedSsoDisplayName?: string;
  ssoGroupId?: string;
  ssoGroupName?: string;
  name?: string;
  users: string[];
  notificationConfigs: NotificationSettingConfig[];
  harnessManaged?: boolean;
  description: string;
  tags: NGTag[];
  createdAt?: number;
  lastModifiedAt?: number;
  version?: number;
  deleted?: boolean;
}

export interface UserLockoutInfo {
  numberOfFailedLoginAttempts?: number;
  userLockedAt?: number;
}

export interface UserLockoutPolicy {
  enableLockoutPolicy?: boolean;
  numberOfFailedAttemptsBeforeLockout?: number;
  lockOutPeriod?: number;
  notifyUser?: boolean;
  userGroupsToNotify?: UserGroup[];
}

export type UsernamePasswordSettings = NGAuthSettings & {
  loginSettings: LoginSettings;
};

export interface UtmInfo {
  utmSource?: string;
  utmContent?: string;
  utmMedium?: string;
  utmTerm?: string;
  utmCampaign?: string;
}

export type WorkflowFilter = Filter & {
  filterTypes?: string[];
};

export interface RestResponseLoginSettings {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: LoginSettings;
  responseMessages?: ResponseMessage[];
}

export interface TwoFactorAdminOverrideSettings {
  adminOverrideTwoFactorEnabled?: boolean;
}

export interface RestResponsePasswordStrengthPolicy {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: PasswordStrengthPolicy;
  responseMessages?: ResponseMessage[];
}

export type LdapSettings = SSOSettings & {
  connectionSettings: LdapConnectionSettings;
  userSettings?: LdapUserSettings;
  groupSettings?: LdapGroupSettings;
  userSettingsList?: LdapUserSettings[];
  groupSettingsList?: LdapGroupSettings[];
};

export type OauthSettings = SSOSettings & {
  filter?: string;
  allowedProviders?: (
    | "AZURE"
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "GOOGLE"
    | "LINKEDIN"
  )[];
};

export interface RestResponseSSOConfig {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: SSOConfig;
  responseMessages?: ResponseMessage[];
}

export interface SSOConfig {
  accountId?: string;
  ssoSettings?: SSOSettings[];
  authenticationMechanism?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
}

export interface SSOSettings {
  uuid: string;
  appId: string;
  createdBy?: EmbeddedUser;
  createdAt?: number;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt: number;
  type: "SAML" | "LDAP" | "OAUTH";
  displayName?: string;
  url?: string;
  nextIteration?: number;
  accountId?: string;
}

export type SamlSettings = SSOSettings & {
  accountId: string;
  origin: string;
  logoutUrl?: string;
  groupMembershipAttr?: string;
  authorizationEnabled?: boolean;
};

export interface LoginTypeResponse {
  authenticationMechanism?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
  showCaptcha?: boolean;
  defaultExperience?: "NG" | "CG";
  ssorequest?: SSORequest;
  oauthEnabled?: boolean;
}

export interface RestResponseLoginTypeResponse {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: LoginTypeResponse;
  responseMessages?: ResponseMessage[];
}

export interface SSORequest {
  oauthProviderType?:
    | "AZURE"
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "GOOGLE"
    | "LINKEDIN";
  idpRedirectUrl?: string;
  oauthProviderTypes?: (
    | "AZURE"
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "GOOGLE"
    | "LINKEDIN"
  )[];
}

export interface InstanceCountDetailsByEnvTypeBase {
  totalInstances?: number;
  nonProdInstances?: number;
  prodInstances?: number;
}

export interface ResponseServiceDetailsInfoDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceDetailsInfoDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceDetailsDTO {
  serviceName?: string;
  serviceIdentifier?: string;
  deploymentTypeList?: string[];
  totalDeployments?: number;
  totalDeploymentChangeRate?: number;
  successRate?: number;
  successRateChangeRate?: number;
  failureRate?: number;
  failureRateChangeRate?: number;
  frequency?: number;
  frequencyChangeRate?: number;
  instanceCountDetails?: InstanceCountDetailsByEnvTypeBase;
  lastPipelineExecuted?: ServicePipelineInfo;
}

export interface ServiceDetailsInfoDTO {
  serviceDeploymentDetailsList?: ServiceDetailsDTO[];
}

export interface ServicePipelineInfo {
  pipelineExecutionId?: string;
  identifier?: string;
  name?: string;
  status?: string;
  lastExecutedAt?: number;
}

export interface ResponseTimeValuePairListDTOInteger {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: TimeValuePairListDTOInteger;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface TimeValuePair {
  timestamp?: number;
  value?: { [key: string]: any };
}

export interface TimeValuePairInteger {
  timestamp?: number;
  value?: number;
}

export interface TimeValuePairListDTO {
  timeValuePairList?: TimeValuePairObject[];
}

export interface TimeValuePairListDTOInteger {
  timeValuePairList?: TimeValuePairInteger[];
}

export interface TimeValuePairObject {
  timestamp?: number;
  value?: { [key: string]: any };
}

export interface ActiveServiceInstanceSummary {
  changeRate?: number;
  countDetails?: InstanceCountDetailsByEnvTypeBase;
}

export interface ResponseActiveServiceInstanceSummary {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ActiveServiceInstanceSummary;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EnvIdCountPair {
  envId?: string;
  count?: number;
}

export interface ResponseTimeValuePairListDTOEnvIdCountPair {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: TimeValuePairListDTOEnvIdCountPair;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface TimeValuePairEnvIdCountPair {
  timestamp?: number;
  value?: EnvIdCountPair;
}

export interface TimeValuePairListDTOEnvIdCountPair {
  timeValuePairList?: TimeValuePairEnvIdCountPair[];
}

export interface AuthorInfo {
  name?: string;
  url?: string;
}

export interface DeploymentsInfo {
  deployments?: ExecutionStatusInfo[];
}

export interface ExecutionStatusInfo {
  pipelineName?: string;
  pipelineIdentifier?: string;
  startTs?: number;
  endTs?: number;
  status?: string;
  planExecutionId?: string;
  gitInfo?: GitInfo;
  triggerType?: string;
  author?: AuthorInfo;
  serviceInfoList?: ServiceDeploymentInfo[];
}

export interface GitInfo {
  sourceBranch?: string;
  targetBranch?: string;
  commit?: string;
  commitID?: string;
  eventType?: string;
  repoName?: string;
}

export interface ResponseDeploymentsInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: DeploymentsInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceDeploymentInfo {
  serviceName?: string;
  serviceTag?: string;
}

export interface DashboardWorkloadDeployment {
  workloadDeploymentInfoList?: WorkloadDeploymentInfo[];
}

export interface LastWorkloadInfo {
  startTime?: number;
  endTime?: number;
  deploymentType?: string;
  status?: string;
}

export interface ResponseDashboardWorkloadDeployment {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: DashboardWorkloadDeployment;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface WorkloadCountInfo {
  count?: number;
}

export interface WorkloadDateCountInfo {
  date?: number;
  execution?: WorkloadCountInfo;
}

export interface WorkloadDeploymentInfo {
  serviceName?: string;
  serviceId?: string;
  lastExecuted?: LastWorkloadInfo;
  deploymentTypeList?: string[];
  totalDeployments?: number;
  totalDeploymentChangeRate?: number;
  percentSuccess?: number;
  rateSuccess?: number;
  failureRate?: number;
  failureRateChangeRate?: number;
  frequency?: number;
  frequencyChangeRate?: number;
  lastPipelineExecutionId?: string;
  workload?: WorkloadDateCountInfo[];
}

export interface InfrastructureDetails {
  [key: string]: any;
}

export interface InstanceDetailsByBuildId {
  buildId?: string;
  instances?: InstanceDetailsDTO[];
}

export interface InstanceDetailsDTO {
  podName?: string;
  artifactName?: string;
  connectorRef?: string;
  infrastructureDetails?: InfrastructureDetails;
  terraformInstance?: string;
  deployedAt?: number;
  deployedById?: string;
  deployedByName?: string;
  pipelineExecutionName?: string;
}

export interface InstancesByBuildIdList {
  instancesByBuildIdList?: InstanceDetailsByBuildId[];
}

export type K8sInfrastructureDetails = InfrastructureDetails & {
  namespace?: string;
  releaseName?: string;
};

export interface ResponseInstancesByBuildIdList {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: InstancesByBuildIdList;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface InstanceCountDetailsByEnvTypeAndServiceId {
  instanceCountDetailsByEnvTypeBaseMap?: {
    [key: string]: InstanceCountDetailsByEnvTypeBase;
  };
}

export interface ResponseInstanceCountDetailsByEnvTypeAndServiceId {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: InstanceCountDetailsByEnvTypeAndServiceId;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Deployment {
  count?: number;
}

export interface DeploymentDateAndCount {
  time?: number;
  deployments?: Deployment;
}

export interface DeploymentInfo {
  count?: number;
  rate?: number;
  countList?: DeploymentDateAndCount[];
}

export interface HealthDeploymentDashboard {
  healthDeploymentInfo?: HealthDeploymentInfo;
}

export interface HealthDeploymentInfo {
  total?: TotalDeploymentInfo;
  success?: DeploymentInfo;
  failure?: DeploymentInfo;
}

export interface ResponseHealthDeploymentDashboard {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: HealthDeploymentDashboard;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface TotalDeploymentInfo {
  count?: number;
  production?: number;
  nonProduction?: number;
  countList?: DeploymentDateAndCount[];
}

export interface DeploymentChangeRates {
  failureRate?: number;
  failureRateChangeRate?: number;
  frequency?: number;
  frequencyChangeRate?: number;
}

export interface DeploymentCount {
  total?: number;
  success?: number;
  failure?: number;
}

export interface ResponseServiceDeploymentInfoDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceDeploymentInfoDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceDeployment {
  time?: number;
  deployments?: DeploymentCount;
  rate?: DeploymentChangeRates;
}

export interface ServiceDeploymentInfoDTO {
  serviceDeploymentList?: ServiceDeployment[];
}

export interface ResponseServiceDeploymentListInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceDeploymentListInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceDeploymentListInfo {
  startTime?: number;
  endTime?: number;
  totalDeployments?: number;
  failureRate?: number;
  frequency?: number;
  failureRateChangeRate?: number;
  totalDeploymentsChangeRate?: number;
  frequencyChangeRate?: number;
  serviceDeploymentList?: ServiceDeployment[];
}

export interface ExecutionDeployment {
  time?: number;
  deployments?: DeploymentCount;
}

export interface ExecutionDeploymentInfo {
  executionDeploymentList?: ExecutionDeployment[];
}

export interface ResponseExecutionDeploymentInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ExecutionDeploymentInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface DashboardExecutionStatusInfo {
  failure?: ExecutionStatusInfo[];
  pending?: ExecutionStatusInfo[];
  active?: ExecutionStatusInfo[];
}

export interface ResponseDashboardExecutionStatusInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: DashboardExecutionStatusInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface BuildIdAndInstanceCount {
  buildId?: string;
  count?: number;
}

export interface EnvBuildIdAndInstanceCountInfo {
  envId?: string;
  envName?: string;
  buildIdAndInstanceCountList?: BuildIdAndInstanceCount[];
}

export interface EnvBuildIdAndInstanceCountInfoList {
  envBuildIdAndInstanceCountInfoList?: EnvBuildIdAndInstanceCountInfo[];
}

export interface ResponseEnvBuildIdAndInstanceCountInfoList {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EnvBuildIdAndInstanceCountInfoList;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Activity {
  accountIdentifier?: string;
  referredEntity?: EntityDetail;
  type:
    | "CONNECTIVITY_CHECK"
    | "ENTITY_USAGE"
    | "ENTITY_CREATION"
    | "ENTITY_UPDATE";
  activityStatus: "SUCCESS" | "FAILED";
  detail?: ActivityDetail;
  activityTime: number;
  description?: string;
}

export interface ActivityDetail {
  [key: string]: any;
}

export interface EntityDetail {
  type?:
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "FeatureFlagStage"
    | "Template"
    | "Triggers"
    | "MonitoredService";
  entityRef?: EntityReference;
  name?: string;
}

export interface PageActivity {
  totalElements?: number;
  totalPages?: number;
  last?: boolean;
  pageable?: Pageable;
  numberOfElements?: number;
  size?: number;
  content?: Activity[];
  number?: number;
  first?: boolean;
  sort?: Sort;
  empty?: boolean;
}

export interface Pageable {
  pageSize?: number;
  offset?: number;
  sort?: Sort;
  paged?: boolean;
  unpaged?: boolean;
  pageNumber?: number;
}

export interface ResponsePageActivity {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageActivity;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Sort {
  sorted?: boolean;
  unsorted?: boolean;
  empty?: boolean;
}

export interface ResponseActivity {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: Activity;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ConnectivityCheckSummary {
  successCount?: number;
  failureCount?: number;
  startTime?: number;
  endTime?: number;
}

export interface ResponseConnectivityCheckSummary {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectivityCheckSummary;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ActivitySummary {
  get_id?: number;
  startTime?: number;
  endTime?: number;
  heartBeatFailuresCount?: number;
  successfulActivitiesCount?: number;
  failedActivitiesCount?: number;
}

export interface PageActivitySummary {
  totalElements?: number;
  totalPages?: number;
  last?: boolean;
  pageable?: Pageable;
  numberOfElements?: number;
  size?: number;
  content?: ActivitySummary[];
  number?: number;
  first?: boolean;
  sort?: Sort;
  empty?: boolean;
}

export interface ResponsePageActivitySummary {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageActivitySummary;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface DockerBuildDetailsDTO {
  tag?: string;
  buildUrl?: string;
  metadata?: {
    [key: string]: string;
  };
  labels?: {
    [key: string]: string;
  };
  imagePath?: string;
}

export interface DockerResponseDTO {
  buildDetailsList?: DockerBuildDetailsDTO[];
}

export interface ResponseDockerResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: DockerResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface DockerRequestDTO {
  tag?: string;
  tagRegex?: string;
  tagsList?: string[];
}

export interface ResponseDockerBuildDetailsDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: DockerBuildDetailsDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EcrListImagesDTO {
  images?: string[];
}

export interface ResponseEcrListImagesDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EcrListImagesDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EcrBuildDetailsDTO {
  tag?: string;
  buildUrl?: string;
  metadata?: {
    [key: string]: string;
  };
  labels?: {
    [key: string]: string;
  };
  imagePath?: string;
}

export interface EcrResponseDTO {
  buildDetailsList?: EcrBuildDetailsDTO[];
}

export interface ResponseEcrResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EcrResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseEcrBuildDetailsDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EcrBuildDetailsDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EcrRequestDTO {
  tag?: string;
  tagRegex?: string;
  tagsList?: string[];
  region?: string;
}

export interface GcrBuildDetailsDTO {
  tag?: string;
  buildUrl?: string;
  metadata?: {
    [key: string]: string;
  };
  labels?: {
    [key: string]: string;
  };
  imagePath?: string;
}

export interface GcrResponseDTO {
  buildDetailsList?: GcrBuildDetailsDTO[];
}

export interface ResponseGcrResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GcrResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseGcrBuildDetailsDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GcrBuildDetailsDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GcrRequestDTO {
  tag?: string;
  tagRegex?: string;
  tagsList?: string[];
  registryHostname?: string;
}

export interface ResponseMapStringString {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: {
    [key: string]: string;
  };
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface DelegateProfileDetailsNg {
  uuid?: string;
  accountId?: string;
  name?: string;
  description?: string;
  primary?: boolean;
  approvalRequired?: boolean;
  startupScript?: string;
  scopingRules?: ScopingRuleDetailsNg[];
  selectors?: string[];
  createdBy?: EmbeddedUserDetails;
  lastUpdatedBy?: EmbeddedUserDetails;
  createdAt?: number;
  lastUpdatedAt?: number;
  identifier?: string;
  numberOfDelegates?: number;
  orgIdentifier?: string;
  projectIdentifier?: string;
}

export interface EmbeddedUserDetails {
  uuid?: string;
  name?: string;
  email?: string;
}

export interface RestResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: DelegateProfileDetailsNg;
  responseMessages?: ResponseMessage[];
}

export interface ScopingRuleDetailsNg {
  description?: string;
  environmentTypeId?: string;
  environmentIds?: string[];
}

export interface RestResponsePageResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: DelegateProfileDetailsNg[];
  responseMessages?: ResponseMessage[];
}

export interface RestResponseVoid {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: Void;
  responseMessages?: ResponseMessage[];
}

export interface Void {
  [key: string]: any;
}

export type EntityReferredByPipelineSetupUsageDetail = SetupUsageDetail & {
  identifier?: string;
  referenceType?: string;
};

export interface EntitySetupUsageDTO {
  accountIdentifier?: string;
  referredEntity?: EntityDetail;
  referredByEntity: EntityDetail;
  detail?: SetupUsageDetail;
  createdAt?: number;
}

export interface PageEntitySetupUsageDTO {
  totalElements?: number;
  totalPages?: number;
  last?: boolean;
  pageable?: Pageable;
  numberOfElements?: number;
  size?: number;
  content?: EntitySetupUsageDTO[];
  number?: number;
  first?: boolean;
  sort?: Sort;
  empty?: boolean;
}

export interface ResponsePageEntitySetupUsageDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageEntitySetupUsageDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type SecretReferredByConnectorSetupUsageDetail = SetupUsageDetail & {
  fieldName?: string;
};

export interface SetupUsageDetail {
  [key: string]: any;
}

export interface EnvironmentResponseDTO {
  accountId?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  identifier?: string;
  name?: string;
  description?: string;
  color?: string;
  type?: "PreProduction" | "Production";
  deleted?: boolean;
  tags?: {
    [key: string]: string;
  };
  version?: number;
}

export interface ResponseEnvironmentResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EnvironmentResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EnvironmentRequestDTO {
  orgIdentifier: string;
  projectIdentifier: string;
  identifier: string;
  tags?: {
    [key: string]: string;
  };
  name?: string;
  description?: string;
  color?: string;
  type: "PreProduction" | "Production";
  version?: number;
}

export interface PageEnvironmentResponseDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: EnvironmentResponseDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageEnvironmentResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageEnvironmentResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EnvironmentResponse {
  environment?: EnvironmentResponseDTO;
  createdAt?: number;
  lastModifiedAt?: number;
}

export interface ResponseEnvironmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EnvironmentResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageEnvironmentResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: EnvironmentResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageEnvironmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageEnvironmentResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListEnvironmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EnvironmentResponse[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Invite {
  id: string;
  name: string;
  email: string;
  accountIdentifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  roleBindings: RoleBinding[];
  inviteType: "USER_INITIATED_INVITE" | "ADMIN_INITIATED_INVITE";
  approved?: boolean;
}

export interface ResponseOptionalInvite {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: Invite;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RoleBinding {
  roleIdentifier: string;
  roleName: string;
  resourceGroupIdentifier?: string;
  resourceGroupName?: string;
  managedRole: boolean;
}

export interface PageInvite {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: Invite[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageInvite {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageInvite;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ACLAggregateFilter {
  resourceGroupIdentifiers?: string[];
  roleIdentifiers?: string[];
}

export interface ResponseInvite {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: Invite;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListInviteOperationResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: (
    | "ACCOUNT_INVITE_ACCEPTED_NEED_PASSWORD"
    | "ACCOUNT_INVITE_ACCEPTED"
    | "USER_INVITED_SUCCESSFULLY"
    | "USER_ALREADY_ADDED"
    | "USER_ALREADY_INVITED"
    | "FAIL"
    | "INVITE_EXPIRED"
    | "INVITE_INVALID"
  )[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface CreateInvite {
  users: string[];
  roleBindings: RoleBinding[];
  inviteType: "USER_INITIATED_INVITE" | "ADMIN_INITIATED_INVITE";
}

export interface GcpResponseDTO {
  clusterNames?: string[];
}

export interface ResponseGcpResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GcpResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ApiKeyDTO {
  identifier: string;
  name: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  apiKeyType: "USER" | "SERVICE_ACCOUNT";
  parentIdentifier: string;
  defaultTimeToExpireToken?: number;
  accountIdentifier: string;
  projectIdentifier?: string;
  orgIdentifier?: string;
}

export interface ResponseApiKeyDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ApiKeyDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListApiKeyDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ApiKeyDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ApiKeyAggregateDTO {
  apiKey: ApiKeyDTO;
  createdAt: number;
  lastModifiedAt: number;
  tokensCount?: number;
}

export interface PageApiKeyAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ApiKeyAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageApiKeyAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageApiKeyAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseApiKeyAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ApiKeyAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Organization {
  identifier: string;
  name: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
}

export interface OrganizationAggregateDTO {
  organizationResponse: OrganizationResponse;
  projectsCount?: number;
  connectorsCount?: number;
  secretsCount?: number;
  delegatesCount?: number;
  templatesCount?: number;
  admins?: UserMetadataDTO[];
  collaborators?: UserMetadataDTO[];
}

export interface OrganizationResponse {
  organization: Organization;
  createdAt?: number;
  lastModifiedAt?: number;
  harnessManaged?: boolean;
}

export interface ResponseOrganizationAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: OrganizationAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserMetadataDTO {
  name?: string;
  email: string;
  uuid: string;
  locked?: boolean;
}

export interface Project {
  orgIdentifier?: string;
  identifier: string;
  name: string;
  color?: string;
  modules?: (
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE"
  )[];
  description?: string;
  tags?: {
    [key: string]: string;
  };
}

export interface ProjectAggregateDTO {
  projectResponse: ProjectResponse;
  organization?: Organization;
  harnessManagedOrg?: boolean;
  admins?: UserMetadataDTO[];
  collaborators?: UserMetadataDTO[];
}

export interface ProjectResponse {
  project: Project;
  createdAt?: number;
  lastModifiedAt?: number;
}

export interface ResponseProjectAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ProjectAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type EmailConfigDTO = NotificationSettingConfigDTO & {
  groupEmail: string;
};

export type MicrosoftTeamsConfigDTO = NotificationSettingConfigDTO & {
  microsoftTeamsWebhookUrl: string;
};

export interface NotificationSettingConfigDTO {
  type?: "EMAIL" | "SLACK" | "PAGERDUTY" | "MSTEAMS";
}

export interface PageUserGroupAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserGroupAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export type PagerDutyConfigDTO = NotificationSettingConfigDTO & {
  pagerDutyKey: string;
};

export interface ResponsePageUserGroupAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserGroupAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RoleAssignmentMetadataDTO {
  identifier: string;
  roleIdentifier: string;
  roleName: string;
  resourceGroupIdentifier: string;
  resourceGroupName: string;
  managedRole: boolean;
  managedRoleAssignment: boolean;
}

export type SlackConfigDTO = NotificationSettingConfigDTO & {
  slackWebhookUrl: string;
};

export interface UserGroupAggregateDTO {
  userGroupDTO: UserGroupDTO;
  users?: UserMetadataDTO[];
  roleAssignmentsMetadataDTO?: RoleAssignmentMetadataDTO[];
  lastModifiedAt?: number;
}

export interface UserGroupDTO {
  accountIdentifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  identifier: string;
  name: string;
  users?: string[];
  notificationConfigs?: NotificationSettingConfigDTO[];
  linkedSsoId?: string;
  linkedSsoDisplayName?: string;
  ssoGroupId?: string;
  ssoGroupName?: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  ssoLinked?: boolean;
}

export interface ResponseListUserGroupAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserGroupAggregateDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface AggregateACLRequest {
  searchTerm?: string;
  resourceGroupFilter?: string[];
  roleFilter?: string[];
}

export interface ResponseUserGroupAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserGroupAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageProjectAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ProjectAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageProjectAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageProjectAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageOrganizationAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: OrganizationAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageOrganizationAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageOrganizationAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface AccountResourcesDTO {
  connectorsCount?: number;
  secretsCount?: number;
  delegatesCount?: number;
  templatesCount?: number;
}

export interface ResponseAccountResourcesDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: AccountResourcesDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type AzureKeyVaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  vaultNames?: string[];
};

export interface ResponseSecretManagerMetadataDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SecretManagerMetadataDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SecretManagerMetadataDTO {
  encryptionType?:
    | "LOCAL"
    | "KMS"
    | "GCP_KMS"
    | "AWS_SECRETS_MANAGER"
    | "AZURE_VAULT"
    | "CYBERARK"
    | "VAULT"
    | "GCP_SECRETS_MANAGER"
    | "CUSTOM"
    | "VAULT_SSH";
  spec?: SecretManagerMetadataSpecDTO;
}

export interface SecretManagerMetadataSpecDTO {
  [key: string]: any;
}

export type VaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  secretEngines?: VaultSecretEngineDTO[];
};

export interface VaultSecretEngineDTO {
  name?: string;
  description?: string;
  type?: string;
  version?: number;
}

export type AzureKeyVaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  clientId: string;
  tenantId: string;
  secretKey: string;
  subscription: string;
  azureEnvironmentType?: "AZURE" | "AZURE_US_GOVERNMENT";
  delegateSelectors?: string[];
};

export interface SecretManagerMetadataRequestDTO {
  encryptionType:
    | "LOCAL"
    | "KMS"
    | "GCP_KMS"
    | "AWS_SECRETS_MANAGER"
    | "AZURE_VAULT"
    | "CYBERARK"
    | "VAULT"
    | "GCP_SECRETS_MANAGER"
    | "CUSTOM"
    | "VAULT_SSH";
  orgIdentifier?: string;
  projectIdentifier?: string;
  identifier: string;
  spec: SecretManagerMetadataRequestSpecDTO;
}

export interface SecretManagerMetadataRequestSpecDTO {
  [key: string]: any;
}

export type VaultAppRoleCredentialDTO = VaultCredentialDTO & {
  appRoleId?: string;
  secretId?: string;
};

export type VaultAuthTokenCredentialDTO = VaultCredentialDTO & {
  authToken?: string;
};

export interface VaultCredentialDTO {
  [key: string]: any;
}

export type VaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  url: string;
  accessType: "APP_ROLE" | "TOKEN";
  spec?: VaultCredentialDTO;
  delegateSelectors?: string[];
};

export interface BaseSSHSpecDTO {
  [key: string]: any;
}

export type KerberosConfigDTO = BaseSSHSpecDTO & {
  principal: string;
  realm: string;
  tgtGenerationMethod?: "KeyTabFilePath" | "Password";
  spec?: TGTGenerationSpecDTO;
};

export interface ResponseSecretResponseWrapper {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SecretResponseWrapper;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SSHAuthDTO {
  spec: BaseSSHSpecDTO;
  type: "SSH" | "Kerberos";
}

export type SSHConfigDTO = BaseSSHSpecDTO & {
  credentialType: "Password" | "KeyPath" | "KeyReference";
  spec: SSHCredentialSpecDTO;
};

export interface SSHCredentialSpecDTO {
  [key: string]: any;
}

export type SSHKeyPathCredentialDTO = SSHCredentialSpecDTO & {
  userName: string;
  keyPath: string;
  encryptedPassphrase?: string;
};

export type SSHKeyReferenceCredentialDTO = SSHCredentialSpecDTO & {
  userName: string;
  key?: string;
  encryptedPassphrase?: string;
};

export type SSHKeySpecDTO = SecretSpecDTO & {
  port?: number;
  auth: SSHAuthDTO;
};

export type SSHPasswordCredentialDTO = SSHCredentialSpecDTO & {
  userName: string;
  password: string;
};

export interface SecretDTOV2 {
  type: "SecretFile" | "SecretText" | "SSHKey";
  name: string;
  identifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  tags?: {
    [key: string]: string;
  };
  description?: string;
  spec: SecretSpecDTO;
}

export type SecretFileSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string;
};

export interface SecretResponseWrapper {
  secret: SecretDTOV2;
  createdAt?: number;
  updatedAt?: number;
  draft?: boolean;
}

export interface SecretSpecDTO {
  errorMessageForInvalidYaml?: string;
}

export type SecretTextSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string;
  valueType: "Inline" | "Reference";
  value?: string;
};

export interface TGTGenerationSpecDTO {
  [key: string]: any;
}

export type TGTKeyTabFilePathSpecDTO = TGTGenerationSpecDTO & {
  keyPath?: string;
};

export type TGTPasswordSpecDTO = TGTGenerationSpecDTO & {
  password?: string;
};

export interface SecretRequestWrapper {
  secret: SecretDTOV2;
}

export interface PageSecretResponseWrapper {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: SecretResponseWrapper[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageSecretResponseWrapper {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageSecretResponseWrapper;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SecretResourceFilterDTO {
  identifiers?: string[];
  searchTerm?: string;
  secretTypes?: ("SecretFile" | "SecretText" | "SSHKey")[];
  sourceCategory?:
    | "CLOUD_PROVIDER"
    | "SECRET_MANAGER"
    | "CLOUD_COST"
    | "ARTIFACTORY"
    | "CODE_REPO"
    | "MONITORING"
    | "TICKETING";
  includeSecretsFromEverySubScope?: boolean;
}

export interface ResponseSecretValidationResultDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SecretValidationResultDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SecretValidationResultDTO {
  success?: boolean;
  message?: string;
}

export type SSHKeyValidationMetadata = SecretValidationMetaData & {
  host: string;
};

export interface SecretValidationMetaData {
  type: "SecretFile" | "SecretText" | "SSHKey";
}

export interface ResponseOrganizationResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: OrganizationResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface OrganizationRequest {
  organization: Organization;
}

export interface PageOrganizationResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: OrganizationResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageOrganizationResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageOrganizationResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseProjectResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ProjectResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ProjectRequest {
  project: Project;
}

export interface PageProjectResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ProjectResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageProjectResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageProjectResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface TokenDTO {
  identifier: string;
  name: string;
  validFrom?: number;
  validTo?: number;
  scheduledExpireTime?: number;
  valid?: boolean;
  accountIdentifier: string;
  projectIdentifier?: string;
  orgIdentifier?: string;
  apiKeyIdentifier: string;
  parentIdentifier: string;
  apiKeyType: "USER" | "SERVICE_ACCOUNT";
  description?: string;
  tags?: {
    [key: string]: string;
  };
  email?: string;
  username?: string;
  encodedPassword?: string;
}

export interface ResponseTokenDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: TokenDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageTokenAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: TokenAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageTokenAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageTokenAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface TokenAggregateDTO {
  token: TokenDTO;
  expiryAt: number;
  createdAt: number;
  lastModifiedAt: number;
}

export interface ResponseUserGroupDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserGroupDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface AccessControlCheckError {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  code?:
    | "DEFAULT_ERROR_CODE"
    | "INVALID_ARGUMENT"
    | "INVALID_EMAIL"
    | "DOMAIN_NOT_ALLOWED_TO_REGISTER"
    | "USER_ALREADY_REGISTERED"
    | "USER_INVITATION_DOES_NOT_EXIST"
    | "USER_DOES_NOT_EXIST"
    | "USER_INVITE_OPERATION_FAILED"
    | "USER_DISABLED"
    | "ACCOUNT_DOES_NOT_EXIST"
    | "INACTIVE_ACCOUNT"
    | "ACCOUNT_MIGRATED"
    | "USER_DOMAIN_NOT_ALLOWED"
    | "MAX_FAILED_ATTEMPT_COUNT_EXCEEDED"
    | "RESOURCE_NOT_FOUND"
    | "ROLE_DOES_NOT_EXIST"
    | "EMAIL_NOT_VERIFIED"
    | "EMAIL_VERIFICATION_TOKEN_NOT_FOUND"
    | "INVALID_TOKEN"
    | "REVOKED_TOKEN"
    | "INVALID_CAPTCHA_TOKEN"
    | "NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS"
    | "EXPIRED_TOKEN"
    | "TOKEN_ALREADY_REFRESHED_ONCE"
    | "ACCESS_DENIED"
    | "NG_ACCESS_DENIED"
    | "INVALID_CREDENTIAL"
    | "INVALID_CREDENTIALS_THIRD_PARTY"
    | "INVALID_KEY"
    | "INVALID_CONNECTOR_TYPE"
    | "INVALID_KEYPATH"
    | "INVALID_VARIABLE"
    | "UNKNOWN_HOST"
    | "UNREACHABLE_HOST"
    | "INVALID_PORT"
    | "SSH_SESSION_TIMEOUT"
    | "SOCKET_CONNECTION_ERROR"
    | "CONNECTION_ERROR"
    | "SOCKET_CONNECTION_TIMEOUT"
    | "CONNECTION_TIMEOUT"
    | "SSH_CONNECTION_ERROR"
    | "USER_GROUP_ERROR"
    | "INVALID_EXECUTION_ID"
    | "ERROR_IN_GETTING_CHANNEL_STREAMS"
    | "UNEXPECTED"
    | "UNKNOWN_ERROR"
    | "UNKNOWN_EXECUTOR_TYPE_ERROR"
    | "DUPLICATE_STATE_NAMES"
    | "TRANSITION_NOT_LINKED"
    | "TRANSITION_TO_INCORRECT_STATE"
    | "TRANSITION_TYPE_NULL"
    | "STATES_WITH_DUP_TRANSITIONS"
    | "BARRIERS_NOT_RUNNING_CONCURRENTLY"
    | "NON_FORK_STATES"
    | "NON_REPEAT_STATES"
    | "INITIAL_STATE_NOT_DEFINED"
    | "FILE_INTEGRITY_CHECK_FAILED"
    | "INVALID_URL"
    | "FILE_DOWNLOAD_FAILED"
    | "PLATFORM_SOFTWARE_DELETE_ERROR"
    | "INVALID_CSV_FILE"
    | "INVALID_REQUEST"
    | "SCHEMA_VALIDATION_FAILED"
    | "FILTER_CREATION_ERROR"
    | "INVALID_YAML_ERROR"
    | "PLAN_CREATION_ERROR"
    | "INVALID_INFRA_STATE"
    | "PIPELINE_ALREADY_TRIGGERED"
    | "NON_EXISTING_PIPELINE"
    | "DUPLICATE_COMMAND_NAMES"
    | "INVALID_PIPELINE"
    | "COMMAND_DOES_NOT_EXIST"
    | "DUPLICATE_ARTIFACTSTREAM_NAMES"
    | "DUPLICATE_HOST_NAMES"
    | "STATE_NOT_FOR_TYPE"
    | "STATE_MACHINE_ISSUE"
    | "STATE_DISCONTINUE_FAILED"
    | "STATE_PAUSE_FAILED"
    | "PAUSE_ALL_ALREADY"
    | "RESUME_ALL_ALREADY"
    | "ROLLBACK_ALREADY"
    | "ABORT_ALL_ALREADY"
    | "EXPIRE_ALL_ALREADY"
    | "RETRY_FAILED"
    | "UNKNOWN_ARTIFACT_TYPE"
    | "UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE"
    | "INIT_TIMEOUT"
    | "LICENSE_EXPIRED"
    | "NOT_LICENSED"
    | "REQUEST_TIMEOUT"
    | "WORKFLOW_ALREADY_TRIGGERED"
    | "JENKINS_ERROR"
    | "INVALID_ARTIFACT_SOURCE"
    | "INVALID_ARTIFACT_SERVER"
    | "INVALID_CLOUD_PROVIDER"
    | "UPDATE_NOT_ALLOWED"
    | "DELETE_NOT_ALLOWED"
    | "APPDYNAMICS_CONFIGURATION_ERROR"
    | "APM_CONFIGURATION_ERROR"
    | "SPLUNK_CONFIGURATION_ERROR"
    | "ELK_CONFIGURATION_ERROR"
    | "LOGZ_CONFIGURATION_ERROR"
    | "SUMO_CONFIGURATION_ERROR"
    | "INSTANA_CONFIGURATION_ERROR"
    | "APPDYNAMICS_ERROR"
    | "STACKDRIVER_ERROR"
    | "STACKDRIVER_CONFIGURATION_ERROR"
    | "NEWRELIC_CONFIGURATION_ERROR"
    | "NEWRELIC_ERROR"
    | "DYNA_TRACE_CONFIGURATION_ERROR"
    | "DYNA_TRACE_ERROR"
    | "CLOUDWATCH_ERROR"
    | "CLOUDWATCH_CONFIGURATION_ERROR"
    | "PROMETHEUS_CONFIGURATION_ERROR"
    | "DATA_DOG_CONFIGURATION_ERROR"
    | "SERVICE_GUARD_CONFIGURATION_ERROR"
    | "ENCRYPTION_NOT_CONFIGURED"
    | "UNAVAILABLE_DELEGATES"
    | "WORKFLOW_EXECUTION_IN_PROGRESS"
    | "PIPELINE_EXECUTION_IN_PROGRESS"
    | "AWS_ACCESS_DENIED"
    | "AWS_CLUSTER_NOT_FOUND"
    | "AWS_SERVICE_NOT_FOUND"
    | "IMAGE_NOT_FOUND"
    | "ILLEGAL_ARGUMENT"
    | "IMAGE_TAG_NOT_FOUND"
    | "DELEGATE_NOT_AVAILABLE"
    | "INVALID_YAML_PAYLOAD"
    | "AUTHENTICATION_ERROR"
    | "AUTHORIZATION_ERROR"
    | "UNRECOGNIZED_YAML_FIELDS"
    | "COULD_NOT_MAP_BEFORE_YAML"
    | "MISSING_BEFORE_YAML"
    | "MISSING_YAML"
    | "NON_EMPTY_DELETIONS"
    | "GENERAL_YAML_ERROR"
    | "GENERAL_YAML_INFO"
    | "YAML_GIT_SYNC_ERROR"
    | "GIT_CONNECTION_ERROR"
    | "GIT_ERROR"
    | "ARTIFACT_SERVER_ERROR"
    | "ENCRYPT_DECRYPT_ERROR"
    | "SECRET_MANAGEMENT_ERROR"
    | "SECRET_NOT_FOUND"
    | "KMS_OPERATION_ERROR"
    | "GCP_KMS_OPERATION_ERROR"
    | "VAULT_OPERATION_ERROR"
    | "AWS_SECRETS_MANAGER_OPERATION_ERROR"
    | "AZURE_KEY_VAULT_OPERATION_ERROR"
    | "CYBERARK_OPERATION_ERROR"
    | "UNSUPPORTED_OPERATION_EXCEPTION"
    | "FEATURE_UNAVAILABLE"
    | "GENERAL_ERROR"
    | "BASELINE_CONFIGURATION_ERROR"
    | "SAML_IDP_CONFIGURATION_NOT_AVAILABLE"
    | "INVALID_AUTHENTICATION_MECHANISM"
    | "INVALID_SAML_CONFIGURATION"
    | "INVALID_OAUTH_CONFIGURATION"
    | "INVALID_LDAP_CONFIGURATION"
    | "USER_GROUP_SYNC_FAILURE"
    | "USER_GROUP_ALREADY_EXIST"
    | "INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION"
    | "EXPLANATION"
    | "HINT"
    | "NOT_WHITELISTED_IP"
    | "INVALID_TOTP_TOKEN"
    | "EMAIL_FAILED"
    | "SSL_HANDSHAKE_FAILED"
    | "NO_APPS_ASSIGNED"
    | "INVALID_INFRA_CONFIGURATION"
    | "TEMPLATES_LINKED"
    | "USER_HAS_NO_PERMISSIONS"
    | "USER_NOT_AUTHORIZED"
    | "USER_ALREADY_PRESENT"
    | "INVALID_USAGE_RESTRICTION"
    | "USAGE_RESTRICTION_ERROR"
    | "STATE_EXECUTION_INSTANCE_NOT_FOUND"
    | "DELEGATE_TASK_RETRY"
    | "KUBERNETES_YAML_ERROR"
    | "SAVE_FILE_INTO_GCP_STORAGE_FAILED"
    | "READ_FILE_FROM_GCP_STORAGE_FAILED"
    | "FILE_NOT_FOUND_ERROR"
    | "USAGE_LIMITS_EXCEEDED"
    | "EVENT_PUBLISH_FAILED"
    | "JIRA_ERROR"
    | "EXPRESSION_EVALUATION_FAILED"
    | "KUBERNETES_VALUES_ERROR"
    | "KUBERNETES_CLUSTER_ERROR"
    | "INCORRECT_SIGN_IN_MECHANISM"
    | "OAUTH_LOGIN_FAILED"
    | "INVALID_TERRAFORM_TARGETS_REQUEST"
    | "TERRAFORM_EXECUTION_ERROR"
    | "FILE_READ_FAILED"
    | "FILE_SIZE_EXCEEDS_LIMIT"
    | "CLUSTER_NOT_FOUND"
    | "MARKETPLACE_TOKEN_NOT_FOUND"
    | "INVALID_MARKETPLACE_TOKEN"
    | "INVALID_TICKETING_SERVER"
    | "SERVICENOW_ERROR"
    | "PASSWORD_EXPIRED"
    | "USER_LOCKED"
    | "PASSWORD_STRENGTH_CHECK_FAILED"
    | "ACCOUNT_DISABLED"
    | "INVALID_ACCOUNT_PERMISSION"
    | "PAGERDUTY_ERROR"
    | "HEALTH_ERROR"
    | "SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED"
    | "DOMAIN_WHITELIST_FILTER_CHECK_FAILED"
    | "INVALID_DASHBOARD_UPDATE_REQUEST"
    | "DUPLICATE_FIELD"
    | "INVALID_AZURE_VAULT_CONFIGURATION"
    | "USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS"
    | "INVALID_ROLLBACK"
    | "DATA_COLLECTION_ERROR"
    | "SUMO_DATA_COLLECTION_ERROR"
    | "DEPLOYMENT_GOVERNANCE_ERROR"
    | "BATCH_PROCESSING_ERROR"
    | "GRAPHQL_ERROR"
    | "FILE_CREATE_ERROR"
    | "ILLEGAL_STATE"
    | "GIT_DIFF_COMMIT_NOT_IN_ORDER"
    | "FAILED_TO_ACQUIRE_PERSISTENT_LOCK"
    | "FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK"
    | "POD_NOT_FOUND_ERROR"
    | "COMMAND_EXECUTION_ERROR"
    | "REGISTRY_EXCEPTION"
    | "ENGINE_INTERRUPT_PROCESSING_EXCEPTION"
    | "ENGINE_IO_EXCEPTION"
    | "ENGINE_OUTCOME_EXCEPTION"
    | "ENGINE_SWEEPING_OUTPUT_EXCEPTION"
    | "CACHE_NOT_FOUND_EXCEPTION"
    | "ENGINE_ENTITY_UPDATE_EXCEPTION"
    | "SHELL_EXECUTION_EXCEPTION"
    | "TEMPLATE_NOT_FOUND"
    | "AZURE_SERVICE_EXCEPTION"
    | "AZURE_CLIENT_EXCEPTION"
    | "GIT_UNSEEN_REMOTE_HEAD_COMMIT"
    | "TIMEOUT_ENGINE_EXCEPTION"
    | "NO_AVAILABLE_DELEGATES"
    | "NO_INSTALLED_DELEGATES"
    | "DUPLICATE_DELEGATE_EXCEPTION"
    | "GCP_MARKETPLACE_EXCEPTION"
    | "MISSING_DEFAULT_GOOGLE_CREDENTIALS"
    | "INCORRECT_DEFAULT_GOOGLE_CREDENTIALS"
    | "OPTIMISTIC_LOCKING_EXCEPTION"
    | "NG_PIPELINE_EXECUTION_EXCEPTION"
    | "NG_PIPELINE_CREATE_EXCEPTION"
    | "RESOURCE_NOT_FOUND_EXCEPTION"
    | "PMS_INITIALIZE_SDK_EXCEPTION"
    | "UNEXPECTED_SNIPPET_EXCEPTION"
    | "UNEXPECTED_SCHEMA_EXCEPTION"
    | "CONNECTOR_VALIDATION_EXCEPTION"
    | "TIMESCALE_NOT_AVAILABLE"
    | "MIGRATION_EXCEPTION"
    | "REQUEST_PROCESSING_INTERRUPTED"
    | "GCP_SECRET_MANAGER_OPERATION_ERROR"
    | "GCP_SECRET_OPERATION_ERROR"
    | "GIT_OPERATION_ERROR"
    | "TASK_FAILURE_ERROR"
    | "INSTANCE_STATS_PROCESS_ERROR"
    | "INSTANCE_STATS_MIGRATION_ERROR"
    | "DEPLOYMENT_MIGRATION_ERROR"
    | "INSTANCE_STATS_AGGREGATION_ERROR"
    | "UNRESOLVED_EXPRESSIONS_ERROR"
    | "KRYO_HANDLER_NOT_FOUND_ERROR"
    | "DELEGATE_ERROR_HANDLER_EXCEPTION"
    | "UNEXPECTED_TYPE_ERROR"
    | "EXCEPTION_HANDLER_NOT_FOUND"
    | "CONNECTOR_NOT_FOUND_EXCEPTION"
    | "GCP_SERVER_ERROR"
    | "HTTP_RESPONSE_EXCEPTION"
    | "SCM_NOT_FOUND_ERROR"
    | "SCM_CONFLICT_ERROR"
    | "SCM_UNPROCESSABLE_ENTITY"
    | "PROCESS_EXECUTION_EXCEPTION"
    | "SCM_UNAUTHORIZED"
    | "DATA"
    | "CONTEXT"
    | "PR_CREATION_ERROR"
    | "URL_NOT_REACHABLE"
    | "URL_NOT_PROVIDED"
    | "ENGINE_EXPRESSION_EVALUATION_ERROR"
    | "ENGINE_FUNCTOR_ERROR"
    | "JIRA_CLIENT_ERROR"
    | "SCM_NOT_MODIFIED"
    | "JIRA_STEP_ERROR"
    | "BUCKET_SERVER_ERROR";
  message?: string;
  correlationId?: string;
  detailedMessage?: string;
  responseMessages?: ResponseMessage[];
  failedPermissionChecks?: PermissionCheck[];
}

export interface PermissionCheck {
  resourceScope?: ResourceScope;
  resourceType?: string;
  resourceIdentifier?: string;
  permission?: string;
}

export interface ResourceScope {
  accountIdentifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
}

export interface ResponseListUserGroupDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserGroupDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserGroupFilterDTO {
  databaseIdFilter?: string[];
  identifierFilter?: string[];
  userIdentifierFilter?: string[];
  accountIdentifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
}

export interface PageUserGroupDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserGroupDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageUserGroupDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserGroupDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type EmailConfig = NotificationSettingConfig & {
  groupEmail?: string;
};

export type MicrosoftTeamsConfig = NotificationSettingConfig & {
  microsoftTeamsWebhookUrl?: string;
};

export interface NotificationSettingConfig {
  type: "EMAIL" | "SLACK" | "PAGERDUTY" | "MSTEAMS";
}

export type PagerDutyConfig = NotificationSettingConfig & {
  pagerDutyKey?: string;
};

export interface RestResponseUserGroup {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: UserGroup;
  responseMessages?: ResponseMessage[];
}

export type SlackConfig = NotificationSettingConfig & {
  slackWebhookUrl?: string;
};

export interface PageUserMetadataDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserMetadataDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageUserMetadataDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserMetadataDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserFilter {
  searchTerm?: string;
  identifiers?: string[];
  parentFilter?:
    | "NO_PARENT_SCOPES"
    | "INCLUDE_PARENT_SCOPES"
    | "STRICTLY_PARENT_SCOPES";
}

export interface SamlLinkGroupRequest {
  samlGroupName?: string;
}

export interface ResponseServiceResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceResponseDTO {
  accountId?: string;
  identifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  name?: string;
  description?: string;
  deleted?: boolean;
  tags?: {
    [key: string]: string;
  };
  version?: number;
}

export interface ServiceRequestDTO {
  identifier: string;
  orgIdentifier: string;
  projectIdentifier: string;
  name?: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  version?: number;
}

export interface PageServiceResponseDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ServiceResponseDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageServiceResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageServiceResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseServiceResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceResponse {
  service?: ServiceResponseDTO;
  createdAt?: number;
  lastModifiedAt?: number;
}

export interface PageServiceResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ServiceResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageServiceResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageServiceResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListServiceResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceResponse[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageUserAggregate {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserAggregate[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageUserAggregate {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserAggregate;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserAggregate {
  user: UserMetadataDTO;
  roleAssignmentMetadata: RoleAssignmentMetadataDTO[];
}

export interface ResponseUserAggregate {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserAggregate;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GatewayAccountRequestDTO {
  uuid?: string;
  accountName?: string;
  companyName?: string;
  defaultExperience?: "NG" | "CG";
  createdFromNG?: boolean;
  nextGenEnabled?: boolean;
}

export interface ResponseUserInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserInfo {
  uuid?: string;
  name?: string;
  email?: string;
  token?: string;
  defaultAccountId?: string;
  intent?: string;
  accounts?: GatewayAccountRequestDTO[];
  admin?: boolean;
  twoFactorAuthenticationEnabled?: boolean;
  emailVerified?: boolean;
  locked?: boolean;
  signupAction?: "REGULAR" | "TRIAL" | "SUBSCRIBE";
  edition?: "FREE" | "TEAM" | "ENTERPRISE";
  billingFrequency?: "MONTHLY" | "YEARLY";
}

export interface ResponseTwoFactorAuthSettingsInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: TwoFactorAuthSettingsInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface TwoFactorAuthSettingsInfo {
  userId?: string;
  email?: string;
  twoFactorAuthenticationEnabled?: boolean;
  mechanism?: "TOTP";
  totpSecretKey?: string;
  totpqrurl?: string;
}

export interface ResponsePasswordChangeResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?:
    | "PASSWORD_CHANGED"
    | "INCORRECT_CURRENT_PASSWORD"
    | "PASSWORD_STRENGTH_VIOLATED";
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PasswordChangeDTO {
  currentPassword?: string;
  newPassword?: string;
}

export interface PageProject {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: Project[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageProject {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageProject;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListExecutionStatus {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: (
    | "Running"
    | "AsyncWaiting"
    | "TaskWaiting"
    | "TimedWaiting"
    | "Failed"
    | "Errored"
    | "IgnoreFailed"
    | "NotStarted"
    | "Expired"
    | "Aborted"
    | "Discontinuing"
    | "Queued"
    | "Paused"
    | "ResourceWaiting"
    | "InterventionWaiting"
    | "ApprovalWaiting"
    | "Success"
    | "Suspended"
    | "Skipped"
    | "Pausing"
    | "ApprovalRejected"
    | "NOT_STARTED"
    | "INTERVENTION_WAITING"
    | "APPROVAL_WAITING"
    | "APPROVAL_REJECTED"
    | "WAITING"
  )[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ArtifactSummary {
  type?: string;
  displayName?: string;
}

export interface ArtifactsSummary {
  primary?: ArtifactSummary;
  sidecars?: ArtifactSummary[];
}

export interface CDStageModuleInfo {
  serviceInfo?: ServiceExecutionSummary;
  infraExecutionSummary?: InfraExecutionSummary;
  nodeExecutionId?: string;
}

export interface InfraExecutionSummary {
  identifier?: string;
  name?: string;
  type?: string;
}

export interface ResponseCDStageModuleInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: CDStageModuleInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceExecutionSummary {
  identifier?: string;
  displayName?: string;
  deploymentType?: string;
  artifacts?: ArtifactsSummary;
}

export type AbortFailureActionConfig = FailureStrategyActionConfig & {
  type: "Abort";
};

export type AddSegmentToVariationTargetMapYaml = PatchInstruction & {
  type: "AddSegmentToVariationTargetMap";
  identifier: string;
  spec: AddSegmentToVariationTargetMapYamlSpec;
};

export interface AddSegmentToVariationTargetMapYamlSpec {
  variation: string;
  segments: string[];
}

export type AddTargetsToVariationTargetMapYaml = PatchInstruction & {
  type: "AddTargetsToVariationTargetMap";
  identifier: string;
  spec: AddTargetsToVariationTargetMapYamlSpec;
};

export interface AddTargetsToVariationTargetMapYamlSpec {
  variation: string;
  targets: string[];
}

export type ApprovalStageConfig = StageInfoConfig & {
  execution: ExecutionElementConfig;
};

export interface ApproverInputInfo {
  name?: string;
  defaultValue?: string;
}

export interface Approvers {
  userGroups: string[];
  minimumCount: number;
  disallowPipelineExecutor: boolean;
}

export interface ArtifactConfig {
  [key: string]: any;
}

export interface ArtifactListConfig {
  primary?: PrimaryArtifact;
  sidecars?: SidecarArtifactWrapper[];
  metadata?: string;
}

export interface ArtifactOverrideSetWrapper {
  overrideSet?: ArtifactOverrideSets;
}

export interface ArtifactOverrideSets {
  identifier?: string;
  artifacts?: ArtifactListConfig;
}

export interface BarrierInfoConfig {
  identifier: string;
  name: string;
}

export type BarrierStepInfo = StepSpecType & {
  barrierRef: string;
};

export type BitbucketStore = StoreConfig & {
  connectorRef: string;
  gitFetchType: "Branch" | "Commit";
  branch?: string;
  commitId?: string;
  paths?: string[];
  folderPath?: string;
  repoName?: string;
  metadata?: string;
};

export type BranchBuildSpec = BuildSpec & {
  branch: string;
};

export interface Build {
  type: "branch" | "tag" | "PR";
  spec: BuildSpec;
}

export interface BuildSpec {
  [key: string]: any;
}

export interface CIProperties {
  codebase?: CodeBase;
}

export interface CodeBase {
  connectorRef: string;
  repoName?: string;
  build: Build;
  depth?: number;
  sslVerify?: boolean;
  prCloneStrategy?: "MergeCommit" | "SourceBranch";
  resources?: ContainerResource;
}

export interface Condition {
  key: string;
  value: string;
  operator: "equals" | "not equals" | "in" | "not in";
}

export interface ContainerResource {
  limits: Limits;
}

export type CountInstanceSelection = InstanceSelectionBase & {
  count?: ParameterFieldString;
};

export interface CriteriaSpec {
  [key: string]: any;
}

export interface CriteriaSpecWrapper {
  type: "Jexl" | "KeyValues";
  spec: CriteriaSpec;
}

export type DeleteManifestPathSpec = DeleteResourcesBaseSpec & {
  manifestPaths?: string[];
  allManifestPaths?: boolean;
};

export type DeleteReleaseNameSpec = DeleteResourcesBaseSpec & {
  deleteNamespace?: boolean;
};

export type DeleteResourceNameSpec = DeleteResourcesBaseSpec & {
  resourceNames?: string[];
};

export interface DeleteResourcesBaseSpec {
  [key: string]: any;
}

export interface DeleteResourcesWrapper {
  type?: "ResourceName" | "ReleaseName" | "ManifestPath";
  spec?: DeleteResourcesBaseSpec;
}

export type DeploymentStageConfig = StageInfoConfig & {
  serviceConfig: ServiceConfig;
  infrastructure: PipelineInfrastructure;
  execution: ExecutionElementConfig;
};

export type DockerHubArtifactConfig = ArtifactConfig & {
  connectorRef: string;
  imagePath: string;
  tag?: string;
  tagRegex?: string;
  metadata?: string;
};

export type EcrArtifactConfig = ArtifactConfig & {
  connectorRef: string;
  region: string;
  imagePath: string;
  tag?: string;
  tagRegex?: string;
  metadata?: string;
};

export interface EnvironmentYaml {
  name: string;
  identifier: string;
  description?: string;
  type: "PreProduction" | "Production";
  tags?: {
    [key: string]: string;
  };
}

export interface ExecutionElementConfig {
  steps: ExecutionWrapperConfig[];
  rollbackSteps?: ExecutionWrapperConfig[];
}

export interface ExecutionTarget {
  host?: string;
  connectorRef?: string;
  workingDirectory?: string;
}

export interface ExecutionWrapperConfig {
  step?: StepElementConfig;
  parallel?: ParallelStepElementConfig;
  stepGroup?: StepGroupElementConfig;
}

export interface FailureStrategyActionConfig {
  type:
    | "Ignore"
    | "Retry"
    | "MarkAsSuccess"
    | "Abort"
    | "StageRollback"
    | "StepGroupRollback"
    | "ManualIntervention";
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig;
}

export type FeatureFlagStageConfig = StageInfoConfig & {};

export type FlagConfigurationStepInfo = StepSpecType & {
  feature: string;
  environment: string;
  instructions: PatchInstruction[];
};

export interface FlowControlConfig {
  barriers?: BarrierInfoConfig[];
}

export type GcrArtifactConfig = ArtifactConfig & {
  connectorRef: string;
  registryHostname: string;
  imagePath: string;
  tag?: string;
  tagRegex?: string;
  metadata?: string;
};

export type GcsStoreConfig = StoreConfig & {
  connectorRef?: string;
  bucketName?: string;
  folderPath?: string;
  metadata?: string;
};

export type GitLabStore = StoreConfig & {
  connectorRef: string;
  gitFetchType: "Branch" | "Commit";
  branch?: string;
  commitId?: string;
  paths?: string[];
  folderPath?: string;
  repoName?: string;
  metadata?: string;
};

export type GitStore = StoreConfig & {
  connectorRef: string;
  gitFetchType: "Branch" | "Commit";
  branch?: string;
  commitId?: string;
  paths?: string[];
  folderPath?: string;
  repoName?: string;
  metadata?: string;
};

export type GithubStore = StoreConfig & {
  connectorRef: string;
  gitFetchType: "Branch" | "Commit";
  branch?: string;
  commitId?: string;
  paths?: string[];
  folderPath?: string;
  repoName?: string;
  metadata?: string;
};

export type HarnessApprovalStepInfo = StepSpecType & {
  approvalMessage: string;
  includePipelineExecutionHistory: boolean;
  approvers: Approvers;
  approverInputs?: ApproverInputInfo[];
};

export type HelmChartManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  chartName?: string;
  chartVersion?: string;
  helmVersion?: "V2" | "V3";
  skipResourceVersioning?: boolean;
  commandFlags?: HelmManifestCommandFlag[];
  metadata?: string;
};

export interface HelmManifestCommandFlag {
  commandType: "Fetch" | "Version" | "Template" | "Pull";
  flag?: string;
}

export interface HoldingScope {
  scope: string;
  nodeSetupId: string;
}

export interface HttpHeaderConfig {
  key?: string;
  value?: string;
}

export type HttpStepInfo = StepSpecType & {
  url: string;
  method: string;
  requestBody?: string;
  assertion?: string;
  outputVariables?: NGVariable[];
  headers?: HttpHeaderConfig[];
  delegateSelectors?: string[];
};

export type HttpStoreConfig = StoreConfig & {
  connectorRef?: string;
  metadata?: string;
};

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & {
  type: "Ignore";
};

export interface InfraOverrides {
  environment?: EnvironmentYaml;
  infrastructureDefinition?: InfrastructureDef;
}

export interface InfraUseFromStage {
  stage: string;
  overrides?: InfraOverrides;
}

export interface Infrastructure {
  [key: string]: any;
}

export interface InfrastructureDef {
  type: "KubernetesDirect" | "KubernetesGcp";
  spec: Infrastructure;
  provisioner?: ExecutionElementConfig;
}

export type InlineTerraformBackendConfigSpec = TerraformBackendConfigSpec & {
  content?: string;
};

export type InlineTerraformVarFileSpec = TerraformVarFileSpec & {
  content?: string;
};

export interface InputSetValidator {
  validatorType?: "ALLOWED_VALUES" | "REGEX";
  parameters?: string;
}

export interface InstanceSelectionBase {
  [key: string]: any;
}

export interface InstanceSelectionWrapper {
  type?: "Count" | "Percentage";
  spec?: InstanceSelectionBase;
}

export type JexlCriteriaSpec = CriteriaSpec & {
  expression: string;
};

export type JiraApprovalStepInfo = StepSpecType & {
  connectorRef: string;
  issueKey: string;
  approvalCriteria: CriteriaSpecWrapper;
  rejectionCriteria?: CriteriaSpecWrapper;
  delegateSelectors?: string[];
};

export type JiraCreateStepInfo = StepSpecType & {
  connectorRef: string;
  projectKey: string;
  issueType: string;
  fields?: JiraField[];
  delegateSelectors?: string[];
};

export interface JiraField {
  name?: string;
  value: string;
}

export type JiraUpdateStepInfo = StepSpecType & {
  connectorRef: string;
  issueKey: string;
  transitionTo?: TransitionTo;
  fields?: JiraField[];
  delegateSelectors?: string[];
};

export type K8SDirectInfrastructure = Infrastructure & {
  connectorRef: string;
  namespace: string;
  releaseName: string;
};

export type K8sApplyStepInfo = StepSpecType & {
  skipDryRun?: boolean;
  skipSteadyStateCheck?: boolean;
  filePaths?: string[];
  delegateSelectors?: string[];
};

export type K8sBGSwapServicesStepInfo = StepSpecType & {
  skipDryRun?: boolean;
  delegateSelectors?: string[];
};

export type K8sBlueGreenStepInfo = StepSpecType & {
  skipDryRun?: boolean;
  delegateSelectors?: string[];
};

export type K8sCanaryDeleteStepInfo = StepSpecType & {
  skipDryRun?: boolean;
  delegateSelectors?: string[];
};

export type K8sCanaryStepInfo = StepSpecType & {
  instanceSelection: InstanceSelectionWrapper;
  skipDryRun?: boolean;
  delegateSelectors?: string[];
};

export type K8sDeleteStepInfo = StepSpecType & {
  deleteResources: DeleteResourcesWrapper;
  skipDryRun?: boolean;
  delegateSelectors?: string[];
};

export type K8sGcpInfrastructure = Infrastructure & {
  connectorRef: string;
  namespace: string;
  releaseName: string;
  cluster: string;
  metadata?: string;
};

export type K8sManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  skipResourceVersioning?: ParameterFieldBoolean;
  metadata?: string;
};

export type K8sRollingRollbackStepInfo = StepSpecType & {
  skipDryRun?: boolean;
  delegateSelectors?: string[];
};

export type K8sRollingStepInfo = StepSpecType & {
  skipDryRun?: boolean;
  delegateSelectors?: string[];
};

export type K8sScaleStepInfo = StepSpecType & {
  instanceSelection: InstanceSelectionWrapper;
  workload?: string;
  skipDryRun?: boolean;
  skipSteadyStateCheck?: boolean;
  delegateSelectors?: string[];
};

export type KeyValuesCriteriaSpec = CriteriaSpec & {
  matchAnyCondition?: boolean;
  conditions: Condition[];
};

export type KubernetesServiceSpec = ServiceSpec & {
  metadata?: string;
};

export type KustomizeManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  skipResourceVersioning?: ParameterFieldBoolean;
  pluginPath?: string;
  metadata?: string;
};

export interface Limits {
  memory?: string;
  cpu?: string;
}

export interface ManifestAttributes {
  [key: string]: any;
}

export interface ManifestConfig {
  identifier: string;
  type:
    | "HelmChart"
    | "K8sManifest"
    | "Kustomize"
    | "OpenshiftParam"
    | "OpenshiftTemplate"
    | "Values";
  spec: ManifestAttributes;
}

export interface ManifestConfigWrapper {
  manifest?: ManifestConfig;
}

export interface ManifestOverrideSetWrapper {
  overrideSet?: ManifestOverrideSets;
}

export interface ManifestOverrideSets {
  identifier?: string;
  manifests?: ManifestConfigWrapper[];
}

export interface ManualFailureSpecConfig {
  timeout: string;
  onTimeout: OnTimeoutConfig;
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec: ManualFailureSpecConfig;
  type: "ManualIntervention";
};

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & {
  type: "MarkAsSuccess";
};

export interface NGProperties {
  ci?: CIProperties;
}

export interface NGVariable {
  description?: string;
  name?: string;
  type?: "String" | "Number" | "Secret";
  required?: boolean;
  metadata?: string;
}

export interface NGVariableOverrideSetWrapper {
  overrideSet?: NGVariableOverrideSets;
}

export interface NGVariableOverrideSets {
  identifier?: string;
  variables?: NGVariable[];
}

export type NativeHelmServiceSpec = ServiceSpec & {
  metadata?: string;
};

export interface NotificationChannelWrapper {
  type?: string;
  spec?: PmsNotificationChannel;
}

export interface NotificationRules {
  name?: string;
  enabled?: boolean;
  pipelineEvents?: PipelineEvent[];
  notificationMethod?: NotificationChannelWrapper;
}

export type NumberNGVariable = NGVariable & {
  name?: string;
  type?: "Number";
  value: number;
  default?: number;
};

export interface OnFailureConfig {
  errors: (
    | "Unknown"
    | "AllErrors"
    | "Authentication"
    | "Connectivity"
    | "Timeout"
    | "Authorization"
    | "Verification"
    | "DelegateProvisioning"
  )[];
  action: FailureStrategyActionConfig;
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig;
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig;
}

export type OpenshiftManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  skipResourceVersioning?: ParameterFieldBoolean;
  metadata?: string;
};

export type OpenshiftParamManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  metadata?: string;
};

export type PRBuildSpec = BuildSpec & {
  number: string;
};

export interface ParallelStageElementConfig {
  sections: StageElementWrapperConfig[];
}

export interface ParallelStepElementConfig {
  sections: ExecutionWrapperConfig[];
}

export interface ParameterField {
  expressionValue?: string;
  expression?: boolean;
  value?: { [key: string]: any };
  typeString?: boolean;
  inputSetValidator?: InputSetValidator;
  jsonResponseField?: boolean;
  responseField?: string;
}

export interface ParameterFieldBoolean {
  expressionValue?: string;
  expression?: boolean;
  value?: boolean;
  typeString?: boolean;
  inputSetValidator?: InputSetValidator;
  jsonResponseField?: boolean;
  responseField?: string;
}

export interface ParameterFieldString {
  expressionValue?: string;
  expression?: boolean;
  value?: string;
  typeString?: boolean;
  inputSetValidator?: InputSetValidator;
  jsonResponseField?: boolean;
  responseField?: string;
}

export interface PatchInstruction {
  type?:
    | "SetFeatureFlagState"
    | "AddTargetsToVariationTargetMap"
    | "RemoveTargetsToVariationTargetMap"
    | "AddSegmentsToVariationTargetMap"
    | "RemoveSegmentsToVariationTargetMap";
}

export type PercentageInstanceSelection = InstanceSelectionBase & {
  percentage?: ParameterFieldString;
};

export interface PipelineConfig {
  pipeline?: PipelineInfoConfig;
}

export interface PipelineEvent {
  type?:
    | "AllEvents"
    | "PipelineStart"
    | "PipelineSuccess"
    | "PipelineFailed"
    | "PipelineEnd"
    | "PipelinePaused"
    | "StageSuccess"
    | "StageFailed"
    | "StageStart"
    | "StepFailed";
  forStages?: string[];
}

export interface PipelineInfoConfig {
  name: string;
  identifier: string;
  flowControl?: FlowControlConfig;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  variables?: NGVariable[];
  properties?: NGProperties;
  stages?: StageElementWrapperConfig[];
  notificationRules?: NotificationRules[];
  orgIdentifier?: string;
  projectIdentifier?: string;
  timeout?: string;
}

export interface PipelineInfrastructure {
  infrastructureDefinition?: InfrastructureDef;
  useFromStage?: InfraUseFromStage;
  environment?: EnvironmentYaml;
  allowSimultaneousDeployments?: boolean;
  infrastructureKey?: string;
  environmentRef?: string;
}

export type PmsEmailChannel = PmsNotificationChannel & {
  userGroups?: string[];
  recipients?: string[];
};

export type PmsMSTeamChannel = PmsNotificationChannel & {
  msTeamKeys?: string[];
  userGroups?: string[];
};

export interface PmsNotificationChannel {
  [key: string]: any;
}

export type PmsPagerDutyChannel = PmsNotificationChannel & {
  userGroups?: string[];
  integrationKey?: string;
};

export type PmsSlackChannel = PmsNotificationChannel & {
  userGroups?: string[];
  webhookUrl?: string;
};

export interface PrimaryArtifact {
  type: "DockerRegistry" | "Gcr" | "Ecr";
  spec: ArtifactConfig;
}

export type RemoteTerraformVarFileSpec = TerraformVarFileSpec & {
  store: StoreConfigWrapper;
};

export type RemoveSegmentToVariationTargetMapYaml = PatchInstruction & {
  type: "RemoveSegmentToVariationTargetMap";
  identifier: string;
  spec: RemoveSegmentToVariationTargetMapYamlSpec;
};

export interface RemoveSegmentToVariationTargetMapYamlSpec {
  variation: string;
  segments: string[];
}

export type RemoveTargetsToVariationTargetMapYaml = PatchInstruction & {
  type: "RemoveTargetsToVariationTargetMap";
  identifier: string;
  spec: RemoveTargetsToVariationTargetMapYamlSpec;
};

export interface RemoveTargetsToVariationTargetMapYamlSpec {
  variation: string;
  targets: string[];
}

export type ResourceConstraintStepInfo = StepSpecType & {
  name: string;
  resourceUnit: string;
  acquireMode: "ENSURE" | "ACCUMULATE";
  permits: number;
  holdingScope: HoldingScope;
};

export interface ResponsePipelineConfig {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PipelineConfig;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryFailureSpecConfig;
  type: "Retry";
};

export interface RetryFailureSpecConfig {
  retryCount: number;
  retryIntervals: string[];
  onRetryFailure: OnRetryFailureConfig;
}

export type S3StoreConfig = StoreConfig & {
  connectorRef?: string;
  bucketName?: string;
  region?: string;
  folderPath?: string;
  metadata?: string;
};

export type SecretNGVariable = NGVariable & {
  name?: string;
  type?: "Secret";
  value: string;
  default?: string;
};

export interface ServiceConfig {
  useFromStage?: ServiceUseFromStage;
  service?: ServiceYaml;
  serviceRef?: string;
  serviceDefinition?: ServiceDefinition;
  stageOverrides?: StageOverridesConfig;
}

export interface ServiceDefinition {
  type: "Kubernetes";
  spec: ServiceSpec;
}

export interface ServiceOverrides {
  name?: string;
  description?: string;
}

export interface ServiceSpec {
  artifacts?: ArtifactListConfig;
  variables?: NGVariable[];
  variableOverrideSets?: NGVariableOverrideSetWrapper[];
  artifactOverrideSets?: ArtifactOverrideSetWrapper[];
  manifestOverrideSets?: ManifestOverrideSetWrapper[];
  manifests?: ManifestConfigWrapper[];
}

export interface ServiceUseFromStage {
  stage: string;
  overrides?: ServiceOverrides;
  metadata?: string;
}

export interface ServiceYaml {
  identifier: string;
  name: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
}

export type SetFeatureFlagStateYaml = PatchInstruction & {
  type: "SetFeatureFlagState";
  identifier: string;
  spec: SetFeatureFlagStateYamlSpec;
};

export interface SetFeatureFlagStateYamlSpec {
  state: string;
}

export interface ShellScriptBaseSource {
  type?: string;
}

export type ShellScriptInlineSource = ShellScriptBaseSource & {
  script?: string;
};

export interface ShellScriptSourceWrapper {
  type: string;
  spec: ShellScriptBaseSource;
}

export type ShellScriptStepInfo = StepSpecType & {
  shell: "Bash" | "PowerShell";
  source: ShellScriptSourceWrapper;
  executionTarget?: ExecutionTarget;
  onDelegate: boolean;
  delegateSelectors?: string[];
  outputVariables?: NGVariable[];
  environmentVariables?: NGVariable[];
  metadata?: string;
};

export interface SidecarArtifact {
  identifier: string;
  type: "DockerRegistry" | "Gcr" | "Ecr";
  spec: ArtifactConfig;
}

export interface SidecarArtifactWrapper {
  sidecar?: SidecarArtifact;
}

export interface StageElementConfig {
  identifier: string;
  name: string;
  description?: string;
  when?: StageWhenCondition;
  failureStrategies?: FailureStrategyConfig[];
  variables?: NGVariable[];
  tags?: {
    [key: string]: string;
  };
  type: string;
  spec?: StageInfoConfig;
}

export interface StageElementWrapperConfig {
  stage?: StageElementConfig;
  parallel?: ParallelStageElementConfig;
}

export interface StageInfoConfig {
  execution?: ExecutionElementConfig;
}

export interface StageOverridesConfig {
  variables?: NGVariable[];
  useVariableOverrideSets?: string[];
  useArtifactOverrideSets?: string[];
  artifacts?: ArtifactListConfig;
  useManifestOverrideSets?: string[];
  manifests?: ManifestConfigWrapper[];
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: "StageRollback";
};

export interface StageWhenCondition {
  pipelineStatus: "Success" | "Failure" | "All";
  condition?: string;
}

export interface StepElementConfig {
  identifier: string;
  name: string;
  description?: string;
  timeout?: string;
  failureStrategies?: FailureStrategyConfig[];
  when?: StepWhenCondition;
  type: string;
  spec?: StepSpecType;
}

export interface StepGroupElementConfig {
  identifier: string;
  name?: string;
  when?: StepWhenCondition;
  failureStrategies?: FailureStrategyConfig[];
  steps: ExecutionWrapperConfig[];
  rollbackSteps?: ExecutionWrapperConfig[];
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & {
  type: "StepGroupRollback";
};

export interface StepSpecType {
  [key: string]: any;
}

export interface StepWhenCondition {
  stageStatus: "Success" | "Failure" | "All";
  condition?: string;
}

export interface StoreConfig {
  [key: string]: any;
}

export interface StoreConfigWrapper {
  spec: StoreConfig;
  metadata?: string;
  type: "Git" | "Github" | "Bitbucket" | "GitLab" | "Http" | "S3" | "Gcs";
}

export type StringNGVariable = NGVariable & {
  name?: string;
  type?: "String";
  value: string;
  default?: string;
};

export type TagBuildSpec = BuildSpec & {
  tag: string;
};

export type TerraformApplyStepInfo = StepSpecType & {
  provisionerIdentifier: string;
  delegateSelectors?: string[];
  metadata?: string;
  configuration: TerraformStepConfiguration;
};

export interface TerraformBackendConfig {
  type?: string;
  spec?: TerraformBackendConfigSpec;
}

export interface TerraformBackendConfigSpec {
  [key: string]: any;
}

export interface TerraformConfigFilesWrapper {
  store: StoreConfigWrapper;
}

export type TerraformDestroyStepInfo = StepSpecType & {
  provisionerIdentifier: string;
  delegateSelectors?: string[];
  metadata?: string;
  configuration: TerraformStepConfiguration;
};

export interface TerraformExecutionData {
  workspace?: string;
  targets?: string[];
  environmentVariables?: NGVariable[];
  configFiles: TerraformConfigFilesWrapper;
  varFiles?: TerraformVarFileWrapper[];
  backendConfig?: TerraformBackendConfig;
}

export interface TerraformPlanExecutionData {
  workspace?: string;
  configFiles: TerraformConfigFilesWrapper;
  varFiles?: TerraformVarFileWrapper[];
  backendConfig?: TerraformBackendConfig;
  targets?: string[];
  environmentVariables?: NGVariable[];
  command: "Apply" | "Destroy";
  secretManagerRef: string;
}

export type TerraformPlanStepInfo = StepSpecType & {
  provisionerIdentifier: string;
  delegateSelectors?: string[];
  configuration: TerraformPlanExecutionData;
};

export type TerraformRollbackStepInfo = StepSpecType & {
  provisionerIdentifier: string;
  delegateSelectors?: string[];
};

export interface TerraformStepConfiguration {
  type: "Inline" | "InheritFromPlan" | "InheritFromApply";
  spec?: TerraformExecutionData;
}

export interface TerraformVarFile {
  type: string;
  identifier: string;
  spec: TerraformVarFileSpec;
}

export interface TerraformVarFileSpec {
  type?: string;
}

export interface TerraformVarFileWrapper {
  varFile: TerraformVarFile;
}

export interface TransitionTo {
  status: string;
  transitionName?: string;
}

export type ValuesManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  metadata?: string;
};

export interface CDPipelineModuleInfo {
  serviceIdentifiers?: string[];
  envIdentifiers?: string[];
  serviceDefinitionTypes?: string[];
  environmentTypes?: ("PreProduction" | "Production")[];
  infrastructureTypes?: string[];
}

export interface ResponseCDPipelineModuleInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: CDPipelineModuleInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface FeedbackFormDTO {
  accountId?: string;
  email?: string;
  moduleType?:
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE";
  score?: number;
  suggestion?: string;
}

export interface ContextElement {
  name?: string;
  elementType?:
    | "SERVICE"
    | "INFRAMAPPING"
    | "SERVICE_TEMPLATE"
    | "TAG"
    | "SHELL"
    | "HOST"
    | "INSTANCE"
    | "STANDARD"
    | "PARAM"
    | "PARTITION"
    | "OTHER"
    | "FORK"
    | "CONTAINER_SERVICE"
    | "CLUSTER"
    | "AWS_LAMBDA_FUNCTION"
    | "AMI_SERVICE_SETUP"
    | "AMI_SERVICE_DEPLOY"
    | "ECS_SERVICE_SETUP"
    | "AMI_SWITCH_ROUTES"
    | "PCF_SERVICE_SETUP"
    | "PCF_SERVICE_DEPLOY"
    | "PCF_ROUTE_SWAP_ROLLBACK"
    | "PCF_INSTANCE"
    | "SPOTINST_SERVICE_SETUP"
    | "SPOTINST_SERVICE_DEPLOY"
    | "ARTIFACT"
    | "ARTIFACT_VARIABLE"
    | "HELM_DEPLOY"
    | "CLOUD_FORMATION_PROVISION"
    | "CLOUD_FORMATION_ROLLBACK"
    | "CLOUD_FORMATION_DEPROVISION"
    | "TERRAFORM_PROVISION"
    | "SHELL_SCRIPT_PROVISION"
    | "K8S"
    | "TERRAFORM_INHERIT_PLAN"
    | "TERRAGRUNT_INHERIT_PLAN"
    | "AZURE_VMSS_SETUP"
    | "AZURE_WEBAPP_SETUP"
    | "HELM_CHART"
    | "MANIFEST_VARIABLE";
  uuid?: string;
}

export interface DOMConfiguration {
  parameterNames?: DOMStringList;
}

export interface DOMImplementation {
  [key: string]: any;
}

export interface DOMStringList {
  length?: number;
}

export interface DelegateMetaInfo {
  id?: string;
  hostName?: string;
}

export interface DelegateResponseData {
  [key: string]: any;
}

export interface Document {
  doctype?: DocumentType;
  documentElement?: Element;
  inputEncoding?: string;
  xmlEncoding?: string;
  xmlStandalone?: boolean;
  xmlVersion?: string;
  strictErrorChecking?: boolean;
  documentURI?: string;
  domConfig?: DOMConfiguration;
  implementation?: DOMImplementation;
  namespaceURI?: string;
  prefix?: string;
  attributes?: NamedNodeMap;
  localName?: string;
  nodeName?: string;
  nodeValue?: string;
  parentNode?: Node;
  childNodes?: NodeList;
  firstChild?: Node;
  lastChild?: Node;
  previousSibling?: Node;
  nextSibling?: Node;
  ownerDocument?: Document;
  baseURI?: string;
  textContent?: string;
  nodeType?: number;
}

export interface DocumentType {
  name?: string;
  publicId?: string;
  systemId?: string;
  entities?: NamedNodeMap;
  notations?: NamedNodeMap;
  internalSubset?: string;
  namespaceURI?: string;
  prefix?: string;
  attributes?: NamedNodeMap;
  localName?: string;
  nodeName?: string;
  nodeValue?: string;
  parentNode?: Node;
  childNodes?: NodeList;
  firstChild?: Node;
  lastChild?: Node;
  previousSibling?: Node;
  nextSibling?: Node;
  ownerDocument?: Document;
  baseURI?: string;
  textContent?: string;
  nodeType?: number;
}

export interface Element {
  tagName?: string;
  schemaTypeInfo?: TypeInfo;
  namespaceURI?: string;
  prefix?: string;
  attributes?: NamedNodeMap;
  localName?: string;
  nodeName?: string;
  nodeValue?: string;
  parentNode?: Node;
  childNodes?: NodeList;
  firstChild?: Node;
  lastChild?: Node;
  previousSibling?: Node;
  nextSibling?: Node;
  ownerDocument?: Document;
  baseURI?: string;
  textContent?: string;
  nodeType?: number;
}

export interface ExecutionDataValue {
  displayName?: string;
  value?: { [key: string]: any };
}

export type HttpStateExecutionData = DelegateResponseData & {
  httpUrl?: string;
  httpMethod?: string;
  httpResponseCode?: number;
  httpResponseBody?: string;
  assertionStatement?: string;
  assertionStatus?: string;
  header?: string;
  headers?: KeyValuePair[];
  useProxy?: boolean;
  warningMessage?: string;
  document?: Document;
  stateName?: string;
  stateType?: string;
  startTs?: number;
  endTs?: number;
  status?:
    | "ABORTED"
    | "DISCONTINUING"
    | "ERROR"
    | "FAILED"
    | "NEW"
    | "PAUSED"
    | "PAUSING"
    | "QUEUED"
    | "RESUMED"
    | "RUNNING"
    | "SCHEDULED"
    | "STARTING"
    | "SUCCESS"
    | "WAITING"
    | "SKIPPED"
    | "ABORTING"
    | "REJECTED"
    | "EXPIRED"
    | "PREPARING";
  errorMsg?: string;
  waitInterval?: number;
  element?: ContextElement;
  stateParams?: {
    [key: string]: { [key: string]: any };
  };
  delegateMetaInfo?: DelegateMetaInfo;
  templateVariable?: {
    [key: string]: { [key: string]: any };
  };
  executionSummary?: {
    [key: string]: ExecutionDataValue;
  };
  executionDetails?: {
    [key: string]: ExecutionDataValue;
  };
};

export interface KeyValuePair {
  key?: string;
  value?: string;
}

export interface NamedNodeMap {
  length?: number;
}

export interface Node {
  namespaceURI?: string;
  prefix?: string;
  attributes?: NamedNodeMap;
  localName?: string;
  nodeName?: string;
  nodeValue?: string;
  parentNode?: Node;
  childNodes?: NodeList;
  firstChild?: Node;
  lastChild?: Node;
  previousSibling?: Node;
  nextSibling?: Node;
  ownerDocument?: Document;
  baseURI?: string;
  textContent?: string;
  nodeType?: number;
}

export interface NodeList {
  length?: number;
}

export type ScriptStateExecutionData = DelegateResponseData & {
  name?: string;
  activityId?: string;
  sweepingOutputEnvVariables?: {
    [key: string]: string;
  };
  secretOutputVars?: string[];
  stateName?: string;
  stateType?: string;
  startTs?: number;
  endTs?: number;
  status?:
    | "ABORTED"
    | "DISCONTINUING"
    | "ERROR"
    | "FAILED"
    | "NEW"
    | "PAUSED"
    | "PAUSING"
    | "QUEUED"
    | "RESUMED"
    | "RUNNING"
    | "SCHEDULED"
    | "STARTING"
    | "SUCCESS"
    | "WAITING"
    | "SKIPPED"
    | "ABORTING"
    | "REJECTED"
    | "EXPIRED"
    | "PREPARING";
  errorMsg?: string;
  waitInterval?: number;
  element?: ContextElement;
  stateParams?: {
    [key: string]: { [key: string]: any };
  };
  delegateMetaInfo?: DelegateMetaInfo;
  templateVariable?: {
    [key: string]: { [key: string]: any };
  };
  executionSummary?: {
    [key: string]: ExecutionDataValue;
  };
  executionDetails?: {
    [key: string]: ExecutionDataValue;
  };
};

export interface TypeInfo {
  typeName?: string;
  typeNamespace?: string;
}

export interface JiraStatusCategoryNG {
  id: number;
  key: string;
  name: string;
}

export interface JiraStatusNG {
  id: string;
  name: string;
  statusCategory?: JiraStatusCategoryNG;
}

export interface ResponseListJiraStatusNG {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JiraStatusNG[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface JiraFieldAllowedValueNG {
  id?: string;
  name?: string;
  value?: string;
}

export interface JiraFieldNG {
  key: string;
  name: string;
  required?: boolean;
  schema: JiraFieldSchemaNG;
  allowedValues: JiraFieldAllowedValueNG[];
  custom?: boolean;
}

export interface JiraFieldSchemaNG {
  array?: boolean;
  typeStr: string;
  type: "string" | "number" | "date" | "datetime" | "timetracking" | "option";
  customType?: string;
}

export interface JiraIssueCreateMetadataNG {
  projects?: {
    [key: string]: JiraProjectNG;
  };
}

export interface JiraIssueTypeNG {
  id: string;
  name: string;
  description?: string;
  statuses: JiraStatusNG[];
  fields: {
    [key: string]: JiraFieldNG;
  };
  subTask?: boolean;
}

export interface JiraProjectNG {
  id: string;
  key: string;
  name: string;
  issuetypes: {
    [key: string]: JiraIssueTypeNG;
  };
}

export interface ResponseJiraIssueCreateMetadataNG {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JiraIssueCreateMetadataNG;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface JiraIssueUpdateMetadataNG {
  fields: {
    [key: string]: JiraFieldNG;
  };
}

export interface ResponseJiraIssueUpdateMetadataNG {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JiraIssueUpdateMetadataNG;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface JiraProjectBasicNG {
  id: string;
  key: string;
  name: string;
}

export interface ResponseListJiraProjectBasicNG {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JiraProjectBasicNG[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseServiceAccountDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceAccountDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceAccountDTO {
  identifier: string;
  name: string;
  email: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  accountIdentifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
}

export interface ResponseListServiceAccountDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceAccountDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageServiceAccountAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ServiceAccountAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageServiceAccountAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageServiceAccountAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceAccountAggregateDTO {
  serviceAccount: ServiceAccountDTO;
  createdAt: number;
  lastModifiedAt: number;
  tokensCount?: number;
  roleAssignmentsMetadataDTO?: RoleAssignmentMetadataDTO[];
}

export interface ResponseServiceAccountAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceAccountAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type AwsCodeCommitSCMDTO = SourceCodeManagerDTO & {
  authentication: AwsCodeCommitAuthenticationDTO;
};

export type AzureDevOpsSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication;
};

export type BitbucketSCMDTO = SourceCodeManagerDTO & {
  authentication?: BitbucketAuthentication;
};

export type GithubSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication;
};

export type GitlabSCMDTO = SourceCodeManagerDTO & {
  authentication: GitlabAuthentication;
};

export interface ResponseListSourceCodeManagerDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SourceCodeManagerDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SourceCodeManagerAuthentication {
  [key: string]: any;
}

export interface SourceCodeManagerDTO {
  id?: string;
  userIdentifier?: string;
  name: string;
  createdAt?: number;
  lastModifiedAt?: number;
  authentication?: SourceCodeManagerAuthentication;
  type?:
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "AWS_CODE_COMMIT"
    | "AZURE_DEV_OPS";
}

export interface ResponseSourceCodeManagerDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SourceCodeManagerDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PollingResponseDTO {
  pollingResponse?: string[];
}

export interface ResponsePollingResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PollingResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RestResponseUserInfo {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: UserInfo;
  responseMessages?: ResponseMessage[];
}

export interface SignupDTO {
  email?: string;
  password?: string;
  utmInfo?: UtmInfo;
  intent?: string;
  signupAction?: "REGULAR" | "TRIAL" | "SUBSCRIBE";
  edition?: "FREE" | "TEAM" | "ENTERPRISE";
  billingFrequency?: "MONTHLY" | "YEARLY";
}

export interface RestResponseVerifyTokenResponseDTO {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: VerifyTokenResponseDTO;
  responseMessages?: ResponseMessage[];
}

export interface VerifyTokenResponseDTO {
  accountIdentifier?: string;
}

export interface OAuthSignupDTO {
  email?: string;
  name?: string;
  utmInfo?: UtmInfo;
}

export interface JsonNode {
  array?: boolean;
  null?: boolean;
  containerNode?: boolean;
  valueNode?: boolean;
  missingNode?: boolean;
  object?: boolean;
  nodeType?:
    | "ARRAY"
    | "BINARY"
    | "BOOLEAN"
    | "MISSING"
    | "NULL"
    | "NUMBER"
    | "OBJECT"
    | "POJO"
    | "STRING";
  pojo?: boolean;
  number?: boolean;
  integralNumber?: boolean;
  floatingPointNumber?: boolean;
  short?: boolean;
  int?: boolean;
  long?: boolean;
  float?: boolean;
  double?: boolean;
  bigDecimal?: boolean;
  bigInteger?: boolean;
  textual?: boolean;
  boolean?: boolean;
  binary?: boolean;
}

export interface PartialSchemaDTO {
  schema?: JsonNode;
  nodeType?: string;
  nodeName?: string;
  namespace?: string;
  moduleType?:
    | "CD"
    | "CI"
    | "CV"
    | "CF"
    | "CE"
    | "CORE"
    | "PMS"
    | "TEMPLATESERVICE";
}

export interface ResponsePartialSchemaDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PartialSchemaDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseJsonNode {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JsonNode;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseYamlSnippets {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: YamlSnippets;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface YamlSnippetMetaData {
  name?: string;
  description?: string;
  version?: string;
  identifier?: string;
  tags?: string[];
  iconTag?: string;
}

export interface YamlSnippets {
  yamlSnippets?: YamlSnippetMetaData[];
}

export type ServiceRequestDTORequestBody = ServiceRequestDTO;

export type ApiKeyDTORequestBody = ApiKeyDTO;

export type TokenDTORequestBody = TokenDTO;

export type OrganizationRequestRequestBody = OrganizationRequest;

export type UploadSamlMetaDataRequestBody = void;

export type GcrRequestDTORequestBody = GcrRequestDTO;

export type ProjectRequestRequestBody = ProjectRequest;

export type GitSyncConfigRequestBody = GitSyncConfig;

export type DelegateProfileDetailsNgRequestBody = DelegateProfileDetailsNg;

export type WebhookCatcherBodyRequestBody = string;

export type ServiceAccountDTORequestBody = ServiceAccountDTO;

export type UserGroupDTORequestBody = UserGroupDTO;

export type FilterDTORequestBody = FilterDTO;

export type AccountDTORequestBody = AccountDTO;

export type ConnectorRequestBody = Connector;

export type GitSyncSettingsDTORequestBody = GitSyncSettingsDTO;

export type StartTrialDTORequestBody = StartTrialDTO;

export type UpdateWhitelistedDomainsBodyRequestBody = string[];

export type DockerRequestDTORequestBody = DockerRequestDTO;

export type EcrRequestDTORequestBody = EcrRequestDTO;

export type ScopingRuleDetailsNgArrayRequestBody = ScopingRuleDetailsNg[];

export type EnvironmentRequestDTORequestBody = EnvironmentRequestDTO;

export type SecretRequestWrapperRequestBody = SecretRequestWrapper;

export type SecretRequestWrapper2RequestBody = void;

export type UserFilterRequestBody = UserFilter;

export type ServiceRequestDTOArrayRequestBody = ServiceRequestDTO[];

export type SourceCodeManagerDTORequestBody = SourceCodeManagerDTO;

export type UnsubscribeBodyRequestBody = string[];

export interface SignupQueryParams {
  captchaToken?: string;
}

export type SignupProps = Omit<
  MutateProps<
    RestResponseVoid,
    Failure | Error,
    SignupQueryParams,
    SignupDTO,
    void
  >,
  "path" | "verb"
>;

export const Signup = (props: SignupProps) => (
  <Mutate<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTO, void>
    verb="POST"
    path={`/signup`}
    base={window.location.pathname.replace("auth/", "") + "gateway/ng/api"}
    {...props}
  />
);

export type UseSignupProps = Omit<
  UseMutateProps<
    RestResponseVoid,
    Failure | Error,
    SignupQueryParams,
    SignupDTO,
    void
  >,
  "path" | "verb"
>;

export const useSignup = (props: UseSignupProps) =>
  useMutate<
    RestResponseVoid,
    Failure | Error,
    SignupQueryParams,
    SignupDTO,
    void
  >("POST", `/signup`, {
    base: window.location.pathname.replace("auth/", "") + "gateway/ng/api",
    ...props
  });

export interface CompleteSignupInvitePathParams {
  token: string;
}

export type CompleteSignupInviteProps = Omit<
  MutateProps<
    RestResponseUserInfo,
    Failure | Error,
    void,
    void,
    CompleteSignupInvitePathParams
  >,
  "path" | "verb"
> &
  CompleteSignupInvitePathParams;

export const CompleteSignupInvite = ({
  token,
  ...props
}: CompleteSignupInviteProps) => (
  <Mutate<
    RestResponseUserInfo,
    Failure | Error,
    void,
    void,
    CompleteSignupInvitePathParams
  >
    verb="PUT"
    path={`/signup/complete/${token}`}
    base={window.location.pathname.replace("auth/", "") + "gateway/ng/api"}
    {...props}
  />
);

export type UseCompleteSignupInviteProps = Omit<
  UseMutateProps<
    RestResponseUserInfo,
    Failure | Error,
    void,
    void,
    CompleteSignupInvitePathParams
  >,
  "path" | "verb"
> &
  CompleteSignupInvitePathParams;

export const useCompleteSignupInvite = ({
  token,
  ...props
}: UseCompleteSignupInviteProps) =>
  useMutate<
    RestResponseUserInfo,
    Failure | Error,
    void,
    void,
    CompleteSignupInvitePathParams
  >(
    "PUT",
    (paramsInPath: CompleteSignupInvitePathParams) =>
      `/signup/complete/${paramsInPath.token}`,
    {
      base: window.location.pathname.replace("auth/", "") + "gateway/ng/api",
      pathParams: { token },
      ...props
    }
  );

export interface ResendVerifyEmailQueryParams {
  email: string;
}

export type ResendVerifyEmailProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    ResendVerifyEmailQueryParams,
    void,
    void
  >,
  "path" | "verb"
>;

/**
 * Resend user verification email
 */
export const ResendVerifyEmail = (props: ResendVerifyEmailProps) => (
  <Mutate<
    ResponseBoolean,
    Failure | Error,
    ResendVerifyEmailQueryParams,
    void,
    void
  >
    verb="POST"
    path={`/signup/verify-notification`}
    base={window.location.pathname.replace("auth/", "") + "gateway/ng/api"}
    {...props}
  />
);

export type UseResendVerifyEmailProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    ResendVerifyEmailQueryParams,
    void,
    void
  >,
  "path" | "verb"
>;

/**
 * Resend user verification email
 */
export const useResendVerifyEmail = (props: UseResendVerifyEmailProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    ResendVerifyEmailQueryParams,
    void,
    void
  >("POST", `/signup/verify-notification`, {
    base: window.location.pathname.replace("auth/", "") + "gateway/ng/api",
    ...props
  });
