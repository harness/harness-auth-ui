/* Generated by restful-react */

import React from "react";
import { Mutate, MutateProps, useMutate, UseMutateProps } from "restful-react";
export const SPEC_VERSION = "2.0";
export interface Account {
  uuid: string;
  appId: string;
  createdBy?: EmbeddedUser;
  createdAt?: number;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt: number;
  companyName: string;
  accountName: string;
  whitelistedDomains?: string[];
  licenseId?: string;
  dataRetentionDurationMs?: number;
  licenseInfo?: LicenseInfo;
  ceLicenseInfo?: CeLicenseInfo;
  accountEvents?: AccountEvent[];
  subdomainUrl?: string;
  twoFactorAdminEnforced?: boolean;
  forImport?: boolean;
  migratedToClusterUrl?: string;
  defaultExperience?: "NG" | "CG";
  localEncryptionEnabled?: boolean;
  delegateConfiguration?: DelegateConfiguration;
  techStacks?: TechStack[];
  oauthEnabled?: boolean;
  accountPreferences?: AccountPreferences;
  cloudCostEnabled?: boolean;
  ceAutoCollectK8sEvents?: boolean;
  trialSignupOptions?: TrialSignupOptions;
  serviceGuardLimit?: number;
  defaults?: {
    [key: string]: string;
  };
  harnessSupportAccessAllowed?: boolean;
  povAccount?: boolean;
}

export interface Response {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: { [key: string]: any };
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseAccount {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: Account;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Failure {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  code?:
    | "DEFAULT_ERROR_CODE"
    | "INVALID_ARGUMENT"
    | "INVALID_EMAIL"
    | "DOMAIN_NOT_ALLOWED_TO_REGISTER"
    | "USER_ALREADY_REGISTERED"
    | "USER_INVITATION_DOES_NOT_EXIST"
    | "USER_DOES_NOT_EXIST"
    | "USER_INVITE_OPERATION_FAILED"
    | "USER_DISABLED"
    | "ACCOUNT_DOES_NOT_EXIST"
    | "INACTIVE_ACCOUNT"
    | "ACCOUNT_MIGRATED"
    | "USER_DOMAIN_NOT_ALLOWED"
    | "MAX_FAILED_ATTEMPT_COUNT_EXCEEDED"
    | "RESOURCE_NOT_FOUND"
    | "ROLE_DOES_NOT_EXIST"
    | "EMAIL_NOT_VERIFIED"
    | "EMAIL_VERIFICATION_TOKEN_NOT_FOUND"
    | "INVALID_TOKEN"
    | "INVALID_CAPTCHA_TOKEN"
    | "NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS"
    | "EXPIRED_TOKEN"
    | "TOKEN_ALREADY_REFRESHED_ONCE"
    | "ACCESS_DENIED"
    | "NG_ACCESS_DENIED"
    | "INVALID_CREDENTIAL"
    | "INVALID_KEY"
    | "INVALID_KEYPATH"
    | "INVALID_VARIABLE"
    | "UNKNOWN_HOST"
    | "UNREACHABLE_HOST"
    | "INVALID_PORT"
    | "SSH_SESSION_TIMEOUT"
    | "SOCKET_CONNECTION_ERROR"
    | "SOCKET_CONNECTION_TIMEOUT"
    | "CONNECTION_TIMEOUT"
    | "SSH_CONNECTION_ERROR"
    | "USER_GROUP_ERROR"
    | "INVALID_EXECUTION_ID"
    | "ERROR_IN_GETTING_CHANNEL_STREAMS"
    | "UNEXPECTED"
    | "UNKNOWN_ERROR"
    | "UNKNOWN_EXECUTOR_TYPE_ERROR"
    | "DUPLICATE_STATE_NAMES"
    | "TRANSITION_NOT_LINKED"
    | "TRANSITION_TO_INCORRECT_STATE"
    | "TRANSITION_TYPE_NULL"
    | "STATES_WITH_DUP_TRANSITIONS"
    | "BARRIERS_NOT_RUNNING_CONCURRENTLY"
    | "NON_FORK_STATES"
    | "NON_REPEAT_STATES"
    | "INITIAL_STATE_NOT_DEFINED"
    | "FILE_INTEGRITY_CHECK_FAILED"
    | "INVALID_URL"
    | "FILE_DOWNLOAD_FAILED"
    | "PLATFORM_SOFTWARE_DELETE_ERROR"
    | "INVALID_CSV_FILE"
    | "INVALID_REQUEST"
    | "INVALID_INFRA_STATE"
    | "PIPELINE_ALREADY_TRIGGERED"
    | "NON_EXISTING_PIPELINE"
    | "DUPLICATE_COMMAND_NAMES"
    | "INVALID_PIPELINE"
    | "COMMAND_DOES_NOT_EXIST"
    | "DUPLICATE_ARTIFACTSTREAM_NAMES"
    | "DUPLICATE_HOST_NAMES"
    | "STATE_NOT_FOR_TYPE"
    | "STATE_MACHINE_ISSUE"
    | "STATE_DISCONTINUE_FAILED"
    | "STATE_PAUSE_FAILED"
    | "PAUSE_ALL_ALREADY"
    | "RESUME_ALL_ALREADY"
    | "ROLLBACK_ALREADY"
    | "ABORT_ALL_ALREADY"
    | "RETRY_FAILED"
    | "UNKNOWN_ARTIFACT_TYPE"
    | "UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE"
    | "INIT_TIMEOUT"
    | "LICENSE_EXPIRED"
    | "NOT_LICENSED"
    | "REQUEST_TIMEOUT"
    | "WORKFLOW_ALREADY_TRIGGERED"
    | "JENKINS_ERROR"
    | "INVALID_ARTIFACT_SOURCE"
    | "INVALID_ARTIFACT_SERVER"
    | "INVALID_CLOUD_PROVIDER"
    | "UPDATE_NOT_ALLOWED"
    | "DELETE_NOT_ALLOWED"
    | "APPDYNAMICS_CONFIGURATION_ERROR"
    | "APM_CONFIGURATION_ERROR"
    | "SPLUNK_CONFIGURATION_ERROR"
    | "ELK_CONFIGURATION_ERROR"
    | "LOGZ_CONFIGURATION_ERROR"
    | "SUMO_CONFIGURATION_ERROR"
    | "INSTANA_CONFIGURATION_ERROR"
    | "APPDYNAMICS_ERROR"
    | "STACKDRIVER_ERROR"
    | "STACKDRIVER_CONFIGURATION_ERROR"
    | "NEWRELIC_CONFIGURATION_ERROR"
    | "NEWRELIC_ERROR"
    | "DYNA_TRACE_CONFIGURATION_ERROR"
    | "DYNA_TRACE_ERROR"
    | "CLOUDWATCH_ERROR"
    | "CLOUDWATCH_CONFIGURATION_ERROR"
    | "PROMETHEUS_CONFIGURATION_ERROR"
    | "DATA_DOG_CONFIGURATION_ERROR"
    | "SERVICE_GUARD_CONFIGURATION_ERROR"
    | "ENCRYPTION_NOT_CONFIGURED"
    | "UNAVAILABLE_DELEGATES"
    | "WORKFLOW_EXECUTION_IN_PROGRESS"
    | "PIPELINE_EXECUTION_IN_PROGRESS"
    | "AWS_ACCESS_DENIED"
    | "AWS_CLUSTER_NOT_FOUND"
    | "AWS_SERVICE_NOT_FOUND"
    | "INVALID_YAML_PAYLOAD"
    | "UNRECOGNIZED_YAML_FIELDS"
    | "COULD_NOT_MAP_BEFORE_YAML"
    | "MISSING_BEFORE_YAML"
    | "MISSING_YAML"
    | "NON_EMPTY_DELETIONS"
    | "GENERAL_YAML_ERROR"
    | "GENERAL_YAML_INFO"
    | "YAML_GIT_SYNC_ERROR"
    | "GIT_CONNECTION_ERROR"
    | "GIT_ERROR"
    | "ARTIFACT_SERVER_ERROR"
    | "ENCRYPT_DECRYPT_ERROR"
    | "SECRET_MANAGEMENT_ERROR"
    | "KMS_OPERATION_ERROR"
    | "GCP_KMS_OPERATION_ERROR"
    | "VAULT_OPERATION_ERROR"
    | "AWS_SECRETS_MANAGER_OPERATION_ERROR"
    | "AZURE_KEY_VAULT_OPERATION_ERROR"
    | "CYBERARK_OPERATION_ERROR"
    | "UNSUPPORTED_OPERATION_EXCEPTION"
    | "FEATURE_UNAVAILABLE"
    | "GENERAL_ERROR"
    | "BASELINE_CONFIGURATION_ERROR"
    | "SAML_IDP_CONFIGURATION_NOT_AVAILABLE"
    | "INVALID_AUTHENTICATION_MECHANISM"
    | "INVALID_SAML_CONFIGURATION"
    | "INVALID_OAUTH_CONFIGURATION"
    | "INVALID_LDAP_CONFIGURATION"
    | "USER_GROUP_SYNC_FAILURE"
    | "USER_GROUP_ALREADY_EXIST"
    | "INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION"
    | "EXPLANATION"
    | "HINT"
    | "NOT_WHITELISTED_IP"
    | "INVALID_TOTP_TOKEN"
    | "EMAIL_FAILED"
    | "SSL_HANDSHAKE_FAILED"
    | "NO_APPS_ASSIGNED"
    | "INVALID_INFRA_CONFIGURATION"
    | "TEMPLATES_LINKED"
    | "USER_HAS_NO_PERMISSIONS"
    | "USER_NOT_AUTHORIZED"
    | "USER_ALREADY_PRESENT"
    | "INVALID_USAGE_RESTRICTION"
    | "USAGE_RESTRICTION_ERROR"
    | "STATE_EXECUTION_INSTANCE_NOT_FOUND"
    | "DELEGATE_TASK_RETRY"
    | "KUBERNETES_YAML_ERROR"
    | "SAVE_FILE_INTO_GCP_STORAGE_FAILED"
    | "READ_FILE_FROM_GCP_STORAGE_FAILED"
    | "USAGE_LIMITS_EXCEEDED"
    | "EVENT_PUBLISH_FAILED"
    | "JIRA_ERROR"
    | "EXPRESSION_EVALUATION_FAILED"
    | "KUBERNETES_VALUES_ERROR"
    | "KUBERNETES_CLUSTER_ERROR"
    | "INCORRECT_SIGN_IN_MECHANISM"
    | "OAUTH_LOGIN_FAILED"
    | "INVALID_TERRAFORM_TARGETS_REQUEST"
    | "TERRAFORM_EXECUTION_ERROR"
    | "FILE_READ_FAILED"
    | "FILE_SIZE_EXCEEDS_LIMIT"
    | "CLUSTER_NOT_FOUND"
    | "MARKETPLACE_TOKEN_NOT_FOUND"
    | "INVALID_MARKETPLACE_TOKEN"
    | "INVALID_TICKETING_SERVER"
    | "SERVICENOW_ERROR"
    | "PASSWORD_EXPIRED"
    | "USER_LOCKED"
    | "PASSWORD_STRENGTH_CHECK_FAILED"
    | "ACCOUNT_DISABLED"
    | "INVALID_ACCOUNT_PERMISSION"
    | "PAGERDUTY_ERROR"
    | "HEALTH_ERROR"
    | "SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED"
    | "DOMAIN_WHITELIST_FILTER_CHECK_FAILED"
    | "INVALID_DASHBOARD_UPDATE_REQUEST"
    | "DUPLICATE_FIELD"
    | "INVALID_AZURE_VAULT_CONFIGURATION"
    | "USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS"
    | "INVALID_ROLLBACK"
    | "SUMO_DATA_COLLECTION_ERROR"
    | "DEPLOYMENT_GOVERNANCE_ERROR"
    | "BATCH_PROCESSING_ERROR"
    | "GRAPHQL_ERROR"
    | "FILE_CREATE_ERROR"
    | "ILLEGAL_STATE"
    | "GIT_DIFF_COMMIT_NOT_IN_ORDER"
    | "FAILED_TO_ACQUIRE_PERSISTENT_LOCK"
    | "FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK"
    | "POD_NOT_FOUND_ERROR"
    | "COMMAND_EXECUTION_ERROR"
    | "REGISTRY_EXCEPTION"
    | "ENGINE_INTERRUPT_PROCESSING_EXCEPTION"
    | "ENGINE_IO_EXCEPTION"
    | "ENGINE_OUTCOME_EXCEPTION"
    | "ENGINE_SWEEPING_OUTPUT_EXCEPTION"
    | "CACHE_NOT_FOUND_EXCEPTION"
    | "ENGINE_ENTITY_UPDATE_EXCEPTION"
    | "SHELL_EXECUTION_EXCEPTION"
    | "TEMPLATE_NOT_FOUND"
    | "AZURE_SERVICE_EXCEPTION"
    | "AZURE_CLIENT_EXCEPTION"
    | "GIT_UNSEEN_REMOTE_HEAD_COMMIT"
    | "TIMEOUT_ENGINE_EXCEPTION"
    | "NO_AVAILABLE_DELEGATES"
    | "NO_INSTALLED_DELEGATES"
    | "DUPLICATE_DELEGATE_EXCEPTION"
    | "GCP_MARKETPLACE_EXCEPTION"
    | "MISSING_DEFAULT_GOOGLE_CREDENTIALS"
    | "INCORRECT_DEFAULT_GOOGLE_CREDENTIALS"
    | "OPTIMISTIC_LOCKING_EXCEPTION"
    | "NG_PIPELINE_EXECUTION_EXCEPTION"
    | "NG_PIPELINE_CREATE_EXCEPTION"
    | "RESOURCE_NOT_FOUND_EXCEPTION"
    | "PMS_INITIALIZE_SDK_EXCEPTION"
    | "UNEXPECTED_SNIPPET_EXCEPTION"
    | "UNEXPECTED_SCHEMA_EXCEPTION"
    | "CONNECTOR_VALIDATION_EXCEPTION"
    | "GCP_SECRET_MANAGER_OPERATION_ERROR"
    | "GCP_SECRET_OPERATION_ERROR"
    | "GIT_OPERATION_ERROR"
    | "TASK_FAILURE_ERROR"
    | "INSTANCE_STATS_PROCESS_ERROR"
    | "INSTANCE_STATS_MIGRATION_ERROR"
    | "DEPLOYMENT_MIGRATION_ERROR"
    | "INSTANCE_STATS_AGGREGATION_ERROR"
    | "UNRESOLVED_EXPRESSIONS_ERROR"
    | "KRYO_HANDLER_NOT_FOUND_ERROR"
    | "DELEGATE_ERROR_HANDLER_EXCEPTION"
    | "UNEXPECTED_TYPE_ERROR"
    | "EXCEPTION_HANDLER_NOT_FOUND"
    | "CONNECTOR_NOT_FOUND_EXCEPTION"
    | "GCP_SERVER_ERROR"
    | "HTTP_RESPONSE_EXCEPTION"
    | "DATA";
  message?: string;
  correlationId?: string;
  errors?: ValidationError[];
}

export interface ValidationError {
  fieldId?: string;
  error?: string;
}

export interface Error {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  code?:
    | "DEFAULT_ERROR_CODE"
    | "INVALID_ARGUMENT"
    | "INVALID_EMAIL"
    | "DOMAIN_NOT_ALLOWED_TO_REGISTER"
    | "USER_ALREADY_REGISTERED"
    | "USER_INVITATION_DOES_NOT_EXIST"
    | "USER_DOES_NOT_EXIST"
    | "USER_INVITE_OPERATION_FAILED"
    | "USER_DISABLED"
    | "ACCOUNT_DOES_NOT_EXIST"
    | "INACTIVE_ACCOUNT"
    | "ACCOUNT_MIGRATED"
    | "USER_DOMAIN_NOT_ALLOWED"
    | "MAX_FAILED_ATTEMPT_COUNT_EXCEEDED"
    | "RESOURCE_NOT_FOUND"
    | "ROLE_DOES_NOT_EXIST"
    | "EMAIL_NOT_VERIFIED"
    | "EMAIL_VERIFICATION_TOKEN_NOT_FOUND"
    | "INVALID_TOKEN"
    | "INVALID_CAPTCHA_TOKEN"
    | "NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS"
    | "EXPIRED_TOKEN"
    | "TOKEN_ALREADY_REFRESHED_ONCE"
    | "ACCESS_DENIED"
    | "NG_ACCESS_DENIED"
    | "INVALID_CREDENTIAL"
    | "INVALID_KEY"
    | "INVALID_KEYPATH"
    | "INVALID_VARIABLE"
    | "UNKNOWN_HOST"
    | "UNREACHABLE_HOST"
    | "INVALID_PORT"
    | "SSH_SESSION_TIMEOUT"
    | "SOCKET_CONNECTION_ERROR"
    | "SOCKET_CONNECTION_TIMEOUT"
    | "CONNECTION_TIMEOUT"
    | "SSH_CONNECTION_ERROR"
    | "USER_GROUP_ERROR"
    | "INVALID_EXECUTION_ID"
    | "ERROR_IN_GETTING_CHANNEL_STREAMS"
    | "UNEXPECTED"
    | "UNKNOWN_ERROR"
    | "UNKNOWN_EXECUTOR_TYPE_ERROR"
    | "DUPLICATE_STATE_NAMES"
    | "TRANSITION_NOT_LINKED"
    | "TRANSITION_TO_INCORRECT_STATE"
    | "TRANSITION_TYPE_NULL"
    | "STATES_WITH_DUP_TRANSITIONS"
    | "BARRIERS_NOT_RUNNING_CONCURRENTLY"
    | "NON_FORK_STATES"
    | "NON_REPEAT_STATES"
    | "INITIAL_STATE_NOT_DEFINED"
    | "FILE_INTEGRITY_CHECK_FAILED"
    | "INVALID_URL"
    | "FILE_DOWNLOAD_FAILED"
    | "PLATFORM_SOFTWARE_DELETE_ERROR"
    | "INVALID_CSV_FILE"
    | "INVALID_REQUEST"
    | "INVALID_INFRA_STATE"
    | "PIPELINE_ALREADY_TRIGGERED"
    | "NON_EXISTING_PIPELINE"
    | "DUPLICATE_COMMAND_NAMES"
    | "INVALID_PIPELINE"
    | "COMMAND_DOES_NOT_EXIST"
    | "DUPLICATE_ARTIFACTSTREAM_NAMES"
    | "DUPLICATE_HOST_NAMES"
    | "STATE_NOT_FOR_TYPE"
    | "STATE_MACHINE_ISSUE"
    | "STATE_DISCONTINUE_FAILED"
    | "STATE_PAUSE_FAILED"
    | "PAUSE_ALL_ALREADY"
    | "RESUME_ALL_ALREADY"
    | "ROLLBACK_ALREADY"
    | "ABORT_ALL_ALREADY"
    | "RETRY_FAILED"
    | "UNKNOWN_ARTIFACT_TYPE"
    | "UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE"
    | "INIT_TIMEOUT"
    | "LICENSE_EXPIRED"
    | "NOT_LICENSED"
    | "REQUEST_TIMEOUT"
    | "WORKFLOW_ALREADY_TRIGGERED"
    | "JENKINS_ERROR"
    | "INVALID_ARTIFACT_SOURCE"
    | "INVALID_ARTIFACT_SERVER"
    | "INVALID_CLOUD_PROVIDER"
    | "UPDATE_NOT_ALLOWED"
    | "DELETE_NOT_ALLOWED"
    | "APPDYNAMICS_CONFIGURATION_ERROR"
    | "APM_CONFIGURATION_ERROR"
    | "SPLUNK_CONFIGURATION_ERROR"
    | "ELK_CONFIGURATION_ERROR"
    | "LOGZ_CONFIGURATION_ERROR"
    | "SUMO_CONFIGURATION_ERROR"
    | "INSTANA_CONFIGURATION_ERROR"
    | "APPDYNAMICS_ERROR"
    | "STACKDRIVER_ERROR"
    | "STACKDRIVER_CONFIGURATION_ERROR"
    | "NEWRELIC_CONFIGURATION_ERROR"
    | "NEWRELIC_ERROR"
    | "DYNA_TRACE_CONFIGURATION_ERROR"
    | "DYNA_TRACE_ERROR"
    | "CLOUDWATCH_ERROR"
    | "CLOUDWATCH_CONFIGURATION_ERROR"
    | "PROMETHEUS_CONFIGURATION_ERROR"
    | "DATA_DOG_CONFIGURATION_ERROR"
    | "SERVICE_GUARD_CONFIGURATION_ERROR"
    | "ENCRYPTION_NOT_CONFIGURED"
    | "UNAVAILABLE_DELEGATES"
    | "WORKFLOW_EXECUTION_IN_PROGRESS"
    | "PIPELINE_EXECUTION_IN_PROGRESS"
    | "AWS_ACCESS_DENIED"
    | "AWS_CLUSTER_NOT_FOUND"
    | "AWS_SERVICE_NOT_FOUND"
    | "INVALID_YAML_PAYLOAD"
    | "UNRECOGNIZED_YAML_FIELDS"
    | "COULD_NOT_MAP_BEFORE_YAML"
    | "MISSING_BEFORE_YAML"
    | "MISSING_YAML"
    | "NON_EMPTY_DELETIONS"
    | "GENERAL_YAML_ERROR"
    | "GENERAL_YAML_INFO"
    | "YAML_GIT_SYNC_ERROR"
    | "GIT_CONNECTION_ERROR"
    | "GIT_ERROR"
    | "ARTIFACT_SERVER_ERROR"
    | "ENCRYPT_DECRYPT_ERROR"
    | "SECRET_MANAGEMENT_ERROR"
    | "KMS_OPERATION_ERROR"
    | "GCP_KMS_OPERATION_ERROR"
    | "VAULT_OPERATION_ERROR"
    | "AWS_SECRETS_MANAGER_OPERATION_ERROR"
    | "AZURE_KEY_VAULT_OPERATION_ERROR"
    | "CYBERARK_OPERATION_ERROR"
    | "UNSUPPORTED_OPERATION_EXCEPTION"
    | "FEATURE_UNAVAILABLE"
    | "GENERAL_ERROR"
    | "BASELINE_CONFIGURATION_ERROR"
    | "SAML_IDP_CONFIGURATION_NOT_AVAILABLE"
    | "INVALID_AUTHENTICATION_MECHANISM"
    | "INVALID_SAML_CONFIGURATION"
    | "INVALID_OAUTH_CONFIGURATION"
    | "INVALID_LDAP_CONFIGURATION"
    | "USER_GROUP_SYNC_FAILURE"
    | "USER_GROUP_ALREADY_EXIST"
    | "INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION"
    | "EXPLANATION"
    | "HINT"
    | "NOT_WHITELISTED_IP"
    | "INVALID_TOTP_TOKEN"
    | "EMAIL_FAILED"
    | "SSL_HANDSHAKE_FAILED"
    | "NO_APPS_ASSIGNED"
    | "INVALID_INFRA_CONFIGURATION"
    | "TEMPLATES_LINKED"
    | "USER_HAS_NO_PERMISSIONS"
    | "USER_NOT_AUTHORIZED"
    | "USER_ALREADY_PRESENT"
    | "INVALID_USAGE_RESTRICTION"
    | "USAGE_RESTRICTION_ERROR"
    | "STATE_EXECUTION_INSTANCE_NOT_FOUND"
    | "DELEGATE_TASK_RETRY"
    | "KUBERNETES_YAML_ERROR"
    | "SAVE_FILE_INTO_GCP_STORAGE_FAILED"
    | "READ_FILE_FROM_GCP_STORAGE_FAILED"
    | "USAGE_LIMITS_EXCEEDED"
    | "EVENT_PUBLISH_FAILED"
    | "JIRA_ERROR"
    | "EXPRESSION_EVALUATION_FAILED"
    | "KUBERNETES_VALUES_ERROR"
    | "KUBERNETES_CLUSTER_ERROR"
    | "INCORRECT_SIGN_IN_MECHANISM"
    | "OAUTH_LOGIN_FAILED"
    | "INVALID_TERRAFORM_TARGETS_REQUEST"
    | "TERRAFORM_EXECUTION_ERROR"
    | "FILE_READ_FAILED"
    | "FILE_SIZE_EXCEEDS_LIMIT"
    | "CLUSTER_NOT_FOUND"
    | "MARKETPLACE_TOKEN_NOT_FOUND"
    | "INVALID_MARKETPLACE_TOKEN"
    | "INVALID_TICKETING_SERVER"
    | "SERVICENOW_ERROR"
    | "PASSWORD_EXPIRED"
    | "USER_LOCKED"
    | "PASSWORD_STRENGTH_CHECK_FAILED"
    | "ACCOUNT_DISABLED"
    | "INVALID_ACCOUNT_PERMISSION"
    | "PAGERDUTY_ERROR"
    | "HEALTH_ERROR"
    | "SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED"
    | "DOMAIN_WHITELIST_FILTER_CHECK_FAILED"
    | "INVALID_DASHBOARD_UPDATE_REQUEST"
    | "DUPLICATE_FIELD"
    | "INVALID_AZURE_VAULT_CONFIGURATION"
    | "USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS"
    | "INVALID_ROLLBACK"
    | "SUMO_DATA_COLLECTION_ERROR"
    | "DEPLOYMENT_GOVERNANCE_ERROR"
    | "BATCH_PROCESSING_ERROR"
    | "GRAPHQL_ERROR"
    | "FILE_CREATE_ERROR"
    | "ILLEGAL_STATE"
    | "GIT_DIFF_COMMIT_NOT_IN_ORDER"
    | "FAILED_TO_ACQUIRE_PERSISTENT_LOCK"
    | "FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK"
    | "POD_NOT_FOUND_ERROR"
    | "COMMAND_EXECUTION_ERROR"
    | "REGISTRY_EXCEPTION"
    | "ENGINE_INTERRUPT_PROCESSING_EXCEPTION"
    | "ENGINE_IO_EXCEPTION"
    | "ENGINE_OUTCOME_EXCEPTION"
    | "ENGINE_SWEEPING_OUTPUT_EXCEPTION"
    | "CACHE_NOT_FOUND_EXCEPTION"
    | "ENGINE_ENTITY_UPDATE_EXCEPTION"
    | "SHELL_EXECUTION_EXCEPTION"
    | "TEMPLATE_NOT_FOUND"
    | "AZURE_SERVICE_EXCEPTION"
    | "AZURE_CLIENT_EXCEPTION"
    | "GIT_UNSEEN_REMOTE_HEAD_COMMIT"
    | "TIMEOUT_ENGINE_EXCEPTION"
    | "NO_AVAILABLE_DELEGATES"
    | "NO_INSTALLED_DELEGATES"
    | "DUPLICATE_DELEGATE_EXCEPTION"
    | "GCP_MARKETPLACE_EXCEPTION"
    | "MISSING_DEFAULT_GOOGLE_CREDENTIALS"
    | "INCORRECT_DEFAULT_GOOGLE_CREDENTIALS"
    | "OPTIMISTIC_LOCKING_EXCEPTION"
    | "NG_PIPELINE_EXECUTION_EXCEPTION"
    | "NG_PIPELINE_CREATE_EXCEPTION"
    | "RESOURCE_NOT_FOUND_EXCEPTION"
    | "PMS_INITIALIZE_SDK_EXCEPTION"
    | "UNEXPECTED_SNIPPET_EXCEPTION"
    | "UNEXPECTED_SCHEMA_EXCEPTION"
    | "CONNECTOR_VALIDATION_EXCEPTION"
    | "GCP_SECRET_MANAGER_OPERATION_ERROR"
    | "GCP_SECRET_OPERATION_ERROR"
    | "GIT_OPERATION_ERROR"
    | "TASK_FAILURE_ERROR"
    | "INSTANCE_STATS_PROCESS_ERROR"
    | "INSTANCE_STATS_MIGRATION_ERROR"
    | "DEPLOYMENT_MIGRATION_ERROR"
    | "INSTANCE_STATS_AGGREGATION_ERROR"
    | "UNRESOLVED_EXPRESSIONS_ERROR"
    | "KRYO_HANDLER_NOT_FOUND_ERROR"
    | "DELEGATE_ERROR_HANDLER_EXCEPTION"
    | "UNEXPECTED_TYPE_ERROR"
    | "EXCEPTION_HANDLER_NOT_FOUND"
    | "CONNECTOR_NOT_FOUND_EXCEPTION"
    | "GCP_SERVER_ERROR"
    | "HTTP_RESPONSE_EXCEPTION"
    | "DATA";
  message?: string;
  correlationId?: string;
  detailedMessage?: string;
  responseMessages?: ResponseMessage[];
}

export interface ResponseMessage {
  code?:
    | "DEFAULT_ERROR_CODE"
    | "INVALID_ARGUMENT"
    | "INVALID_EMAIL"
    | "DOMAIN_NOT_ALLOWED_TO_REGISTER"
    | "USER_ALREADY_REGISTERED"
    | "USER_INVITATION_DOES_NOT_EXIST"
    | "USER_DOES_NOT_EXIST"
    | "USER_INVITE_OPERATION_FAILED"
    | "USER_DISABLED"
    | "ACCOUNT_DOES_NOT_EXIST"
    | "INACTIVE_ACCOUNT"
    | "ACCOUNT_MIGRATED"
    | "USER_DOMAIN_NOT_ALLOWED"
    | "MAX_FAILED_ATTEMPT_COUNT_EXCEEDED"
    | "RESOURCE_NOT_FOUND"
    | "ROLE_DOES_NOT_EXIST"
    | "EMAIL_NOT_VERIFIED"
    | "EMAIL_VERIFICATION_TOKEN_NOT_FOUND"
    | "INVALID_TOKEN"
    | "INVALID_CAPTCHA_TOKEN"
    | "NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS"
    | "EXPIRED_TOKEN"
    | "TOKEN_ALREADY_REFRESHED_ONCE"
    | "ACCESS_DENIED"
    | "NG_ACCESS_DENIED"
    | "INVALID_CREDENTIAL"
    | "INVALID_KEY"
    | "INVALID_KEYPATH"
    | "INVALID_VARIABLE"
    | "UNKNOWN_HOST"
    | "UNREACHABLE_HOST"
    | "INVALID_PORT"
    | "SSH_SESSION_TIMEOUT"
    | "SOCKET_CONNECTION_ERROR"
    | "SOCKET_CONNECTION_TIMEOUT"
    | "CONNECTION_TIMEOUT"
    | "SSH_CONNECTION_ERROR"
    | "USER_GROUP_ERROR"
    | "INVALID_EXECUTION_ID"
    | "ERROR_IN_GETTING_CHANNEL_STREAMS"
    | "UNEXPECTED"
    | "UNKNOWN_ERROR"
    | "UNKNOWN_EXECUTOR_TYPE_ERROR"
    | "DUPLICATE_STATE_NAMES"
    | "TRANSITION_NOT_LINKED"
    | "TRANSITION_TO_INCORRECT_STATE"
    | "TRANSITION_TYPE_NULL"
    | "STATES_WITH_DUP_TRANSITIONS"
    | "BARRIERS_NOT_RUNNING_CONCURRENTLY"
    | "NON_FORK_STATES"
    | "NON_REPEAT_STATES"
    | "INITIAL_STATE_NOT_DEFINED"
    | "FILE_INTEGRITY_CHECK_FAILED"
    | "INVALID_URL"
    | "FILE_DOWNLOAD_FAILED"
    | "PLATFORM_SOFTWARE_DELETE_ERROR"
    | "INVALID_CSV_FILE"
    | "INVALID_REQUEST"
    | "INVALID_INFRA_STATE"
    | "PIPELINE_ALREADY_TRIGGERED"
    | "NON_EXISTING_PIPELINE"
    | "DUPLICATE_COMMAND_NAMES"
    | "INVALID_PIPELINE"
    | "COMMAND_DOES_NOT_EXIST"
    | "DUPLICATE_ARTIFACTSTREAM_NAMES"
    | "DUPLICATE_HOST_NAMES"
    | "STATE_NOT_FOR_TYPE"
    | "STATE_MACHINE_ISSUE"
    | "STATE_DISCONTINUE_FAILED"
    | "STATE_PAUSE_FAILED"
    | "PAUSE_ALL_ALREADY"
    | "RESUME_ALL_ALREADY"
    | "ROLLBACK_ALREADY"
    | "ABORT_ALL_ALREADY"
    | "RETRY_FAILED"
    | "UNKNOWN_ARTIFACT_TYPE"
    | "UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE"
    | "INIT_TIMEOUT"
    | "LICENSE_EXPIRED"
    | "NOT_LICENSED"
    | "REQUEST_TIMEOUT"
    | "WORKFLOW_ALREADY_TRIGGERED"
    | "JENKINS_ERROR"
    | "INVALID_ARTIFACT_SOURCE"
    | "INVALID_ARTIFACT_SERVER"
    | "INVALID_CLOUD_PROVIDER"
    | "UPDATE_NOT_ALLOWED"
    | "DELETE_NOT_ALLOWED"
    | "APPDYNAMICS_CONFIGURATION_ERROR"
    | "APM_CONFIGURATION_ERROR"
    | "SPLUNK_CONFIGURATION_ERROR"
    | "ELK_CONFIGURATION_ERROR"
    | "LOGZ_CONFIGURATION_ERROR"
    | "SUMO_CONFIGURATION_ERROR"
    | "INSTANA_CONFIGURATION_ERROR"
    | "APPDYNAMICS_ERROR"
    | "STACKDRIVER_ERROR"
    | "STACKDRIVER_CONFIGURATION_ERROR"
    | "NEWRELIC_CONFIGURATION_ERROR"
    | "NEWRELIC_ERROR"
    | "DYNA_TRACE_CONFIGURATION_ERROR"
    | "DYNA_TRACE_ERROR"
    | "CLOUDWATCH_ERROR"
    | "CLOUDWATCH_CONFIGURATION_ERROR"
    | "PROMETHEUS_CONFIGURATION_ERROR"
    | "DATA_DOG_CONFIGURATION_ERROR"
    | "SERVICE_GUARD_CONFIGURATION_ERROR"
    | "ENCRYPTION_NOT_CONFIGURED"
    | "UNAVAILABLE_DELEGATES"
    | "WORKFLOW_EXECUTION_IN_PROGRESS"
    | "PIPELINE_EXECUTION_IN_PROGRESS"
    | "AWS_ACCESS_DENIED"
    | "AWS_CLUSTER_NOT_FOUND"
    | "AWS_SERVICE_NOT_FOUND"
    | "INVALID_YAML_PAYLOAD"
    | "UNRECOGNIZED_YAML_FIELDS"
    | "COULD_NOT_MAP_BEFORE_YAML"
    | "MISSING_BEFORE_YAML"
    | "MISSING_YAML"
    | "NON_EMPTY_DELETIONS"
    | "GENERAL_YAML_ERROR"
    | "GENERAL_YAML_INFO"
    | "YAML_GIT_SYNC_ERROR"
    | "GIT_CONNECTION_ERROR"
    | "GIT_ERROR"
    | "ARTIFACT_SERVER_ERROR"
    | "ENCRYPT_DECRYPT_ERROR"
    | "SECRET_MANAGEMENT_ERROR"
    | "KMS_OPERATION_ERROR"
    | "GCP_KMS_OPERATION_ERROR"
    | "VAULT_OPERATION_ERROR"
    | "AWS_SECRETS_MANAGER_OPERATION_ERROR"
    | "AZURE_KEY_VAULT_OPERATION_ERROR"
    | "CYBERARK_OPERATION_ERROR"
    | "UNSUPPORTED_OPERATION_EXCEPTION"
    | "FEATURE_UNAVAILABLE"
    | "GENERAL_ERROR"
    | "BASELINE_CONFIGURATION_ERROR"
    | "SAML_IDP_CONFIGURATION_NOT_AVAILABLE"
    | "INVALID_AUTHENTICATION_MECHANISM"
    | "INVALID_SAML_CONFIGURATION"
    | "INVALID_OAUTH_CONFIGURATION"
    | "INVALID_LDAP_CONFIGURATION"
    | "USER_GROUP_SYNC_FAILURE"
    | "USER_GROUP_ALREADY_EXIST"
    | "INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION"
    | "EXPLANATION"
    | "HINT"
    | "NOT_WHITELISTED_IP"
    | "INVALID_TOTP_TOKEN"
    | "EMAIL_FAILED"
    | "SSL_HANDSHAKE_FAILED"
    | "NO_APPS_ASSIGNED"
    | "INVALID_INFRA_CONFIGURATION"
    | "TEMPLATES_LINKED"
    | "USER_HAS_NO_PERMISSIONS"
    | "USER_NOT_AUTHORIZED"
    | "USER_ALREADY_PRESENT"
    | "INVALID_USAGE_RESTRICTION"
    | "USAGE_RESTRICTION_ERROR"
    | "STATE_EXECUTION_INSTANCE_NOT_FOUND"
    | "DELEGATE_TASK_RETRY"
    | "KUBERNETES_YAML_ERROR"
    | "SAVE_FILE_INTO_GCP_STORAGE_FAILED"
    | "READ_FILE_FROM_GCP_STORAGE_FAILED"
    | "USAGE_LIMITS_EXCEEDED"
    | "EVENT_PUBLISH_FAILED"
    | "JIRA_ERROR"
    | "EXPRESSION_EVALUATION_FAILED"
    | "KUBERNETES_VALUES_ERROR"
    | "KUBERNETES_CLUSTER_ERROR"
    | "INCORRECT_SIGN_IN_MECHANISM"
    | "OAUTH_LOGIN_FAILED"
    | "INVALID_TERRAFORM_TARGETS_REQUEST"
    | "TERRAFORM_EXECUTION_ERROR"
    | "FILE_READ_FAILED"
    | "FILE_SIZE_EXCEEDS_LIMIT"
    | "CLUSTER_NOT_FOUND"
    | "MARKETPLACE_TOKEN_NOT_FOUND"
    | "INVALID_MARKETPLACE_TOKEN"
    | "INVALID_TICKETING_SERVER"
    | "SERVICENOW_ERROR"
    | "PASSWORD_EXPIRED"
    | "USER_LOCKED"
    | "PASSWORD_STRENGTH_CHECK_FAILED"
    | "ACCOUNT_DISABLED"
    | "INVALID_ACCOUNT_PERMISSION"
    | "PAGERDUTY_ERROR"
    | "HEALTH_ERROR"
    | "SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED"
    | "DOMAIN_WHITELIST_FILTER_CHECK_FAILED"
    | "INVALID_DASHBOARD_UPDATE_REQUEST"
    | "DUPLICATE_FIELD"
    | "INVALID_AZURE_VAULT_CONFIGURATION"
    | "USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS"
    | "INVALID_ROLLBACK"
    | "SUMO_DATA_COLLECTION_ERROR"
    | "DEPLOYMENT_GOVERNANCE_ERROR"
    | "BATCH_PROCESSING_ERROR"
    | "GRAPHQL_ERROR"
    | "FILE_CREATE_ERROR"
    | "ILLEGAL_STATE"
    | "GIT_DIFF_COMMIT_NOT_IN_ORDER"
    | "FAILED_TO_ACQUIRE_PERSISTENT_LOCK"
    | "FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK"
    | "POD_NOT_FOUND_ERROR"
    | "COMMAND_EXECUTION_ERROR"
    | "REGISTRY_EXCEPTION"
    | "ENGINE_INTERRUPT_PROCESSING_EXCEPTION"
    | "ENGINE_IO_EXCEPTION"
    | "ENGINE_OUTCOME_EXCEPTION"
    | "ENGINE_SWEEPING_OUTPUT_EXCEPTION"
    | "CACHE_NOT_FOUND_EXCEPTION"
    | "ENGINE_ENTITY_UPDATE_EXCEPTION"
    | "SHELL_EXECUTION_EXCEPTION"
    | "TEMPLATE_NOT_FOUND"
    | "AZURE_SERVICE_EXCEPTION"
    | "AZURE_CLIENT_EXCEPTION"
    | "GIT_UNSEEN_REMOTE_HEAD_COMMIT"
    | "TIMEOUT_ENGINE_EXCEPTION"
    | "NO_AVAILABLE_DELEGATES"
    | "NO_INSTALLED_DELEGATES"
    | "DUPLICATE_DELEGATE_EXCEPTION"
    | "GCP_MARKETPLACE_EXCEPTION"
    | "MISSING_DEFAULT_GOOGLE_CREDENTIALS"
    | "INCORRECT_DEFAULT_GOOGLE_CREDENTIALS"
    | "OPTIMISTIC_LOCKING_EXCEPTION"
    | "NG_PIPELINE_EXECUTION_EXCEPTION"
    | "NG_PIPELINE_CREATE_EXCEPTION"
    | "RESOURCE_NOT_FOUND_EXCEPTION"
    | "PMS_INITIALIZE_SDK_EXCEPTION"
    | "UNEXPECTED_SNIPPET_EXCEPTION"
    | "UNEXPECTED_SCHEMA_EXCEPTION"
    | "CONNECTOR_VALIDATION_EXCEPTION"
    | "GCP_SECRET_MANAGER_OPERATION_ERROR"
    | "GCP_SECRET_OPERATION_ERROR"
    | "GIT_OPERATION_ERROR"
    | "TASK_FAILURE_ERROR"
    | "INSTANCE_STATS_PROCESS_ERROR"
    | "INSTANCE_STATS_MIGRATION_ERROR"
    | "DEPLOYMENT_MIGRATION_ERROR"
    | "INSTANCE_STATS_AGGREGATION_ERROR"
    | "UNRESOLVED_EXPRESSIONS_ERROR"
    | "KRYO_HANDLER_NOT_FOUND_ERROR"
    | "DELEGATE_ERROR_HANDLER_EXCEPTION"
    | "UNEXPECTED_TYPE_ERROR"
    | "EXCEPTION_HANDLER_NOT_FOUND"
    | "CONNECTOR_NOT_FOUND_EXCEPTION"
    | "GCP_SERVER_ERROR"
    | "HTTP_RESPONSE_EXCEPTION"
    | "DATA";
  level?: "INFO" | "ERROR";
  message?: string;
  exception?: Throwable;
  failureTypes?: (
    | "EXPIRED"
    | "DELEGATE_PROVISIONING"
    | "CONNECTIVITY"
    | "AUTHENTICATION"
    | "VERIFICATION_FAILURE"
    | "APPLICATION_ERROR"
    | "AUTHORIZATION_ERROR"
    | "TIMEOUT_ERROR"
  )[];
}

export interface StackTraceElement {
  methodName?: string;
  fileName?: string;
  lineNumber?: number;
  className?: string;
  nativeMethod?: boolean;
}

export interface Throwable {
  cause?: Throwable;
  stackTrace?: StackTraceElement[];
  message?: string;
  localizedMessage?: string;
  suppressed?: Throwable[];
}

export interface ResponseStepCategory {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: StepCategory;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface StepCategory {
  name?: string;
  stepsData?: StepData[];
  stepCategories?: StepCategory[];
}

export interface StepData {
  type?:
    | "Placeholder"
    | "Placeholder"
    | "Placeholder"
    | "K8sRollingDeploy"
    | "K8sRollingRollback"
    | "K8sBGSwapServices"
    | "K8sDelete"
    | "K8sCanaryDelete"
    | "K8sCanaryDeploy"
    | "TerraformApply"
    | "TerraformPlan"
    | "TerraformDestroy"
    | "TerraformRollback"
    | "Placeholder"
    | "Placeholder"
    | "Placeholder"
    | "Placeholder"
    | "Placeholder"
    | "Placeholder"
    | "Placeholder"
    | "ShellScript"
    | "Placeholder"
    | "Placeholder";
  name?: string;
}

export interface ResponseMapServiceDefinitionTypeListExecutionStrategyType {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: {
    [key: string]: ("Basic" | "Canary" | "BlueGreen" | "Rolling" | "Default")[];
  };
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseString {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: string;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListServiceDefinitionType {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ("Ssh" | "Kubernetes" | "Ecs" | "NativeHelm" | "Pcf")[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface NGPipelineValidationInfo {
  pipelineYaml?: string;
  uuidToErrorResponseMap?: {
    [key: string]: VisitorErrorResponseWrapper;
  };
  errorResponse?: boolean;
}

export interface ResponseNGPipelineValidationInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: NGPipelineValidationInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface VisitorErrorResponse {
  fieldName?: string;
  message?: string;
}

export interface VisitorErrorResponseWrapper {
  errors?: VisitorErrorResponse[];
}

export interface ByteString {
  empty?: boolean;
  validUtf8?: boolean;
}

export interface Commit {
  unknownFields?: UnknownFieldSet;
  message?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserCommit;
  defaultInstanceForType?: Commit;
  messageBytes?: ByteString;
  link?: string;
  author?: Signature;
  authorOrBuilder?: SignatureOrBuilder;
  shaBytes?: ByteString;
  linkBytes?: ByteString;
  sha?: string;
  committer?: Signature;
  committerOrBuilder?: SignatureOrBuilder;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface CommitOrBuilder {
  message?: string;
  messageBytes?: ByteString;
  link?: string;
  author?: Signature;
  authorOrBuilder?: SignatureOrBuilder;
  shaBytes?: ByteString;
  linkBytes?: ByteString;
  sha?: string;
  committer?: Signature;
  committerOrBuilder?: SignatureOrBuilder;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface Descriptor {
  index?: number;
  fullName?: string;
  file?: FileDescriptor;
  containingType?: Descriptor;
  nestedTypes?: Descriptor[];
  enumTypes?: EnumDescriptor[];
  fields?: FieldDescriptor[];
  extensions?: FieldDescriptor[];
  oneofs?: OneofDescriptor[];
  name?: string;
  options?: MessageOptions;
  extendable?: boolean;
}

export interface EnumDescriptor {
  index?: number;
  fullName?: string;
  file?: FileDescriptor;
  containingType?: Descriptor;
  values?: EnumValueDescriptor[];
  name?: string;
  options?: EnumOptions;
}

export interface EnumOptions {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserEnumOptions;
  defaultInstanceForType?: EnumOptions;
  deprecated?: boolean;
  uninterpretedOptionList?: UninterpretedOption[];
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[];
  uninterpretedOptionCount?: number;
  allowAlias?: boolean;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  allFieldsRaw?: {
    [key: string]: { [key: string]: any };
  };
}

export interface EnumValueDescriptor {
  index?: number;
  fullName?: string;
  file?: FileDescriptor;
  type?: EnumDescriptor;
  name?: string;
  number?: number;
  options?: EnumValueOptions;
}

export interface EnumValueOptions {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserEnumValueOptions;
  defaultInstanceForType?: EnumValueOptions;
  deprecated?: boolean;
  uninterpretedOptionList?: UninterpretedOption[];
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[];
  uninterpretedOptionCount?: number;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  allFieldsRaw?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ExecutionMetadata {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserExecutionMetadata;
  defaultInstanceForType?: ExecutionMetadata;
  yaml?: string;
  runSequence?: number;
  triggerInfo?: ExecutionTriggerInfo;
  triggerInfoOrBuilder?: ExecutionTriggerInfoOrBuilder;
  triggerPayload?: TriggerPayload;
  triggerPayloadOrBuilder?: TriggerPayloadOrBuilder;
  pipelineIdentifier?: string;
  pipelineIdentifierBytes?: ByteString;
  inputSetYaml?: string;
  inputSetYamlBytes?: ByteString;
  executionUuid?: string;
  executionUuidBytes?: ByteString;
  yamlBytes?: ByteString;
  principalInfoOrBuilder?: ExecutionPrincipalInfoOrBuilder;
  processedYaml?: string;
  processedYamlBytes?: ByteString;
  principalInfo?: ExecutionPrincipalInfo;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ExecutionPrincipalInfo {
  unknownFields?: UnknownFieldSet;
  principal?: string;
  principalBytes?: ByteString;
  principalTypeValue?: number;
  principalType?:
    | "UNKNOWN"
    | "USER"
    | "USER_GROUP"
    | "API_KEY"
    | "SERVICE"
    | "UNRECOGNIZED";
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserExecutionPrincipalInfo;
  defaultInstanceForType?: ExecutionPrincipalInfo;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ExecutionPrincipalInfoOrBuilder {
  principal?: string;
  principalBytes?: ByteString;
  principalTypeValue?: number;
  principalType?:
    | "UNKNOWN"
    | "USER"
    | "USER_GROUP"
    | "API_KEY"
    | "SERVICE"
    | "UNRECOGNIZED";
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface ExecutionTriggerInfo {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserExecutionTriggerInfo;
  defaultInstanceForType?: ExecutionTriggerInfo;
  triggerTypeValue?: number;
  triggerType?:
    | "NOOP"
    | "MANUAL"
    | "WEBHOOK"
    | "WEBHOOK_CUSTOM"
    | "SCHEDULER_CRON"
    | "UNRECOGNIZED";
  triggeredBy?: TriggeredBy;
  triggeredByOrBuilder?: TriggeredByOrBuilder;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ExecutionTriggerInfoOrBuilder {
  triggerTypeValue?: number;
  triggerType?:
    | "NOOP"
    | "MANUAL"
    | "WEBHOOK"
    | "WEBHOOK_CUSTOM"
    | "SCHEDULER_CRON"
    | "UNRECOGNIZED";
  triggeredBy?: TriggeredBy;
  triggeredByOrBuilder?: TriggeredByOrBuilder;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface FieldDescriptor {
  index?: number;
  fullName?: string;
  jsonName?: string;
  file?: FileDescriptor;
  extensionScope?: Descriptor;
  type?:
    | "DOUBLE"
    | "FLOAT"
    | "INT64"
    | "UINT64"
    | "INT32"
    | "FIXED64"
    | "FIXED32"
    | "BOOL"
    | "STRING"
    | "GROUP"
    | "MESSAGE"
    | "BYTES"
    | "UINT32"
    | "ENUM"
    | "SFIXED32"
    | "SFIXED64"
    | "SINT32"
    | "SINT64";
  containingType?: Descriptor;
  messageType?: Descriptor;
  containingOneof?: OneofDescriptor;
  enumType?: EnumDescriptor;
  defaultValue?: { [key: string]: any };
  packed?: boolean;
  name?: string;
  number?: number;
  required?: boolean;
  optional?: boolean;
  repeated?: boolean;
  javaType?:
    | "INT"
    | "LONG"
    | "FLOAT"
    | "DOUBLE"
    | "BOOLEAN"
    | "STRING"
    | "BYTE_STRING"
    | "ENUM"
    | "MESSAGE";
  mapField?: boolean;
  options?: FieldOptions;
  extension?: boolean;
  liteJavaType?:
    | "INT"
    | "LONG"
    | "FLOAT"
    | "DOUBLE"
    | "BOOLEAN"
    | "STRING"
    | "BYTE_STRING"
    | "ENUM"
    | "MESSAGE";
  liteType?:
    | "DOUBLE"
    | "FLOAT"
    | "INT64"
    | "UINT64"
    | "INT32"
    | "FIXED64"
    | "FIXED32"
    | "BOOL"
    | "STRING"
    | "GROUP"
    | "MESSAGE"
    | "BYTES"
    | "UINT32"
    | "ENUM"
    | "SFIXED32"
    | "SFIXED64"
    | "SINT32"
    | "SINT64";
  packable?: boolean;
}

export interface FieldOptions {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserFieldOptions;
  defaultInstanceForType?: FieldOptions;
  lazy?: boolean;
  ctype?: "STRING" | "CORD" | "STRING_PIECE";
  jstype?: "JS_NORMAL" | "JS_STRING" | "JS_NUMBER";
  weak?: boolean;
  deprecated?: boolean;
  uninterpretedOptionList?: UninterpretedOption[];
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[];
  uninterpretedOptionCount?: number;
  packed?: boolean;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  allFieldsRaw?: {
    [key: string]: { [key: string]: any };
  };
}

export interface FileDescriptor {
  messageTypes?: Descriptor[];
  enumTypes?: EnumDescriptor[];
  services?: ServiceDescriptor[];
  extensions?: FieldDescriptor[];
  dependencies?: FileDescriptor[];
  publicDependencies?: FileDescriptor[];
  name?: string;
  package?: string;
  file?: FileDescriptor;
  fullName?: string;
  syntax?: "UNKNOWN" | "PROTO2" | "PROTO3";
  options?: FileOptions;
}

export interface FileOptions {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserFileOptions;
  defaultInstanceForType?: FileOptions;
  javaPackageBytes?: ByteString;
  javaOuterClassname?: string;
  javaPackage?: string;
  javaOuterClassnameBytes?: ByteString;
  javaMultipleFiles?: boolean;
  javaGenerateEqualsAndHash?: boolean;
  optimizeFor?: "SPEED" | "CODE_SIZE" | "LITE_RUNTIME";
  goPackage?: string;
  goPackageBytes?: ByteString;
  ccGenericServices?: boolean;
  javaGenericServices?: boolean;
  pyGenericServices?: boolean;
  phpGenericServices?: boolean;
  ccEnableArenas?: boolean;
  objcClassPrefix?: string;
  objcClassPrefixBytes?: ByteString;
  csharpNamespace?: string;
  csharpNamespaceBytes?: ByteString;
  swiftPrefix?: string;
  swiftPrefixBytes?: ByteString;
  phpClassPrefix?: string;
  phpClassPrefixBytes?: ByteString;
  phpNamespace?: string;
  phpNamespaceBytes?: ByteString;
  phpMetadataNamespace?: string;
  phpMetadataNamespaceBytes?: ByteString;
  rubyPackage?: string;
  rubyPackageBytes?: ByteString;
  deprecated?: boolean;
  uninterpretedOptionList?: UninterpretedOption[];
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[];
  uninterpretedOptionCount?: number;
  javaStringCheckUtf8?: boolean;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  allFieldsRaw?: {
    [key: string]: { [key: string]: any };
  };
}

export interface Label {
  unknownFields?: UnknownFieldSet;
  name?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserLabel;
  defaultInstanceForType?: Label;
  color?: string;
  colorBytes?: ByteString;
  nameBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface LabelOrBuilder {
  name?: string;
  color?: string;
  colorBytes?: ByteString;
  nameBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface Message {
  parserForType?: ParserMessage;
  serializedSize?: number;
  initialized?: boolean;
  defaultInstanceForType?: MessageLite;
  unknownFields?: UnknownFieldSet;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface MessageLite {
  serializedSize?: number;
  parserForType?: ParserMessageLite;
  initialized?: boolean;
  defaultInstanceForType?: MessageLite;
}

export interface MessageOptions {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserMessageOptions;
  defaultInstanceForType?: MessageOptions;
  noStandardDescriptorAccessor?: boolean;
  deprecated?: boolean;
  uninterpretedOptionList?: UninterpretedOption[];
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[];
  uninterpretedOptionCount?: number;
  mapEntry?: boolean;
  messageSetWireFormat?: boolean;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  allFieldsRaw?: {
    [key: string]: { [key: string]: any };
  };
}

export interface MethodDescriptor {
  index?: number;
  fullName?: string;
  file?: FileDescriptor;
  service?: ServiceDescriptor;
  inputType?: Descriptor;
  outputType?: Descriptor;
  name?: string;
  options?: MethodOptions;
  clientStreaming?: boolean;
  serverStreaming?: boolean;
}

export interface MethodOptions {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserMethodOptions;
  defaultInstanceForType?: MethodOptions;
  idempotencyLevel?: "IDEMPOTENCY_UNKNOWN" | "NO_SIDE_EFFECTS" | "IDEMPOTENT";
  deprecated?: boolean;
  uninterpretedOptionList?: UninterpretedOption[];
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[];
  uninterpretedOptionCount?: number;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  allFieldsRaw?: {
    [key: string]: { [key: string]: any };
  };
}

export interface NGPipelineError {
  fieldName?: string;
  message?: string;
  identifierOfErrorSource?: string;
}

export interface NGPipelineErrorResponse {
  errors?: NGPipelineError[];
}

export interface NGPipelineErrorWrapper {
  errorPipelineYaml?: string;
  uuidToErrorResponseMap?: {
    [key: string]: NGPipelineErrorResponse;
  };
}

export interface NGPipelineExecutionResponse {
  planExecution?: PlanExecution;
  pipelineErrorResponse?: NGPipelineErrorWrapper;
  errorResponse?: boolean;
}

export interface NamePart {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserNamePart;
  defaultInstanceForType?: NamePart;
  namePart?: string;
  namePartBytes?: ByteString;
  isExtension?: boolean;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface NamePartOrBuilder {
  namePart?: string;
  namePartBytes?: ByteString;
  isExtension?: boolean;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface OneofDescriptor {
  index?: number;
  fullName?: string;
  file?: FileDescriptor;
  containingType?: Descriptor;
  fieldCount?: number;
  fields?: FieldDescriptor[];
  name?: string;
  options?: OneofOptions;
}

export interface OneofOptions {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserOneofOptions;
  defaultInstanceForType?: OneofOptions;
  uninterpretedOptionList?: UninterpretedOption[];
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[];
  uninterpretedOptionCount?: number;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  allFieldsRaw?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ParsedPayload {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserParsedPayload;
  defaultInstanceForType?: ParsedPayload;
  push?: PushHook;
  pr?: PullRequestHook;
  pushOrBuilder?: PushHookOrBuilder;
  prOrBuilder?: PullRequestHookOrBuilder;
  payloadCase?: "PR" | "PUSH" | "PAYLOAD_NOT_SET";
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ParsedPayloadOrBuilder {
  push?: PushHook;
  pr?: PullRequestHook;
  pushOrBuilder?: PushHookOrBuilder;
  prOrBuilder?: PullRequestHookOrBuilder;
  payloadCase?: "PR" | "PUSH" | "PAYLOAD_NOT_SET";
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface Parser {
  [key: string]: any;
}

export interface ParserCommit {
  [key: string]: any;
}

export interface ParserEnumOptions {
  [key: string]: any;
}

export interface ParserEnumValueOptions {
  [key: string]: any;
}

export interface ParserExecutionMetadata {
  [key: string]: any;
}

export interface ParserExecutionPrincipalInfo {
  [key: string]: any;
}

export interface ParserExecutionTriggerInfo {
  [key: string]: any;
}

export interface ParserFieldOptions {
  [key: string]: any;
}

export interface ParserFileOptions {
  [key: string]: any;
}

export interface ParserLabel {
  [key: string]: any;
}

export interface ParserMessage {
  [key: string]: any;
}

export interface ParserMessageLite {
  [key: string]: any;
}

export interface ParserMessageOptions {
  [key: string]: any;
}

export interface ParserMethodOptions {
  [key: string]: any;
}

export interface ParserNamePart {
  [key: string]: any;
}

export interface ParserOneofOptions {
  [key: string]: any;
}

export interface ParserParsedPayload {
  [key: string]: any;
}

export interface ParserPerm {
  [key: string]: any;
}

export interface ParserPullRequest {
  [key: string]: any;
}

export interface ParserPullRequestHook {
  [key: string]: any;
}

export interface ParserPushHook {
  [key: string]: any;
}

export interface ParserReference {
  [key: string]: any;
}

export interface ParserRepository {
  [key: string]: any;
}

export interface ParserServiceOptions {
  [key: string]: any;
}

export interface ParserSignature {
  [key: string]: any;
}

export interface ParserTimestamp {
  [key: string]: any;
}

export interface ParserTriggerPayload {
  [key: string]: any;
}

export interface ParserTriggeredBy {
  [key: string]: any;
}

export interface ParserUninterpretedOption {
  [key: string]: any;
}

export interface ParserUser {
  [key: string]: any;
}

export interface Perm {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserPerm;
  defaultInstanceForType?: Perm;
  push?: boolean;
  pull?: boolean;
  admin?: boolean;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface PermOrBuilder {
  push?: boolean;
  pull?: boolean;
  admin?: boolean;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface PlanExecution {
  uuid?: string;
  createdAt?: number;
  setupAbstractions?: {
    [key: string]: string;
  };
  validUntil?: string;
  status?:
    | "NO_OP"
    | "RUNNING"
    | "INTERVENTION_WAITING"
    | "TIMED_WAITING"
    | "ASYNC_WAITING"
    | "TASK_WAITING"
    | "DISCONTINUING"
    | "PAUSING"
    | "QUEUED"
    | "SKIPPED"
    | "PAUSED"
    | "ABORTED"
    | "ERRORED"
    | "FAILED"
    | "EXPIRED"
    | "SUSPENDED"
    | "SUCCEEDED"
    | "IGNORE_FAILED"
    | "APPROVAL_WAITING"
    | "RESOURCE_WAITING"
    | "APPROVAL_REJECTED"
    | "UNRECOGNIZED";
  startTs?: number;
  endTs?: number;
  metadata?: ExecutionMetadata;
  lastUpdatedAt?: number;
  version?: number;
  nextIteration?: number;
}

export interface PullRequest {
  unknownFields?: UnknownFieldSet;
  target?: string;
  ref?: string;
  number?: number;
  title?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserPullRequest;
  defaultInstanceForType?: PullRequest;
  titleBytes?: ByteString;
  bodyBytes?: ByteString;
  fork?: string;
  sourceBytes?: ByteString;
  targetBytes?: ByteString;
  forkBytes?: ByteString;
  closed?: boolean;
  merged?: boolean;
  baseOrBuilder?: ReferenceOrBuilder;
  headOrBuilder?: ReferenceOrBuilder;
  labelsList?: Label[];
  labelsCount?: number;
  labelsOrBuilderList?: LabelOrBuilder[];
  base?: Reference;
  head?: Reference;
  source?: string;
  body?: string;
  refBytes?: ByteString;
  link?: string;
  created?: Timestamp;
  author?: User;
  authorOrBuilder?: UserOrBuilder;
  shaBytes?: ByteString;
  linkBytes?: ByteString;
  createdOrBuilder?: TimestampOrBuilder;
  updated?: Timestamp;
  updatedOrBuilder?: TimestampOrBuilder;
  sha?: string;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface PullRequestHook {
  unknownFields?: UnknownFieldSet;
  action?:
    | "UNKNOWN"
    | "CREATE"
    | "UPDATE"
    | "DELETE"
    | "OPEN"
    | "REOPEN"
    | "CLOSE"
    | "LABEL"
    | "UNLABEL"
    | "SYNC"
    | "MERGE"
    | "UNRECOGNIZED";
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserPullRequestHook;
  defaultInstanceForType?: PullRequestHook;
  repo?: Repository;
  pr?: PullRequest;
  prOrBuilder?: PullRequestOrBuilder;
  actionValue?: number;
  repoOrBuilder?: RepositoryOrBuilder;
  sender?: User;
  senderOrBuilder?: UserOrBuilder;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface PullRequestHookOrBuilder {
  action?:
    | "UNKNOWN"
    | "CREATE"
    | "UPDATE"
    | "DELETE"
    | "OPEN"
    | "REOPEN"
    | "CLOSE"
    | "LABEL"
    | "UNLABEL"
    | "SYNC"
    | "MERGE"
    | "UNRECOGNIZED";
  repo?: Repository;
  pr?: PullRequest;
  prOrBuilder?: PullRequestOrBuilder;
  actionValue?: number;
  repoOrBuilder?: RepositoryOrBuilder;
  sender?: User;
  senderOrBuilder?: UserOrBuilder;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface PullRequestOrBuilder {
  target?: string;
  ref?: string;
  number?: number;
  title?: string;
  titleBytes?: ByteString;
  bodyBytes?: ByteString;
  fork?: string;
  sourceBytes?: ByteString;
  targetBytes?: ByteString;
  forkBytes?: ByteString;
  closed?: boolean;
  merged?: boolean;
  baseOrBuilder?: ReferenceOrBuilder;
  headOrBuilder?: ReferenceOrBuilder;
  labelsList?: Label[];
  labelsCount?: number;
  labelsOrBuilderList?: LabelOrBuilder[];
  base?: Reference;
  head?: Reference;
  source?: string;
  body?: string;
  refBytes?: ByteString;
  link?: string;
  created?: Timestamp;
  author?: User;
  authorOrBuilder?: UserOrBuilder;
  shaBytes?: ByteString;
  linkBytes?: ByteString;
  createdOrBuilder?: TimestampOrBuilder;
  updated?: Timestamp;
  updatedOrBuilder?: TimestampOrBuilder;
  sha?: string;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface PushHook {
  unknownFields?: UnknownFieldSet;
  ref?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserPushHook;
  defaultInstanceForType?: PushHook;
  after?: string;
  baseRef?: string;
  baseRefBytes?: ByteString;
  repo?: Repository;
  refBytes?: ByteString;
  repoOrBuilder?: RepositoryOrBuilder;
  before?: string;
  beforeBytes?: ByteString;
  afterBytes?: ByteString;
  commit?: Commit;
  commitOrBuilder?: CommitOrBuilder;
  sender?: User;
  senderOrBuilder?: UserOrBuilder;
  commitsList?: Commit[];
  commitsCount?: number;
  commitsOrBuilderList?: CommitOrBuilder[];
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface PushHookOrBuilder {
  ref?: string;
  after?: string;
  baseRef?: string;
  baseRefBytes?: ByteString;
  repo?: Repository;
  refBytes?: ByteString;
  repoOrBuilder?: RepositoryOrBuilder;
  before?: string;
  beforeBytes?: ByteString;
  afterBytes?: ByteString;
  commit?: Commit;
  commitOrBuilder?: CommitOrBuilder;
  sender?: User;
  senderOrBuilder?: UserOrBuilder;
  commitsList?: Commit[];
  commitsCount?: number;
  commitsOrBuilderList?: CommitOrBuilder[];
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface Reference {
  unknownFields?: UnknownFieldSet;
  name?: string;
  path?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserReference;
  defaultInstanceForType?: Reference;
  nameBytes?: ByteString;
  shaBytes?: ByteString;
  sha?: string;
  pathBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ReferenceOrBuilder {
  name?: string;
  path?: string;
  nameBytes?: ByteString;
  shaBytes?: ByteString;
  sha?: string;
  pathBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface Repository {
  unknownFields?: UnknownFieldSet;
  name?: string;
  id?: string;
  namespace?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserRepository;
  defaultInstanceForType?: Repository;
  branch?: string;
  link?: string;
  created?: Timestamp;
  nameBytes?: ByteString;
  namespaceBytes?: ByteString;
  idBytes?: ByteString;
  perm?: Perm;
  permOrBuilder?: PermOrBuilder;
  branchBytes?: ByteString;
  private?: boolean;
  clone?: string;
  cloneBytes?: ByteString;
  cloneSsh?: string;
  cloneSshBytes?: ByteString;
  linkBytes?: ByteString;
  createdOrBuilder?: TimestampOrBuilder;
  updated?: Timestamp;
  updatedOrBuilder?: TimestampOrBuilder;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface RepositoryOrBuilder {
  name?: string;
  id?: string;
  namespace?: string;
  branch?: string;
  link?: string;
  created?: Timestamp;
  nameBytes?: ByteString;
  namespaceBytes?: ByteString;
  idBytes?: ByteString;
  perm?: Perm;
  permOrBuilder?: PermOrBuilder;
  branchBytes?: ByteString;
  private?: boolean;
  clone?: string;
  cloneBytes?: ByteString;
  cloneSsh?: string;
  cloneSshBytes?: ByteString;
  linkBytes?: ByteString;
  createdOrBuilder?: TimestampOrBuilder;
  updated?: Timestamp;
  updatedOrBuilder?: TimestampOrBuilder;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface ResponseNGPipelineExecutionResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: NGPipelineExecutionResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceDescriptor {
  index?: number;
  fullName?: string;
  file?: FileDescriptor;
  methods?: MethodDescriptor[];
  name?: string;
  options?: ServiceOptions;
}

export interface ServiceOptions {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserServiceOptions;
  defaultInstanceForType?: ServiceOptions;
  deprecated?: boolean;
  uninterpretedOptionList?: UninterpretedOption[];
  uninterpretedOptionOrBuilderList?: UninterpretedOptionOrBuilder[];
  uninterpretedOptionCount?: number;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  allFieldsRaw?: {
    [key: string]: { [key: string]: any };
  };
}

export interface Signature {
  unknownFields?: UnknownFieldSet;
  name?: string;
  login?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserSignature;
  defaultInstanceForType?: Signature;
  date?: Timestamp;
  dateOrBuilder?: TimestampOrBuilder;
  email?: string;
  nameBytes?: ByteString;
  emailBytes?: ByteString;
  avatar?: string;
  avatarBytes?: ByteString;
  loginBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface SignatureOrBuilder {
  name?: string;
  login?: string;
  date?: Timestamp;
  dateOrBuilder?: TimestampOrBuilder;
  email?: string;
  nameBytes?: ByteString;
  emailBytes?: ByteString;
  avatar?: string;
  avatarBytes?: ByteString;
  loginBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface Timestamp {
  unknownFields?: UnknownFieldSet;
  seconds?: number;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserTimestamp;
  defaultInstanceForType?: Timestamp;
  nanos?: number;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface TimestampOrBuilder {
  seconds?: number;
  nanos?: number;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface TriggerPayload {
  unknownFields?: UnknownFieldSet;
  type?: "CUSTOM" | "GIT" | "SCHEDULED" | "UNRECOGNIZED";
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserTriggerPayload;
  defaultInstanceForType?: TriggerPayload;
  jsonPayloadBytes?: ByteString;
  jsonPayload?: string;
  parsedPayload?: ParsedPayload;
  parsedPayloadOrBuilder?: ParsedPayloadOrBuilder;
  typeValue?: number;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface TriggerPayloadOrBuilder {
  type?: "CUSTOM" | "GIT" | "SCHEDULED" | "UNRECOGNIZED";
  jsonPayloadBytes?: ByteString;
  jsonPayload?: string;
  parsedPayload?: ParsedPayload;
  parsedPayloadOrBuilder?: ParsedPayloadOrBuilder;
  typeValue?: number;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface TriggeredBy {
  unknownFields?: UnknownFieldSet;
  identifier?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserTriggeredBy;
  defaultInstanceForType?: TriggeredBy;
  uuid?: string;
  uuidBytes?: ByteString;
  identifierBytes?: ByteString;
  extraInfoCount?: number;
  extraInfo?: {
    [key: string]: string;
  };
  extraInfoMap?: {
    [key: string]: string;
  };
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface TriggeredByOrBuilder {
  identifier?: string;
  uuid?: string;
  uuidBytes?: ByteString;
  identifierBytes?: ByteString;
  extraInfoCount?: number;
  extraInfo?: {
    [key: string]: string;
  };
  extraInfoMap?: {
    [key: string]: string;
  };
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface UninterpretedOption {
  unknownFields?: UnknownFieldSet;
  nameCount?: number;
  stringValue?: ByteString;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserUninterpretedOption;
  defaultInstanceForType?: UninterpretedOption;
  doubleValue?: number;
  nameList?: NamePart[];
  nameOrBuilderList?: NamePartOrBuilder[];
  identifierValue?: string;
  identifierValueBytes?: ByteString;
  positiveIntValue?: number;
  negativeIntValue?: number;
  aggregateValue?: string;
  aggregateValueBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface UninterpretedOptionOrBuilder {
  nameCount?: number;
  stringValue?: ByteString;
  doubleValue?: number;
  nameList?: NamePart[];
  nameOrBuilderList?: NamePartOrBuilder[];
  identifierValue?: string;
  identifierValueBytes?: ByteString;
  positiveIntValue?: number;
  negativeIntValue?: number;
  aggregateValue?: string;
  aggregateValueBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface UnknownFieldSet {
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: Parser;
  defaultInstanceForType?: UnknownFieldSet;
  serializedSizeAsMessageSet?: number;
}

export interface User {
  uuid: string;
  appId: string;
  createdBy?: EmbeddedUser;
  createdAt?: number;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt: number;
  name?: string;
  givenName?: string;
  familyName?: string;
  email?: string;
  companyName?: string;
  accountName?: string;
  userGroups?: UserGroup[];
  accounts?: Account[];
  pendingAccounts?: Account[];
  supportAccounts?: Account[];
  lastLogin?: number;
  firstLogin?: boolean;
  password?: string[];
  token?: string;
  twoFactorJwtToken?: string;
  emailVerified?: boolean;
  passwordExpired?: boolean;
  userLocked?: boolean;
  statsFetchedOn?: number;
  lastAccountId?: string;
  defaultAccountId?: string;
  lastAppId?: string;
  disabled?: boolean;
  imported?: boolean;
  userLockoutInfo?: UserLockoutInfo;
  twoFactorAuthenticationEnabled?: boolean;
  twoFactorAuthenticationMechanism?: "TOTP";
  oauthProvider?: string;
  reportedSegmentTracks?: string[];
  utmInfo?: UtmInfo;
  accountIds?: string[];
}

export interface UserOrBuilder {
  name?: string;
  login?: string;
  email?: string;
  created?: Timestamp;
  nameBytes?: ByteString;
  emailBytes?: ByteString;
  avatar?: string;
  avatarBytes?: ByteString;
  createdOrBuilder?: TimestampOrBuilder;
  updated?: Timestamp;
  updatedOrBuilder?: TimestampOrBuilder;
  loginBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export type AbortFailureActionConfig = FailureStrategyActionConfig & {
  type: "Abort";
};

export type AddSegmentToVariationTargetMapYaml = PatchInstruction & {
  type:
    | "SetFeatureFlagState"
    | "AddTargetsToVariationTargetMap"
    | "RemoveTargetsToVariationTargetMap"
    | "AddSegmentsToVariationTargetMap"
    | "RemoveSegmentsToVariationTargetMap";
  spec: AddSegmentToVariationTargetMapYamlSpec;
};

export interface AddSegmentToVariationTargetMapYamlSpec {
  variation?: string;
  segments?: string[];
}

export type AddTargetsToVariationTargetMapYaml = PatchInstruction & {
  type:
    | "SetFeatureFlagState"
    | "AddTargetsToVariationTargetMap"
    | "RemoveTargetsToVariationTargetMap"
    | "AddSegmentsToVariationTargetMap"
    | "RemoveSegmentsToVariationTargetMap";
  spec: AddTargetsToVariationTargetMapYamlSpec;
};

export interface AddTargetsToVariationTargetMapYamlSpec {
  variation?: string;
  targets?: string[];
}

export interface ApproverInputInfo {
  name?: string;
  defaultValue?: string;
}

export interface Approvers {
  userGroups: string[];
  minimumCount: number;
  disallowPipelineExecutor: boolean;
}

export interface ArtifactConfig {
  [key: string]: any;
}

export interface ArtifactListConfig {
  primary?: ArtifactSpecWrapper;
  sidecars?: SidecarArtifactWrapper[];
  metadata?: string;
}

export interface ArtifactOverrideSetWrapper {
  overrideSet?: ArtifactOverrideSets;
}

export interface ArtifactOverrideSets {
  identifier?: string;
  artifacts?: ArtifactListConfig;
}

export interface ArtifactSpecWrapper {
  type: "Dockerhub" | "Gcr" | "Ecr";
  spec?: ArtifactConfig;
}

export type BarrierStepInfo = StepSpecType & {
  barrierRef: string;
};

export type BitbucketStore = StoreConfig & {
  connectorRef?: string;
  gitFetchType?: "BRANCH" | "COMMIT";
  branch?: string;
  commitId?: string;
  paths?: string[];
  folderPath?: string;
  repoName?: string;
  metadata?: string;
};

export type BranchBuildSpec = BuildSpec & {
  branch: string;
};

export interface Build {
  type: "branch" | "tag";
  spec: BuildSpec;
}

export interface BuildSpec {
  [key: string]: any;
}

export interface CodeBase {
  connectorRef: string;
  repoName?: string;
  build: Build;
}

export interface Condition {
  key: string;
  value: string;
  operator: "equals" | "not equals" | "in" | "not in";
}

export type CountInstanceSelection = InstanceSelectionBase & {
  count?: string;
};

export interface CriteriaSpec {
  [key: string]: any;
}

export interface CriteriaSpecWrapper {
  type: "Jexl" | "KeyValues";
  spec: CriteriaSpec;
}

export type DeleteManifestPathSpec = DeleteResourcesBaseSpec & {
  manifestPaths?: string[];
};

export type DeleteReleaseNameSpec = DeleteResourcesBaseSpec & {};

export type DeleteResourceNameSpec = DeleteResourcesBaseSpec & {};

export interface DeleteResourcesBaseSpec {
  type?: "ResourceName" | "ReleaseName" | "ManifestPath";
  manifestPaths?: string;
  resourceNames?: string[];
  deleteNamespace?: boolean;
  allManifestPaths?: boolean;
}

export interface DeleteResourcesWrapper {
  type?: "ResourceName" | "ReleaseName" | "ManifestPath";
  spec?: DeleteResourcesBaseSpec;
}

export type DeploymentStage = StageType & {
  variables?: NGVariable[];
  serviceConfig?: ServiceConfig;
  infrastructure?: PipelineInfrastructure;
  execution?: ExecutionElement;
  skipCondition?: string;
  metadata?: string;
};

export type DockerHubArtifactConfig = ArtifactConfig & {
  connectorRef?: string;
  imagePath?: string;
  tag?: string;
  tagRegex?: string;
  metadata?: string;
};

export type EcrArtifactConfig = ArtifactConfig & {
  connectorRef?: string;
  region?: string;
  imagePath?: string;
  tag?: string;
  tagRegex?: string;
};

export interface EnvironmentYaml {
  name: string;
  identifier: string;
  description?: string;
  type: "PreProduction" | "Production";
  tags?: {
    [key: string]: string;
  };
}

export interface ExecutionElement {
  steps?: ExecutionWrapper[];
  rollbackSteps?: ExecutionWrapper[];
  metadata?: string;
}

export interface ExecutionElementConfig {
  steps?: ExecutionWrapperConfig[];
  rollbackSteps?: ExecutionWrapperConfig[];
}

export interface ExecutionTarget {
  host?: string;
  connectorRef?: string;
  workingDirectory?: string;
}

export interface ExecutionWrapper {
  [key: string]: any;
}

export interface ExecutionWrapperConfig {
  step?: StepElementConfig;
  parallel?: ParallelStepElementConfig;
  stepGroup?: StepGroupElementConfig;
}

export interface FailureStrategyActionConfig {
  type:
    | "Ignore"
    | "Retry"
    | "MarkAsSuccess"
    | "Abort"
    | "StageRollback"
    | "StepGroupRollback"
    | "ManualIntervention";
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig;
}

export type FeatureUpdateStepInfo = StepSpecType & {
  featureUpdateRef: string;
  feature: string;
  environment: string;
  instructions: PatchInstruction[];
  state: string;
};

export type GcrArtifactConfig = ArtifactConfig & {
  connectorRef?: string;
  registryHostname?: string;
  imagePath?: string;
  tag?: string;
  tagRegex?: string;
  metadata?: string;
};

export type GcsStoreConfig = StoreConfig & {
  connectorRef?: string;
  bucketName?: string;
  folderPath?: string;
  metadata?: string;
};

export type GitLabStore = StoreConfig & {
  connectorRef?: string;
  gitFetchType?: "BRANCH" | "COMMIT";
  branch?: string;
  commitId?: string;
  paths?: string[];
  folderPath?: string;
  repoName?: string;
  metadata?: string;
};

export type GitStore = StoreConfig & {
  connectorRef?: string;
  gitFetchType?: "BRANCH" | "COMMIT";
  branch?: string;
  commitId?: string;
  paths?: string[];
  folderPath?: string;
  repoName?: string;
  metadata?: string;
};

export type GithubStore = StoreConfig & {
  connectorRef?: string;
  gitFetchType?: "BRANCH" | "COMMIT";
  branch?: string;
  commitId?: string;
  paths?: string[];
  folderPath?: string;
  repoName?: string;
  metadata?: string;
};

export type HarnessApprovalStepInfo = StepSpecType & {
  approvalMessage: string;
  includePipelineExecutionHistory: boolean;
  approvers: Approvers;
  approverInputs?: ApproverInputInfo[];
};

export type HelmChartManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  chartName?: string;
  chartVersion?: string;
  helmVersion?: "V2" | "V3";
  skipResourceVersioning?: boolean;
  commandFlags?: HelmManifestCommandFlag[];
  metadata?: string;
};

export interface HelmManifestCommandFlag {
  commandType: "Fetch" | "Version" | "Template" | "Pull";
  flag?: string;
}

export interface HoldingScope {
  scope: string;
  nodeSetupId: string;
}

export interface HttpHeaderConfig {
  key?: string;
  value?: string;
}

export type HttpStepInfo = StepSpecType & {
  url: string;
  method: string;
  requestBody?: string;
  assertion?: string;
  outputVariables?: NGVariable[];
  headers?: HttpHeaderConfig[];
  delegateSelectors?: ParameterFieldListTaskSelectorYaml;
};

export type HttpStoreConfig = StoreConfig & {
  connectorRef?: string;
  metadata?: string;
};

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & {
  type: "Ignore";
};

export interface InfraOverrides {
  environment?: EnvironmentYaml;
  infrastructureDefinition?: InfrastructureDef;
}

export interface InfraUseFromStage {
  stage: string;
  overrides?: InfraOverrides;
}

export interface Infrastructure {
  [key: string]: any;
}

export interface InfrastructureDef {
  type?: string;
  spec?: Infrastructure;
  provisioner?: ExecutionElementConfig;
}

export type InlineTerraformBackendConfigSpec = TerraformBackendConfigSpec & {
  content?: string;
};

export type InlineTerraformVarFileSpec = TerraformVarFileSpec & {
  content?: string;
};

export interface InputSetValidator {
  validatorType?: "ALLOWED_VALUES" | "REGEX";
  parameters?: string;
}

export interface InstanceSelectionBase {
  type?: "Count" | "Percentage";
  instances?: number;
}

export interface InstanceSelectionWrapper {
  type?: "Count" | "Percentage";
  spec?: InstanceSelectionBase;
}

export type JexlCriteriaSpec = CriteriaSpec & {
  expression: string;
};

export type JiraApprovalStepInfo = StepSpecType & {
  connectorRef: string;
  issueKey: string;
  approvalCriteria: CriteriaSpecWrapper;
  rejectionCriteria: CriteriaSpecWrapper;
};

export type JiraCreateStepInfo = StepSpecType & {
  connectorRef?: string;
  projectKey?: string;
  issueType?: string;
  fields?: JiraField[];
};

export interface JiraField {
  name?: string;
  value: string;
}

export type JiraUpdateStepInfo = StepSpecType & {
  connectorRef: string;
  issueKey: string;
  transitionTo?: TransitionTo;
  fields?: JiraField[];
};

export type K8SDirectInfrastructure = Infrastructure & {
  connectorRef?: string;
  namespace?: string;
  releaseName?: string;
};

export type K8sApplyStepInfo = StepSpecType & {
  skipDryRun: ParameterFieldBoolean;
  skipSteadyStateCheck?: ParameterFieldBoolean;
  filePaths?: string[];
};

export type K8sBGSwapServicesStepInfo = StepSpecType & {
  skipDryRun?: boolean;
};

export type K8sBlueGreenStepInfo = StepSpecType & {
  skipDryRun?: ParameterFieldBoolean;
};

export type K8sCanaryDeleteStepInfo = StepSpecType & {
  skipDryRun?: boolean;
};

export type K8sCanaryStepInfo = StepSpecType & {
  instanceSelection: InstanceSelectionWrapper;
  skipDryRun?: ParameterFieldBoolean;
};

export type K8sDeleteStepInfo = StepSpecType & {
  deleteResources: DeleteResourcesWrapper;
  skipDryRun?: ParameterFieldBoolean;
};

export type K8sGcpInfrastructure = Infrastructure & {
  connectorRef?: string;
  namespace?: string;
  releaseName?: string;
  cluster?: string;
  metadata?: string;
};

export type K8sManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  skipResourceVersioning?: boolean;
  metadata?: string;
};

export type K8sRollingRollbackStepInfo = StepSpecType & {
  skipDryRun?: ParameterFieldBoolean;
};

export type K8sRollingStepInfo = StepSpecType & {
  skipDryRun: boolean;
};

export type K8sScaleStepInfo = StepSpecType & {
  instanceSelection: InstanceSelectionWrapper;
  workload?: string;
  skipDryRun?: ParameterFieldBoolean;
  skipSteadyStateCheck?: ParameterFieldBoolean;
};

export type KeyValuesCriteriaSpec = CriteriaSpec & {
  matchAnyCondition?: boolean;
  conditions: Condition[];
};

export type KubernetesServiceSpec = ServiceSpec & {
  metadata?: string;
};

export type KustomizeManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  skipResourceVersioning?: boolean;
  pluginPath?: string;
  metadata?: string;
};

export interface ManifestAttributes {
  [key: string]: any;
}

export interface ManifestConfig {
  identifier?: string;
  type?: string;
  spec?: ManifestAttributes;
}

export interface ManifestConfigWrapper {
  manifest?: ManifestConfig;
}

export interface ManifestOverrideSetWrapper {
  overrideSet?: ManifestOverrideSets;
}

export interface ManifestOverrideSets {
  identifier?: string;
  manifests?: ManifestConfigWrapper[];
}

export interface ManualFailureSpecConfig {
  timeout: string;
  onTimeout: OnTimeoutConfig;
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec: ManualFailureSpecConfig;
  type: "ManualIntervention";
};

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & {
  type: "MarkAsSuccess";
};

export interface NGVariable {
  name?: string;
  type?: "String" | "Number" | "Secret";
  required?: boolean;
  description?: string;
  metadata?: string;
}

export interface NGVariableOverrideSetWrapper {
  overrideSet?: NGVariableOverrideSets;
  uuid?: string;
}

export interface NGVariableOverrideSets {
  identifier?: string;
  variables?: NGVariable[];
}

export type NativeHelmServiceSpec = ServiceSpec & {
  metadata?: string;
};

export interface NgPipeline {
  name: string;
  identifier: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  variables?: NGVariable[];
  ciCodebase?: CodeBase;
  stages?: StageElementWrapper[];
  metadata?: string;
}

export type NumberNGVariable = NGVariable & {
  type?: "Number";
  value: number;
  default?: number;
};

export interface OnFailureConfig {
  errors: string[];
  action: FailureStrategyActionConfig;
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig;
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig;
}

export type OpenshiftManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  skipResourceVersioning?: boolean;
  metadata?: string;
};

export type OpenshiftParamManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  metadata?: string;
};

export type ParallelStageElement = StageElementWrapper & {
  sections: StageElementWrapper[];
  metadata?: string;
};

export type ParallelStepElement = ExecutionWrapper & {
  sections: ExecutionWrapper[];
  metadata?: string;
};

export interface ParallelStepElementConfig {
  sections: ExecutionWrapperConfig[];
}

export interface ParameterField {
  expressionValue?: string;
  expression?: boolean;
  value?: { [key: string]: any };
  typeString?: boolean;
  inputSetValidator?: InputSetValidator;
  jsonResponseField?: boolean;
  responseField?: string;
}

export interface ParameterFieldBoolean {
  expressionValue?: string;
  expression?: boolean;
  value?: boolean;
  typeString?: boolean;
  inputSetValidator?: InputSetValidator;
  jsonResponseField?: boolean;
  responseField?: string;
}

export interface ParameterFieldInteger {
  expressionValue?: string;
  expression?: boolean;
  value?: number;
  typeString?: boolean;
  inputSetValidator?: InputSetValidator;
  jsonResponseField?: boolean;
  responseField?: string;
}

export interface ParameterFieldListTaskSelectorYaml {
  expressionValue?: string;
  expression?: boolean;
  value?: TaskSelectorYaml[];
  typeString?: boolean;
  inputSetValidator?: InputSetValidator;
  jsonResponseField?: boolean;
  responseField?: string;
}

export interface PatchInstruction {
  type?:
    | "SetFeatureFlagState"
    | "AddTargetsToVariationTargetMap"
    | "RemoveTargetsToVariationTargetMap"
    | "AddSegmentsToVariationTargetMap"
    | "RemoveSegmentsToVariationTargetMap";
}

export type PercentageInstanceSelection = InstanceSelectionBase & {
  percentage?: ParameterFieldInteger;
};

export interface PipelineInfrastructure {
  infrastructureDefinition?: InfrastructureDef;
  useFromStage?: InfraUseFromStage;
  environment?: EnvironmentYaml;
  allowSimultaneousDeployments?: boolean;
  infrastructureKey?: string;
  environmentRef?: string;
}

export type RemoteTerraformVarFileSpec = TerraformVarFileSpec & {
  store?: StoreConfigWrapper;
};

export type RemoveSegmentToVariationTargetMapYaml = PatchInstruction & {
  type:
    | "SetFeatureFlagState"
    | "AddTargetsToVariationTargetMap"
    | "RemoveTargetsToVariationTargetMap"
    | "AddSegmentsToVariationTargetMap"
    | "RemoveSegmentsToVariationTargetMap";
  spec: RemoveSegmentToVariationTargetMapYamlSpec;
};

export interface RemoveSegmentToVariationTargetMapYamlSpec {
  variation?: string;
  segments?: string[];
}

export type RemoveTargetsToVariationTargetMapYaml = PatchInstruction & {
  type:
    | "SetFeatureFlagState"
    | "AddTargetsToVariationTargetMap"
    | "RemoveTargetsToVariationTargetMap"
    | "AddSegmentsToVariationTargetMap"
    | "RemoveSegmentsToVariationTargetMap";
  spec: RemoveTargetsToVariationTargetMapYamlSpec;
};

export interface RemoveTargetsToVariationTargetMapYamlSpec {
  variation?: string;
  targets?: string[];
}

export type ResourceConstraintStepInfo = StepSpecType & {
  name: string;
  resourceUnit: string;
  acquireMode: "ENSURE" | "ACCUMULATE";
  permits: number;
  holdingScope: HoldingScope;
};

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryFailureSpecConfig;
  type: "Retry";
};

export interface RetryFailureSpecConfig {
  retryCount: number;
  retryIntervals: string[];
  onRetryFailure: OnRetryFailureConfig;
}

export type S3StoreConfig = StoreConfig & {
  connectorRef?: string;
  bucketName?: string;
  region?: string;
  folderPath?: string;
  metadata?: string;
};

export type SecretNGVariable = NGVariable & {
  type?: "Secret";
  value: string;
  default?: string;
};

export interface ServiceConfig {
  useFromStage?: ServiceUseFromStage;
  service?: ServiceYaml;
  serviceRef?: string;
  serviceDefinition?: ServiceDefinition;
  stageOverrides?: StageOverridesConfig;
}

export interface ServiceDefinition {
  type?: string;
  spec?: ServiceSpec;
}

export interface ServiceOverrides {
  name?: string;
  description?: string;
}

export interface ServiceSpec {
  variables?: NGVariable[];
  artifacts?: ArtifactListConfig;
  manifestOverrideSets?: ManifestOverrideSetWrapper[];
  manifests?: ManifestConfigWrapper[];
  artifactOverrideSets?: ArtifactOverrideSetWrapper[];
  variableOverrideSets?: NGVariableOverrideSetWrapper[];
}

export interface ServiceUseFromStage {
  stage: string;
  overrides?: ServiceOverrides;
  metadata?: string;
}

export interface ServiceYaml {
  identifier: string;
  name: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
}

export type SetFeatureFlagStateYaml = PatchInstruction & {
  type:
    | "SetFeatureFlagState"
    | "AddTargetsToVariationTargetMap"
    | "RemoveTargetsToVariationTargetMap"
    | "AddSegmentsToVariationTargetMap"
    | "RemoveSegmentsToVariationTargetMap";
  spec: SetFeatureFlagStateYamlSpec;
};

export interface SetFeatureFlagStateYamlSpec {
  state?: string;
}

export interface ShellScriptBaseSource {
  type?: string;
}

export type ShellScriptInlineSource = ShellScriptBaseSource & {
  script?: string;
};

export interface ShellScriptSourceWrapper {
  type?: string;
  spec?: ShellScriptBaseSource;
}

export type ShellScriptStepInfo = StepSpecType & {
  shell: "Bash" | "PowerShell";
  source: ShellScriptSourceWrapper;
  executionTarget?: ExecutionTarget;
  onDelegate: ParameterFieldBoolean;
  outputVariables?: NGVariable[];
  environmentVariables?: NGVariable[];
  delegateSelectors?: ParameterFieldListTaskSelectorYaml;
  metadata?: string;
};

export interface SidecarArtifact {
  identifier?: string;
  type: "Dockerhub" | "Gcr" | "Ecr";
  spec?: ArtifactConfig;
}

export interface SidecarArtifactWrapper {
  sidecar?: SidecarArtifact;
}

export type StageElement = StageElementWrapper & {
  identifier: string;
  name?: string;
  description?: string;
  failureStrategies: FailureStrategyConfig[];
  type?: string;
  skipCondition?: string;
  metadata?: string;
  spec?: StageType;
};

export interface StageElementWrapper {
  [key: string]: any;
}

export interface StageOverridesConfig {
  variables?: NGVariable[];
  useVariableOverrideSets?: string[];
  useArtifactOverrideSets?: string[];
  artifacts?: ArtifactListConfig;
  useManifestOverrideSets?: string[];
  manifests?: ManifestConfigWrapper[];
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: "StageRollback";
};

export interface StageType {
  identifier: string;
}

export type StepElement = ExecutionWrapper & {
  identifier: string;
  name?: string;
  failureStrategies?: FailureStrategyConfig[];
  type?: string;
  skipCondition?: string;
  metadata?: string;
  spec?: StepSpecType;
};

export interface StepElementConfig {
  identifier?: string;
  name?: string;
  description?: string;
  timeout?: string;
  failureStrategies?: FailureStrategyConfig[];
  skipCondition?: string;
  type?: string;
  spec?: StepSpecType;
}

export type StepGroupElement = ExecutionWrapper & {
  identifier: string;
  name?: string;
  failureStrategies?: FailureStrategyConfig[];
  steps: ExecutionWrapper[];
  rollbackSteps?: ExecutionWrapper[];
  metadata?: string;
};

export interface StepGroupElementConfig {
  identifier: string;
  name?: string;
  skipCondition?: string;
  failureStrategies?: FailureStrategyConfig[];
  steps: ExecutionWrapperConfig[];
  rollbackSteps?: ExecutionWrapperConfig[];
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & {
  type: "StepGroupRollback";
};

export interface StepSpecType {
  [key: string]: any;
}

export interface StoreConfig {
  [key: string]: any;
}

export interface StoreConfigWrapper {
  type?: string;
  metadata?: string;
  spec?: StoreConfig;
}

export type StringNGVariable = NGVariable & {
  type?: "String";
  value: string;
  default?: string;
};

export type TagBuildSpec = BuildSpec & {
  tag: string;
};

export interface TaskSelectorYaml {
  delegateSelectors?: string;
}

export type TerraformApplyStepInfo = StepSpecType & {
  provisionerIdentifier?: string;
  metadata?: string;
  configuration?: TerrformStepConfiguration;
};

export interface TerraformBackendConfig {
  type?: string;
  spec?: TerraformBackendConfigSpec;
}

export interface TerraformBackendConfigSpec {
  [key: string]: any;
}

export interface TerraformConfigFilesWrapper {
  store?: StoreConfigWrapper;
}

export type TerraformDestroyStepInfo = StepSpecType & {
  provisionerIdentifier?: string;
  metadata?: string;
  configuration?: TerrformStepConfiguration;
};

export interface TerraformExecutionData {
  workspace?: string;
  targets?: string[];
  environmentVariables?: NGVariable[];
  configFiles?: TerraformConfigFilesWrapper;
  varFiles?: TerraformVarFileWrapper[];
  backendConfig?: TerraformBackendConfig;
}

export interface TerraformPlanExecutionData {
  workspace?: string;
  targets?: string[];
  environmentVariables?: NGVariable[];
  command?: "Apply" | "Destroy";
  secretManagerRef?: string;
  configFiles?: TerraformConfigFilesWrapper;
  varFiles?: TerraformVarFileWrapper[];
  backendConfig?: TerraformBackendConfig;
}

export type TerraformPlanStepInfo = StepSpecType & {
  provisionerIdentifier?: string;
  configuration?: TerraformPlanExecutionData;
};

export interface TerraformVarFile {
  type?: string;
  spec?: TerraformVarFileSpec;
}

export interface TerraformVarFileSpec {
  type?: string;
}

export interface TerraformVarFileWrapper {
  varFile?: TerraformVarFile;
}

export interface TerrformStepConfiguration {
  type?: "Inline" | "InheritFromPlan" | "InheritFromApply";
  spec?: TerraformExecutionData;
}

export interface TransitionTo {
  status: string;
  transitionName?: string;
}

export type ValuesManifest = ManifestAttributes & {
  store?: StoreConfigWrapper;
  metadata?: string;
};

export interface MergeInputSetRequest {
  inputSetReferences?: string[];
}

export type AppDynamicsConnectorDTO = ConnectorConfigDTO & {
  username?: string;
  accountname: string;
  controllerUrl: string;
  accountId: string;
  delegateSelectors?: string[];
  passwordRef?: string;
  clientSecretRef?: string;
  clientId?: string;
  authType?: "UsernamePassword" | "ApiClientToken";
};

export interface ArtifactoryAuthCredentials {
  [key: string]: any;
}

export interface ArtifactoryAuthentication {
  type: "UsernamePassword" | "Anonymous";
  spec?: ArtifactoryAuthCredentials;
}

export type ArtifactoryConnector = ConnectorConfigDTO & {
  artifactoryServerUrl: string;
  auth?: ArtifactoryAuthentication;
  delegateSelectors?: string[];
};

export type ArtifactoryUsernamePasswordAuth = ArtifactoryAuthCredentials & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export interface AwsCodeCommitAuthenticationDTO {
  type: "HTTPS";
  spec: AwsCodeCommitCredentialsDTO;
}

export type AwsCodeCommitConnectorDTO = ConnectorConfigDTO & {
  url: string;
  authentication: AwsCodeCommitAuthenticationDTO;
  delegateSelectors?: string[];
  type: "Repo" | "Region";
};

export interface AwsCodeCommitCredentialsDTO {
  [key: string]: any;
}

export type AwsCodeCommitHttpsCredentialsDTO = AwsCodeCommitCredentialsDTO & {
  type: "AWSCredentials";
  spec: AwsCodeCommitHttpsCredentialsSpecDTO;
};

export interface AwsCodeCommitHttpsCredentialsSpecDTO {
  [key: string]: any;
}

export type AwsCodeCommitSecretKeyAccessKeyDTO = AwsCodeCommitHttpsCredentialsSpecDTO & {
  accessKey?: string;
  accessKeyRef?: string;
  secretKeyRef: string;
};

export type AwsConnector = ConnectorConfigDTO & {
  credential: AwsCredential;
  delegateSelectors?: string[];
};

export interface AwsCredential {
  crossAccountAccess?: CrossAccountAccess;
  type: "InheritFromDelegate" | "ManualConfig";
  spec?: AwsCredentialSpec;
}

export interface AwsCredentialSpec {
  [key: string]: any;
}

export interface AwsCurAttributes {
  reportName: string;
  s3BucketName: string;
}

export interface AwsKmsConnectorCredential {
  type: "AssumeIAMRole" | "AssumeSTSRole" | "ManualConfig";
  spec?: AwsKmsCredentialSpec;
}

export type AwsKmsConnectorDTO = ConnectorConfigDTO & {
  credential?: AwsKmsConnectorCredential;
  kmsArn?: string;
  region?: string;
  default?: boolean;
};

export interface AwsKmsCredentialSpec {
  [key: string]: any;
}

export type AwsKmsCredentialSpecAssumeIAM = AwsKmsCredentialSpec & {
  delegateSelectors: string[];
};

export type AwsKmsCredentialSpecAssumeSTS = AwsKmsCredentialSpec & {
  delegateSelectors: string[];
  roleArn: string;
  externalName?: string;
  assumeStsRoleDuration?: number;
};

export type AwsKmsCredentialSpecManualConfig = AwsKmsCredentialSpec & {
  accessKey: string;
  secretKey: string;
};

export type AwsManualConfigSpec = AwsCredentialSpec & {
  accessKey?: string;
  accessKeyRef?: string;
  secretKeyRef: string;
};

export interface BillingExportSpec {
  storageAccountName: string;
  containerName: string;
  directoryName: string;
}

export interface BitbucketApiAccess {
  type: "UsernameToken";
  spec: BitbucketApiAccessSpecDTO;
}

export interface BitbucketApiAccessSpecDTO {
  [key: string]: any;
}

export interface BitbucketAuthentication {
  type: "Http" | "Ssh";
  spec: BitbucketCredentialsDTO;
}

export type BitbucketConnector = ConnectorConfigDTO & {
  url: string;
  authentication: BitbucketAuthentication;
  apiAccess?: BitbucketApiAccess;
  delegateSelectors?: string[];
  type: "Account" | "Repo";
};

export interface BitbucketCredentialsDTO {
  [key: string]: any;
}

export type BitbucketHttpCredentials = BitbucketCredentialsDTO & {
  type: "UsernamePassword";
  spec: BitbucketHttpCredentialsSpecDTO;
};

export interface BitbucketHttpCredentialsSpecDTO {
  [key: string]: any;
}

export type BitbucketSshCredentials = BitbucketCredentialsDTO & {
  sshKeyRef: string;
};

export type BitbucketUsernamePassword = BitbucketHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type BitbucketUsernameTokenApiAccess = BitbucketApiAccessSpecDTO & {
  username?: string;
  usernameRef?: string;
  tokenRef: string;
};

export type CEAwsConnector = ConnectorConfigDTO & {
  crossAccountAccess: CrossAccountAccess;
  curAttributes?: AwsCurAttributes;
  featuresEnabled?: ("CUR" | "EVENTS" | "OPTIMIZATION")[];
};

export type CEAzureConnector = ConnectorConfigDTO & {
  featuresEnabled?: ("BILLING" | "OPTIMIZATION")[];
  tenantId: string;
  subscriptionId: string;
  billingExportSpec?: BillingExportSpec;
};

export type CEKubernetesClusterConfig = ConnectorConfigDTO & {
  connectorRef: string;
};

export interface ConnectorActivityDetails {
  lastActivityTime?: number;
}

export interface ConnectorConfigDTO {
  [key: string]: any;
}

export interface ConnectorConnectivityDetails {
  status?: "SUCCESS" | "FAILURE" | "PARTIAL";
  errorSummary?: string;
  errors?: ErrorDetail[];
  testedAt?: number;
  lastTestedAt?: number;
  lastConnectedAt?: number;
}

export interface ConnectorInfoDTO {
  name: string;
  identifier: string;
  description?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  tags?: {
    [key: string]: string;
  };
  type:
    | "K8sCluster"
    | "Git"
    | "Splunk"
    | "AppDynamics"
    | "Vault"
    | "DockerRegistry"
    | "Local"
    | "AwsKms"
    | "GcpKms"
    | "Gcp"
    | "Aws"
    | "Artifactory"
    | "Jira"
    | "Nexus"
    | "Github"
    | "Gitlab"
    | "Bitbucket"
    | "Codecommit"
    | "CEAws"
    | "CEAzure"
    | "GcpCloudCost"
    | "CEK8sCluster"
    | "HttpHelmRepo"
    | "NewRelic";
  spec: ConnectorConfigDTO;
}

export interface ConnectorResponse {
  connector?: ConnectorInfoDTO;
  createdAt?: number;
  lastModifiedAt?: number;
  status?: ConnectorConnectivityDetails;
  activityDetails?: ConnectorActivityDetails;
  harnessManaged?: boolean;
  gitDetails?: EntityGitDetails;
}

export interface CrossAccountAccess {
  crossAccountRoleArn: string;
  externalId?: string;
}

export interface CustomCommitAttributes {
  authorName?: string;
  authorEmail?: string;
  commitMessage?: string;
}

export interface DockerAuthCredentialsDTO {
  [key: string]: any;
}

export interface DockerAuthenticationDTO {
  type: "UsernamePassword" | "Anonymous";
  spec?: DockerAuthCredentialsDTO;
}

export type DockerConnectorDTO = ConnectorConfigDTO & {
  dockerRegistryUrl: string;
  providerType: "DockerHub" | "Harbor" | "Quay" | "Other";
  auth?: DockerAuthenticationDTO;
  delegateSelectors?: string[];
};

export type DockerUserNamePasswordDTO = DockerAuthCredentialsDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export interface EntityGitDetails {
  objectId?: string;
  branch?: string;
  repoIdentifier?: string;
}

export interface ErrorDetail {
  reason?: string;
  message?: string;
  code?: number;
}

export interface GcpBillingExportSpec {
  projectId: string;
  datasetId: string;
}

export type GcpCloudCostConnector = ConnectorConfigDTO & {
  featuresEnabled?: "BILLING"[];
  billingExportSpec?: GcpBillingExportSpec;
};

export type GcpConnector = ConnectorConfigDTO & {
  credential?: GcpConnectorCredential;
  delegateSelectors?: string[];
};

export interface GcpConnectorCredential {
  type: "InheritFromDelegate" | "ManualConfig";
  spec?: GcpCredentialSpec;
}

export interface GcpCredentialSpec {
  [key: string]: any;
}

export type GcpKmsConnectorDTO = ConnectorConfigDTO & {
  projectId?: string;
  region?: string;
  keyRing?: string;
  keyName?: string;
  credentials?: string[];
  default?: boolean;
};

export type GcpManualDetails = GcpCredentialSpec & {
  secretKeyRef: string;
};

export interface GitAuthenticationDTO {
  [key: string]: any;
}

export type GitConfigDTO = ConnectorConfigDTO & {
  url: string;
  branchName?: string;
  delegateSelectors?: string[];
  type: "Http" | "Ssh";
  connectionType: "Account" | "Repo";
  spec: GitAuthenticationDTO;
  gitSync?: GitSyncConfig;
};

export type GitHTTPAuthenticationDTO = GitAuthenticationDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type GitSSHAuthenticationDTO = GitAuthenticationDTO & {
  sshKeyRef: string;
};

export interface GitSyncConfig {
  identifier?: string;
  name?: string;
  projectIdentifier?: string;
  orgIdentifier?: string;
  gitConnectorRef?: string;
  repo?: string;
  branch?: string;
  gitConnectorType: "Github" | "Gitlab" | "Bitbucket";
  gitSyncFolderConfigDTOs?: GitSyncFolderConfigDTO[];
}

export interface GithubApiAccess {
  type: "GithubApp" | "Token";
  spec?: GithubApiAccessSpecDTO;
}

export interface GithubApiAccessSpecDTO {
  [key: string]: any;
}

export type GithubAppSpec = GithubApiAccessSpecDTO & {
  installationId: string;
  applicationId: string;
  privateKeyRef: string;
};

export interface GithubAuthentication {
  type: "Http" | "Ssh";
  spec: GithubCredentialsDTO;
}

export type GithubConnector = ConnectorConfigDTO & {
  url: string;
  authentication: GithubAuthentication;
  apiAccess?: GithubApiAccess;
  delegateSelectors?: string[];
  type: "Account" | "Repo";
};

export interface GithubCredentialsDTO {
  [key: string]: any;
}

export type GithubHttpCredentials = GithubCredentialsDTO & {
  type: "UsernamePassword" | "UsernameToken";
  spec: GithubHttpCredentialsSpecDTO;
};

export interface GithubHttpCredentialsSpecDTO {
  [key: string]: any;
}

export type GithubSshCredentials = GithubCredentialsDTO & {
  sshKeyRef: string;
};

export type GithubTokenSpec = GithubApiAccessSpecDTO & {
  tokenRef: string;
};

export type GithubUsernamePassword = GithubHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type GithubUsernameToken = GithubHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  tokenRef: string;
};

export interface GitlabApiAccess {
  type: "Token";
  spec?: GitlabApiAccessSpecDTO;
}

export interface GitlabApiAccessSpecDTO {
  [key: string]: any;
}

export interface GitlabAuthentication {
  type: "Http" | "Ssh";
  spec: GitlabCredentialsDTO;
}

export type GitlabConnector = ConnectorConfigDTO & {
  url: string;
  authentication: GitlabAuthentication;
  apiAccess?: GitlabApiAccess;
  delegateSelectors?: string[];
  type: "Account" | "Repo";
};

export interface GitlabCredentialsDTO {
  [key: string]: any;
}

export type GitlabHttpCredentials = GitlabCredentialsDTO & {
  type: "UsernamePassword" | "UsernameToken" | "Kerberos";
  spec: GitlabHttpCredentialsSpecDTO;
};

export interface GitlabHttpCredentialsSpecDTO {
  [key: string]: any;
}

export type GitlabKerberos = GitlabHttpCredentialsSpecDTO & {
  kerberosKeyRef: string;
};

export type GitlabSshCredentials = GitlabCredentialsDTO & {
  sshKeyRef: string;
};

export type GitlabTokenSpec = GitlabApiAccessSpecDTO & {
  tokenRef: string;
};

export type GitlabUsernamePassword = GitlabHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type GitlabUsernameToken = GitlabHttpCredentialsSpecDTO & {
  username?: string;
  usernameRef?: string;
  tokenRef: string;
};

export interface HttpHelmAuthCredentialsDTO {
  [key: string]: any;
}

export interface HttpHelmAuthenticationDTO {
  type: "UsernamePassword" | "Anonymous";
  spec?: HttpHelmAuthCredentialsDTO;
}

export type HttpHelmConnectorDTO = ConnectorConfigDTO & {
  helmRepoUrl: string;
  auth?: HttpHelmAuthenticationDTO;
  delegateSelectors?: string[];
};

export type HttpHelmUsernamePasswordDTO = HttpHelmAuthCredentialsDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type JiraConnector = ConnectorConfigDTO & {
  jiraUrl: string;
  username?: string;
  passwordRef: string;
  delegateSelectors?: string[];
};

export interface KubernetesAuthCredentialDTO {
  [key: string]: any;
}

export interface KubernetesAuthDTO {
  type:
    | "UsernamePassword"
    | "ClientKeyCert"
    | "ServiceAccount"
    | "OpenIdConnect";
  spec: KubernetesAuthCredentialDTO;
}

export type KubernetesClientKeyCertDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string;
  clientCertRef: string;
  clientKeyRef: string;
  clientKeyPassphraseRef: string;
  clientKeyAlgo?: string;
};

export type KubernetesClusterConfigDTO = ConnectorConfigDTO & {
  credential: KubernetesCredentialDTO;
  delegateSelectors?: string[];
};

export type KubernetesClusterDetailsDTO = KubernetesCredentialSpecDTO & {
  masterUrl: string;
  auth: KubernetesAuthDTO;
};

export interface KubernetesCredentialDTO {
  type: "InheritFromDelegate" | "ManualConfig";
  spec?: KubernetesCredentialSpecDTO;
}

export interface KubernetesCredentialSpecDTO {
  [key: string]: any;
}

export type KubernetesOpenIdConnectDTO = KubernetesAuthCredentialDTO & {
  oidcIssuerUrl?: string;
  oidcUsername?: string;
  oidcUsernameRef?: string;
  oidcClientIdRef: string;
  oidcPasswordRef: string;
  oidcSecretRef?: string;
  oidcScopes?: string;
};

export type KubernetesServiceAccountDTO = KubernetesAuthCredentialDTO & {
  serviceAccountTokenRef: string;
};

export type KubernetesUserNamePasswordDTO = KubernetesAuthCredentialDTO & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export type LocalConnectorDTO = ConnectorConfigDTO & {
  default?: boolean;
};

export type NewRelicConnectorDTO = ConnectorConfigDTO & {
  newRelicAccountId: string;
  url: string;
  apiKeyRef: string;
  delegateSelectors?: string[];
};

export interface NexusAuthCredentials {
  [key: string]: any;
}

export interface NexusAuthentication {
  type: "UsernamePassword" | "Anonymous";
  spec?: NexusAuthCredentials;
}

export type NexusConnector = ConnectorConfigDTO & {
  nexusServerUrl: string;
  version: string;
  auth?: NexusAuthentication;
  delegateSelectors?: string[];
};

export type NexusUsernamePasswordAuth = NexusAuthCredentials & {
  username?: string;
  usernameRef?: string;
  passwordRef: string;
};

export interface ResponseConnectorResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type SplunkConnectorDTO = ConnectorConfigDTO & {
  splunkUrl?: string;
  username?: string;
  accountId: string;
  delegateSelectors?: string[];
  passwordRef: string;
};

export type VaultConnectorDTO = ConnectorConfigDTO & {
  authToken?: string;
  basePath?: string;
  vaultUrl?: string;
  renewalIntervalMinutes?: number;
  secretEngineManuallyConfigured?: boolean;
  secretEngineName?: string;
  appRoleId?: string;
  secretId?: string;
  secretEngineVersion?: number;
  default?: boolean;
  readOnly?: boolean;
  accessType?: "APP_ROLE" | "TOKEN";
};

export interface Connector {
  connector?: ConnectorInfoDTO;
}

export interface ResponseBoolean {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: boolean;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Page {
  totalElements?: number;
  totalPages?: number;
  size?: number;
  content?: { [key: string]: any }[];
  number?: number;
  first?: boolean;
  sort?: Sort;
  last?: boolean;
  numberOfElements?: number;
  pageable?: Pageable;
  empty?: boolean;
}

export interface PageConnectorResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ConnectorResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageConnectorResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageConnectorResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type ConnectorFilterProperties = FilterProperties & {
  connectorNames?: string[];
  connectorIdentifiers?: string[];
  description?: string;
  types?: (
    | "K8sCluster"
    | "Git"
    | "Splunk"
    | "AppDynamics"
    | "Vault"
    | "DockerRegistry"
    | "Local"
    | "AwsKms"
    | "GcpKms"
    | "Gcp"
    | "Aws"
    | "Artifactory"
    | "Jira"
    | "Nexus"
    | "Github"
    | "Gitlab"
    | "Bitbucket"
    | "Codecommit"
    | "CEAws"
    | "CEAzure"
    | "GcpCloudCost"
    | "CEK8sCluster"
    | "HttpHelmRepo"
    | "NewRelic"
  )[];
  categories?: (
    | "CLOUD_PROVIDER"
    | "SECRET_MANAGER"
    | "CLOUD_COST"
    | "ARTIFACTORY"
    | "CODE_REPO"
    | "MONITORING"
    | "TICKETING"
  )[];
  connectivityStatuses?: ("SUCCESS" | "FAILURE" | "PARTIAL")[];
  inheritingCredentialsFromDelegate?: boolean;
};

export interface ConnectorValidationResult {
  status?: "SUCCESS" | "FAILURE" | "PARTIAL";
  errors?: ErrorDetail[];
  errorSummary?: string;
  testedAt?: number;
  delegateId?: string;
}

export interface ResponseConnectorValidationResult {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorValidationResult;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ConnectorStatistics {
  typeStats?: ConnectorTypeStatistics[];
  statusStats?: ConnectorStatusStatistics[];
}

export interface ConnectorStatusStatistics {
  status?: "SUCCESS" | "FAILURE" | "PARTIAL";
  count?: number;
}

export interface ConnectorTypeStatistics {
  type?:
    | "K8sCluster"
    | "Git"
    | "Splunk"
    | "AppDynamics"
    | "Vault"
    | "DockerRegistry"
    | "Local"
    | "AwsKms"
    | "GcpKms"
    | "Gcp"
    | "Aws"
    | "Artifactory"
    | "Jira"
    | "Nexus"
    | "Github"
    | "Gitlab"
    | "Bitbucket"
    | "Codecommit"
    | "CEAws"
    | "CEAzure"
    | "GcpCloudCost"
    | "CEK8sCluster"
    | "HttpHelmRepo"
    | "NewRelic";
  count?: number;
}

export interface ResponseConnectorStatistics {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorStatistics;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListConnectorResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorResponse[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ConnectorCatalogueItem {
  category?:
    | "CLOUD_PROVIDER"
    | "SECRET_MANAGER"
    | "CLOUD_COST"
    | "ARTIFACTORY"
    | "CODE_REPO"
    | "MONITORING"
    | "TICKETING";
  connectors?: (
    | "K8sCluster"
    | "Git"
    | "Splunk"
    | "AppDynamics"
    | "Vault"
    | "DockerRegistry"
    | "Local"
    | "AwsKms"
    | "GcpKms"
    | "Gcp"
    | "Aws"
    | "Artifactory"
    | "Jira"
    | "Nexus"
    | "Github"
    | "Gitlab"
    | "Bitbucket"
    | "Codecommit"
    | "CEAws"
    | "CEAzure"
    | "GcpCloudCost"
    | "CEK8sCluster"
    | "HttpHelmRepo"
    | "NewRelic"
  )[];
}

export interface ConnectorCatalogueResponse {
  catalogue?: ConnectorCatalogueItem[];
}

export interface ResponseConnectorCatalogueResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectorCatalogueResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type AuditFilterProperties = FilterProperties & {
  scopes?: ResourceScopeDTO[];
  resources?: ResourceDTO[];
  modules?: ("CD" | "CI" | "CORE" | "CV" | "CF" | "CE")[];
  actions?: (
    | "CREATE"
    | "UPDATE"
    | "RESTORE"
    | "DELETE"
    | "INVITE"
    | "RESEND_INVITE"
    | "REVOKE_INVITE"
    | "ADD_COLLABORATOR"
    | "REMOVE_COLLABORATOR"
    | "ADD_MEMBERSHIP"
    | "REMOVE_MEMBERSHIP"
  )[];
  environments?: Environment[];
  principals?: Principal[];
  startTime?: number;
  endTime?: number;
};

export interface Environment {
  type: "PreProduction" | "Production";
  identifier: string;
}

export interface FilterDTO {
  name: string;
  identifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  filterProperties: FilterProperties;
  filterVisibility?: "EveryOne" | "OnlyCreator";
}

export interface FilterProperties {
  tags?: {
    [key: string]: string;
  };
  filterType?:
    | "Connector"
    | "PipelineSetup"
    | "PipelineExecution"
    | "Deployment"
    | "Audit";
}

export interface NGTag {
  key: string;
  value: string;
}

export type PipelineFilterProperties = FilterProperties & {
  pipelineTags?: NGTag[];
  pipelineIdentifiers?: string[];
  name?: string;
  description?: string;
  moduleProperties?: {
    [key: string]: { [key: string]: any };
  };
};

export interface Principal {
  identifier: string;
  type: "USER" | "USER_GROUP" | "API_KEY" | "SERVICE";
}

export interface ResourceDTO {
  type: string;
  identifier: string;
  labels?: {
    [key: string]: string;
  };
}

export interface ResourceScopeDTO {
  accountIdentifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  labels?: {
    [key: string]: string;
  };
}

export interface ResponseFilterDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: FilterDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageFilterDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: FilterDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageFilterDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageFilterDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListString {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: string[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitBranchDTO {
  branchName?: string;
  branchSyncStatus?: "SYNCED" | "SYNCING" | "UNSYNCED";
}

export interface PageGitBranchDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: GitBranchDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageGitBranchDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageGitBranchDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitSyncEntityDTO {
  entityName?: string;
  entityType?:
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "Triggers";
  entityIdentifier?: string;
  gitConnectorId?: string;
  repositoryName?: string;
  branch?: string;
  folderPath?: string;
  entityGitPath?: string;
  repoProviderType?: "github" | "gitlab" | "bitbucket" | "unknown";
  accountId?: string;
}

export interface GitSyncEntityListDTO {
  entityType?:
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "Triggers";
  count?: number;
  gitSyncEntities?: GitSyncEntityDTO[];
}

export interface GitSyncRepoFiles {
  gitSyncConfigIdentifier?: string;
  gitSyncEntityLists?: GitSyncEntityListDTO[];
}

export interface GitSyncRepoFilesList {
  moduleType?: "CD" | "CI" | "CORE" | "CV" | "CF" | "CE";
  gitSyncRepoFilesList?: GitSyncRepoFiles[];
}

export interface ResponseGitSyncRepoFilesList {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GitSyncRepoFilesList;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitEntityFilterProperties {
  moduleType?: "CD" | "CI" | "CORE" | "CV" | "CF" | "CE";
  gitSyncConfigIdentifiers?: string[];
  entityTypes?: (
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "Triggers"
  )[];
  searchTerm?: string;
}

export interface ResponseListGitSyncEntityListDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GitSyncEntityListDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitEntityBranchFilterSummaryProperties {
  moduleType?: "CD" | "CI" | "CORE" | "CV" | "CF" | "CE";
  entityTypes?: (
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "Triggers"
  )[];
  searchTerm?: string;
}

export interface PageGitSyncEntityListDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: GitSyncEntityListDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageGitSyncEntityListDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageGitSyncEntityListDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GitSyncFolderConfigDTO {
  rootFolder?: string;
  isDefault?: boolean;
  identifier?: string;
  enabled?: boolean;
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: { [key: string]: any };
  responseMessages?: ResponseMessage[];
}

export type CDModuleLicenseDTO = ModuleLicenseDTO & {
  deploymentUnits?: {
    [key: string]: number;
  };
};

export type CEModuleLicenseDTO = ModuleLicenseDTO & {};

export type CFModuleLicenseDTO = ModuleLicenseDTO & {};

export type CIModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfCommitters?: number;
};

export type CVModuleLicenseDTO = ModuleLicenseDTO & {};

export interface ModuleLicenseDTO {
  id?: string;
  accountIdentifier?: string;
  moduleType?: "CD" | "CI" | "CV" | "CE" | "CF";
  edition?: "FREE" | "TEAM" | "ENTERPRISE";
  licenseType?: "TRIAL" | "PAID";
  startTime?: number;
  expiryTime?: number;
  status?: "ACTIVE" | "DELETED" | "EXPIRED";
  createdAt?: number;
  lastModifiedAt?: number;
}

export interface ResponseModuleLicenseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ModuleLicenseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface AccountLicensesDTO {
  accountId?: string;
  moduleLicenses?: {
    [key: string]: ModuleLicenseDTO;
  };
}

export interface ResponseAccountLicensesDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: AccountLicensesDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface StartTrialRequestDTO {
  moduleType: "CD" | "CI" | "CV" | "CE" | "CF";
}

export interface RestResponseVersionPackage {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: VersionPackage;
  responseMessages?: ResponseMessage[];
}

export interface RuntimeInfo {
  primary?: boolean;
  primaryVersion?: string;
  deployMode?: string;
}

export interface VersionInfo {
  version?: string;
  buildNo?: string;
  gitCommit?: string;
  gitBranch?: string;
  timestamp?: string;
}

export interface VersionPackage {
  versionInfo?: VersionInfo;
  runtimeInfo?: RuntimeInfo;
}

export interface PageRoleAssignmentResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: RoleAssignmentResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageRoleAssignmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageRoleAssignmentResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RoleAssignment {
  identifier?: string;
  resourceGroupIdentifier: string;
  roleIdentifier: string;
  principal: Principal;
  disabled?: boolean;
}

export interface RoleAssignmentResponse {
  roleAssignment: RoleAssignment;
  scope: ScopeDTO;
  createdAt?: number;
  lastModifiedAt?: number;
  harnessManaged?: boolean;
}

export interface ScopeDTO {
  accountIdentifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
}

export interface RoleAssignmentFilter {
  resourceGroupFilter?: string[];
  roleFilter?: string[];
  principalTypeFilter?: ("USER" | "USER_GROUP" | "API_KEY" | "SERVICE")[];
  principalFilter?: Principal[];
  harnessManagedFilter?: boolean[];
  disabledFilter?: boolean[];
}

export interface ResponseRoleAssignmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: RoleAssignmentResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListRoleAssignmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: RoleAssignmentResponse[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface BatchRoleAssignmentCreateRequest {
  roleAssignments?: RoleAssignment[];
}

export interface AccountEvent {
  accountEventType?:
    | "APP_CREATED"
    | "SERVICE_CREATED"
    | "ENV_CREATED"
    | "WORKFLOW_CREATED"
    | "WORKFLOW_DEPLOYED"
    | "PIPELINE_DEPLOYED"
    | "DELEGATE_INSTALLED"
    | "CLOUD_PROVIDER_CREATED"
    | "ARTIFACT_REPO_CREATED"
    | "PIPELINE_CREATED"
    | "ARTIFACT_STREAM_ADDED"
    | "INFRA_MAPPING_ADDED"
    | "INFRA_DEFINITION_ADDED"
    | "CUSTOM";
  customMsg?: string;
  category?: string;
  properties?: {
    [key: string]: string;
  };
}

export interface AccountPermissions {
  permissions?: (
    | "ACCOUNT"
    | "LOGGED_IN"
    | "DELEGATE"
    | "NONE"
    | "APP"
    | "ALL_APP_ENTITIES"
    | "ENV"
    | "SERVICE"
    | "WORKFLOW"
    | "PIPELINE"
    | "DEPLOYMENT"
    | "APPLICATION_CREATE_DELETE"
    | "USER_PERMISSION_MANAGEMENT"
    | "ACCOUNT_MANAGEMENT"
    | "PROVISIONER"
    | "TEMPLATE_MANAGEMENT"
    | "USER_PERMISSION_READ"
    | "AUDIT_VIEWER"
    | "TAG_MANAGEMENT"
    | "CE_ADMIN"
    | "CE_VIEWER"
    | "MANAGE_CLOUD_PROVIDERS"
    | "MANAGE_CONNECTORS"
    | "MANAGE_APPLICATIONS"
    | "MANAGE_APPLICATION_STACKS"
    | "MANAGE_DELEGATES"
    | "MANAGE_ALERT_NOTIFICATION_RULES"
    | "MANAGE_DELEGATE_PROFILES"
    | "MANAGE_CONFIG_AS_CODE"
    | "MANAGE_SECRETS"
    | "MANAGE_SECRET_MANAGERS"
    | "MANAGE_SSH_AND_WINRM"
    | "MANAGE_AUTHENTICATION_SETTINGS"
    | "MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS"
    | "VIEW_USER_AND_USER_GROUPS_AND_API_KEYS"
    | "MANAGE_IP_WHITELIST"
    | "MANAGE_IP_WHITELISTING"
    | "MANAGE_DEPLOYMENT_FREEZES"
    | "MANAGE_PIPELINE_GOVERNANCE_STANDARDS"
    | "MANAGE_API_KEYS"
    | "MANAGE_TAGS"
    | "MANAGE_CUSTOM_DASHBOARDS"
    | "CREATE_CUSTOM_DASHBOARDS"
  )[];
}

export interface AccountPreferences {
  delegateSecretsCacheTTLInHours?: number;
}

export interface AppPermission {
  permissionType?:
    | "ACCOUNT"
    | "LOGGED_IN"
    | "DELEGATE"
    | "NONE"
    | "APP"
    | "ALL_APP_ENTITIES"
    | "ENV"
    | "SERVICE"
    | "WORKFLOW"
    | "PIPELINE"
    | "DEPLOYMENT"
    | "APPLICATION_CREATE_DELETE"
    | "USER_PERMISSION_MANAGEMENT"
    | "ACCOUNT_MANAGEMENT"
    | "PROVISIONER"
    | "TEMPLATE_MANAGEMENT"
    | "USER_PERMISSION_READ"
    | "AUDIT_VIEWER"
    | "TAG_MANAGEMENT"
    | "CE_ADMIN"
    | "CE_VIEWER"
    | "MANAGE_CLOUD_PROVIDERS"
    | "MANAGE_CONNECTORS"
    | "MANAGE_APPLICATIONS"
    | "MANAGE_APPLICATION_STACKS"
    | "MANAGE_DELEGATES"
    | "MANAGE_ALERT_NOTIFICATION_RULES"
    | "MANAGE_DELEGATE_PROFILES"
    | "MANAGE_CONFIG_AS_CODE"
    | "MANAGE_SECRETS"
    | "MANAGE_SECRET_MANAGERS"
    | "MANAGE_SSH_AND_WINRM"
    | "MANAGE_AUTHENTICATION_SETTINGS"
    | "MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS"
    | "VIEW_USER_AND_USER_GROUPS_AND_API_KEYS"
    | "MANAGE_IP_WHITELIST"
    | "MANAGE_IP_WHITELISTING"
    | "MANAGE_DEPLOYMENT_FREEZES"
    | "MANAGE_PIPELINE_GOVERNANCE_STANDARDS"
    | "MANAGE_API_KEYS"
    | "MANAGE_TAGS"
    | "MANAGE_CUSTOM_DASHBOARDS"
    | "CREATE_CUSTOM_DASHBOARDS";
  appFilter?: GenericEntityFilter;
  entityFilter?: Filter;
  actions?: (
    | "ALL"
    | "CREATE"
    | "READ"
    | "UPDATE"
    | "DELETE"
    | "EXECUTE"
    | "EXECUTE_WORKFLOW"
    | "EXECUTE_PIPELINE"
    | "EXECUTE_WORKFLOW_ROLLBACK"
    | "DEFAULT"
  )[];
}

export interface AuthenticationSettingsResponse {
  ngAuthSettings?: NGAuthSettings[];
  whitelistedDomains?: string[];
  authenticationMechanism?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
  twoFactorEnabled?: boolean;
}

export interface CeLicenseInfo {
  licenseType?: "FULL_TRIAL" | "LIMITED_TRIAL" | "PAID";
  expiryTime?: number;
}

export interface DelegateConfiguration {
  delegateVersions?: string[];
}

export interface EmbeddedUser {
  uuid?: string;
  name?: string;
  email?: string;
}

export type EnvFilter = Filter & {
  filterTypes?: string[];
};

export interface Filter {
  ids?: string[];
}

export type GenericEntityFilter = Filter & {
  filterType?: string;
};

export type LDAPSettings = NGAuthSettings & {
  connectionSettings: LdapConnectionSettings;
  userSettingsList?: LdapUserSettings[];
  groupSettingsList?: LdapGroupSettings[];
};

export interface LdapConnectionSettings {
  host: string;
  port?: number;
  sslEnabled?: boolean;
  referralsEnabled?: boolean;
  maxReferralHops?: number;
  bindDN?: string;
  bindPassword?: string;
  connectTimeout?: number;
  responseTimeout?: number;
}

export interface LdapGroupSettings {
  baseDN?: string;
  searchFilter?: string;
  nameAttr?: string;
  descriptionAttr?: string;
  userMembershipAttr?: string;
  referencedUserAttr?: string;
}

export interface LdapUserSettings {
  baseDN?: string;
  searchFilter?: string;
  emailAttr?: string;
  displayNameAttr?: string;
  groupMembershipAttr?: string;
}

export interface LicenseInfo {
  accountType?: string;
  accountStatus?: string;
  expiryTime?: number;
  licenseUnits?: number;
}

export interface LoginSettings {
  uuid: string;
  accountId: string;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt?: number;
  userLockoutPolicy: UserLockoutPolicy;
  passwordExpirationPolicy: PasswordExpirationPolicy;
  passwordStrengthPolicy: PasswordStrengthPolicy;
}

export interface NGAuthSettings {
  settingsType?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
}

export interface NotificationSettings {
  useIndividualEmails?: boolean;
  sendMailToNewMembers?: boolean;
  emailAddresses: string[];
  slackConfig: SlackNotificationSetting;
  pagerDutyIntegrationKey?: string;
  microsoftTeamsWebhookUrl?: string;
}

export interface OAuthSettings {
  filter?: string;
  allowedProviders?: (
    | "AZURE"
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "GOOGLE"
    | "LINKEDIN"
  )[];
  settingsType?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
}

export interface PasswordExpirationPolicy {
  enabled?: boolean;
  daysBeforePasswordExpires?: number;
  daysBeforeUserNotifiedOfPasswordExpiration?: number;
}

export interface PasswordStrengthPolicy {
  enabled?: boolean;
  minNumberOfCharacters?: number;
  minNumberOfUppercaseCharacters?: number;
  minNumberOfLowercaseCharacters?: number;
  minNumberOfSpecialCharacters?: number;
  minNumberOfDigits?: number;
}

export interface RestResponseAuthenticationSettingsResponse {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: AuthenticationSettingsResponse;
  responseMessages?: ResponseMessage[];
}

export type SAMLSettings = NGAuthSettings & {
  origin: string;
  logoutUrl?: string;
  groupMembershipAttr?: string;
  displayName?: string;
  authorizationEnabled?: boolean;
};

export interface SlackNotificationSetting {
  name?: string;
  outgoingWebhookUrl: string;
}

export interface TechStack {
  category?: string;
  technology?: string;
}

export interface TrialSignupOptions {
  productsSelected?: ("CD" | "CE" | "CI")[];
  assistedOption?: boolean;
}

export interface UserGroup {
  uuid: string;
  appId: string;
  createdBy?: EmbeddedUser;
  createdAt?: number;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt: number;
  name?: string;
  description?: string;
  linkedSsoType?: "SAML" | "LDAP" | "OAUTH";
  linkedSsoId?: string;
  linkedSsoDisplayName?: string;
  ssoGroupId?: string;
  ssoGroupName?: string;
  importedByScim?: boolean;
  accountId?: string;
  memberIds?: string[];
  members?: User[];
  appPermissions?: AppPermission[];
  accountPermissions?: AccountPermissions;
  notificationSettings?: NotificationSettings;
  default?: boolean;
  ssoLinked?: boolean;
}

export interface UserLockoutInfo {
  numberOfFailedLoginAttempts?: number;
  userLockedAt?: number;
}

export interface UserLockoutPolicy {
  enableLockoutPolicy?: boolean;
  numberOfFailedAttemptsBeforeLockout?: number;
  lockOutPeriod?: number;
  notifyUser?: boolean;
  userGroupsToNotify?: UserGroup[];
}

export type UsernamePasswordSettings = NGAuthSettings & {
  loginSettings: LoginSettings;
};

export interface UtmInfo {
  utmSource?: string;
  utmContent?: string;
  utmMedium?: string;
  utmTerm?: string;
  utmCampaign?: string;
}

export type WorkflowFilter = Filter & {
  filterTypes?: string[];
};

export interface RestResponseBoolean {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: boolean;
  responseMessages?: ResponseMessage[];
}

export interface RestResponseLoginSettings {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: LoginSettings;
  responseMessages?: ResponseMessage[];
}

export interface TwoFactorAdminOverrideSettings {
  adminOverrideTwoFactorEnabled?: boolean;
}

export interface RestResponsePasswordStrengthPolicy {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: PasswordStrengthPolicy;
  responseMessages?: ResponseMessage[];
}

export type LdapSettings = SSOSettings & {
  connectionSettings: LdapConnectionSettings;
  userSettings?: LdapUserSettings;
  groupSettings?: LdapGroupSettings;
  userSettingsList?: LdapUserSettings[];
  groupSettingsList?: LdapGroupSettings[];
};

export type OauthSettings = SSOSettings & {
  filter?: string;
  allowedProviders?: (
    | "AZURE"
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "GOOGLE"
    | "LINKEDIN"
  )[];
};

export interface RestResponseSSOConfig {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: SSOConfig;
  responseMessages?: ResponseMessage[];
}

export interface SSOConfig {
  accountId?: string;
  ssoSettings?: SSOSettings[];
  authenticationMechanism?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
}

export interface SSOSettings {
  uuid: string;
  appId: string;
  createdBy?: EmbeddedUser;
  createdAt?: number;
  lastUpdatedBy?: EmbeddedUser;
  lastUpdatedAt: number;
  type: "SAML" | "LDAP" | "OAUTH";
  displayName?: string;
  url?: string;
  accountId?: string;
}

export type SamlSettings = SSOSettings & {
  accountId: string;
  origin: string;
  logoutUrl?: string;
  groupMembershipAttr?: string;
  authorizationEnabled?: boolean;
};

export interface LoginTypeResponse {
  authenticationMechanism?: "USER_PASSWORD" | "SAML" | "LDAP" | "OAUTH";
  showCaptcha?: boolean;
  defaultExperience?: "NG" | "CG";
  oauthEnabled?: boolean;
  ssorequest?: SSORequest;
}

export interface RestResponseLoginTypeResponse {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: LoginTypeResponse;
  responseMessages?: ResponseMessage[];
}

export interface SSORequest {
  oauthProviderType?:
    | "AZURE"
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "GOOGLE"
    | "LINKEDIN";
  idpRedirectUrl?: string;
  oauthProviderTypes?: (
    | "AZURE"
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "GOOGLE"
    | "LINKEDIN"
  )[];
}

export interface Deployment {
  count?: number;
}

export interface DeploymentDateAndCount {
  time?: string;
  deployments?: Deployment;
}

export interface DeploymentInfo {
  count?: number;
  rate?: number;
  countList?: DeploymentDateAndCount[];
}

export interface HealthDeploymentDashboard {
  healthDeploymentInfo?: HealthDeploymentInfo;
}

export interface HealthDeploymentInfo {
  total?: TotalDeploymentInfo;
  success?: DeploymentInfo;
  failure?: DeploymentInfo;
}

export interface ResponseHealthDeploymentDashboard {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: HealthDeploymentDashboard;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface TotalDeploymentInfo {
  count?: number;
  production?: number;
  nonProduction?: number;
  countList?: DeploymentDateAndCount[];
}

export interface Activity {
  accountIdentifier?: string;
  referredEntity?: EntityDetail;
  type:
    | "CONNECTIVITY_CHECK"
    | "ENTITY_USAGE"
    | "ENTITY_CREATION"
    | "ENTITY_UPDATE";
  activityStatus: "SUCCESS" | "FAILED";
  detail?: ActivityDetail;
  activityTime: number;
  description?: string;
}

export interface ActivityDetail {
  [key: string]: any;
}

export interface EntityDetail {
  type?:
    | "Projects"
    | "Pipelines"
    | "PipelineSteps"
    | "Connectors"
    | "Secrets"
    | "Service"
    | "Environment"
    | "InputSets"
    | "CvConfig"
    | "Delegates"
    | "DelegateConfigurations"
    | "CvVerificationJob"
    | "IntegrationStage"
    | "IntegrationSteps"
    | "CvKubernetesActivitySource"
    | "DeploymentSteps"
    | "DeploymentStage"
    | "ApprovalStage"
    | "Triggers";
  entityRef?: EntityReference;
  name?: string;
}

export interface EntityReference {
  identifier?: string;
  accountIdentifier?: string;
  projectIdentifier?: string;
  orgIdentifier?: string;
}

export type IdentifierRef = EntityReference & {
  scope?: "account" | "org" | "project" | "unknown";
  metadata?: {
    [key: string]: string;
  };
};

export type InputSetReference = EntityReference & {
  pipelineIdentifier?: string;
};

export interface PageActivity {
  totalElements?: number;
  totalPages?: number;
  size?: number;
  content?: Activity[];
  number?: number;
  first?: boolean;
  sort?: Sort;
  last?: boolean;
  numberOfElements?: number;
  pageable?: Pageable;
  empty?: boolean;
}

export interface Pageable {
  pageSize?: number;
  offset?: number;
  sort?: Sort;
  paged?: boolean;
  pageNumber?: number;
  unpaged?: boolean;
}

export interface ResponsePageActivity {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageActivity;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Sort {
  unsorted?: boolean;
  sorted?: boolean;
  empty?: boolean;
}

export interface ResponseActivity {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: Activity;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ConnectivityCheckSummary {
  successCount?: number;
  failureCount?: number;
  startTime?: number;
  endTime?: number;
}

export interface ResponseConnectivityCheckSummary {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ConnectivityCheckSummary;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ActivitySummary {
  get_id?: number;
  startTime?: number;
  endTime?: number;
  heartBeatFailuresCount?: number;
  successfulActivitiesCount?: number;
  failedActivitiesCount?: number;
}

export interface PageActivitySummary {
  totalElements?: number;
  totalPages?: number;
  size?: number;
  content?: ActivitySummary[];
  number?: number;
  first?: boolean;
  sort?: Sort;
  last?: boolean;
  numberOfElements?: number;
  pageable?: Pageable;
  empty?: boolean;
}

export interface ResponsePageActivitySummary {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageActivitySummary;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface DockerBuildDetailsDTO {
  tag?: string;
  buildUrl?: string;
  metadata?: {
    [key: string]: string;
  };
  labels?: {
    [key: string]: string;
  };
  imagePath?: string;
}

export interface DockerResponseDTO {
  buildDetailsList?: DockerBuildDetailsDTO[];
}

export interface ResponseDockerResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: DockerResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface DockerRequestDTO {
  tag?: string;
  tagRegex?: string;
  tagsList?: string[];
}

export interface ResponseDockerBuildDetailsDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: DockerBuildDetailsDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EcrBuildDetailsDTO {
  tag?: string;
  buildUrl?: string;
  metadata?: {
    [key: string]: string;
  };
  labels?: {
    [key: string]: string;
  };
  imagePath?: string;
}

export interface EcrResponseDTO {
  buildDetailsList?: EcrBuildDetailsDTO[];
}

export interface ResponseEcrResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EcrResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseEcrBuildDetailsDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EcrBuildDetailsDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EcrRequestDTO {
  tag?: string;
  tagRegex?: string;
  tagsList?: string[];
  region?: string;
}

export interface GcrBuildDetailsDTO {
  tag?: string;
  buildUrl?: string;
  metadata?: {
    [key: string]: string;
  };
  labels?: {
    [key: string]: string;
  };
  imagePath?: string;
}

export interface GcrResponseDTO {
  buildDetailsList?: GcrBuildDetailsDTO[];
}

export interface ResponseGcrResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GcrResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseGcrBuildDetailsDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GcrBuildDetailsDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface GcrRequestDTO {
  tag?: string;
  tagRegex?: string;
  tagsList?: string[];
  registryHostname?: string;
}

export interface DelegateProfileDetailsNg {
  uuid?: string;
  accountId?: string;
  name?: string;
  description?: string;
  primary?: boolean;
  approvalRequired?: boolean;
  startupScript?: string;
  scopingRules?: ScopingRuleDetailsNg[];
  selectors?: string[];
  createdBy?: EmbeddedUserDetails;
  lastUpdatedBy?: EmbeddedUserDetails;
  identifier?: string;
  numberOfDelegates?: number;
}

export interface EmbeddedUserDetails {
  uuid?: string;
  name?: string;
  email?: string;
}

export interface RestResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: DelegateProfileDetailsNg;
  responseMessages?: ResponseMessage[];
}

export interface ScopingRuleDetailsNg {
  description?: string;
  environmentTypeId?: string;
  environmentIds?: string[];
}

export interface RestResponseVoid {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: Void;
  responseMessages?: ResponseMessage[];
}

export interface Void {
  [key: string]: any;
}

export interface RestResponsePageResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: DelegateProfileDetailsNg[];
  responseMessages?: ResponseMessage[];
}

export interface ContextElement {
  name?: string;
  uuid?: string;
  elementType?:
    | "SERVICE"
    | "INFRAMAPPING"
    | "SERVICE_TEMPLATE"
    | "TAG"
    | "SHELL"
    | "HOST"
    | "INSTANCE"
    | "STANDARD"
    | "PARAM"
    | "PARTITION"
    | "OTHER"
    | "FORK"
    | "CONTAINER_SERVICE"
    | "CLUSTER"
    | "AWS_LAMBDA_FUNCTION"
    | "AMI_SERVICE_SETUP"
    | "AMI_SERVICE_DEPLOY"
    | "ECS_SERVICE_SETUP"
    | "AMI_SWITCH_ROUTES"
    | "PCF_SERVICE_SETUP"
    | "PCF_SERVICE_DEPLOY"
    | "PCF_ROUTE_SWAP_ROLLBACK"
    | "PCF_INSTANCE"
    | "SPOTINST_SERVICE_SETUP"
    | "SPOTINST_SERVICE_DEPLOY"
    | "ARTIFACT"
    | "ARTIFACT_VARIABLE"
    | "HELM_DEPLOY"
    | "CLOUD_FORMATION_PROVISION"
    | "CLOUD_FORMATION_ROLLBACK"
    | "CLOUD_FORMATION_DEPROVISION"
    | "TERRAFORM_PROVISION"
    | "SHELL_SCRIPT_PROVISION"
    | "K8S"
    | "TERRAFORM_INHERIT_PLAN"
    | "TERRAGRUNT_INHERIT_PLAN"
    | "AZURE_VMSS_SETUP"
    | "AZURE_WEBAPP_SETUP"
    | "HELM_CHART"
    | "MANIFEST_VARIABLE";
}

export interface DOMConfiguration {
  parameterNames?: DOMStringList;
}

export interface DOMImplementation {
  [key: string]: any;
}

export interface DOMStringList {
  length?: number;
}

export interface DelegateMetaInfo {
  id?: string;
  hostName?: string;
}

export interface DelegateResponseData {
  [key: string]: any;
}

export interface Document {
  doctype?: DocumentType;
  documentElement?: Element;
  inputEncoding?: string;
  xmlEncoding?: string;
  xmlStandalone?: boolean;
  xmlVersion?: string;
  strictErrorChecking?: boolean;
  documentURI?: string;
  domConfig?: DOMConfiguration;
  implementation?: DOMImplementation;
  attributes?: NamedNodeMap;
  prefix?: string;
  nodeType?: number;
  namespaceURI?: string;
  localName?: string;
  nodeName?: string;
  nodeValue?: string;
  parentNode?: Node;
  childNodes?: NodeList;
  firstChild?: Node;
  lastChild?: Node;
  previousSibling?: Node;
  nextSibling?: Node;
  ownerDocument?: Document;
  baseURI?: string;
  textContent?: string;
}

export interface DocumentType {
  name?: string;
  publicId?: string;
  systemId?: string;
  entities?: NamedNodeMap;
  notations?: NamedNodeMap;
  internalSubset?: string;
  attributes?: NamedNodeMap;
  prefix?: string;
  nodeType?: number;
  namespaceURI?: string;
  localName?: string;
  nodeName?: string;
  nodeValue?: string;
  parentNode?: Node;
  childNodes?: NodeList;
  firstChild?: Node;
  lastChild?: Node;
  previousSibling?: Node;
  nextSibling?: Node;
  ownerDocument?: Document;
  baseURI?: string;
  textContent?: string;
}

export interface Element {
  tagName?: string;
  schemaTypeInfo?: TypeInfo;
  attributes?: NamedNodeMap;
  prefix?: string;
  nodeType?: number;
  namespaceURI?: string;
  localName?: string;
  nodeName?: string;
  nodeValue?: string;
  parentNode?: Node;
  childNodes?: NodeList;
  firstChild?: Node;
  lastChild?: Node;
  previousSibling?: Node;
  nextSibling?: Node;
  ownerDocument?: Document;
  baseURI?: string;
  textContent?: string;
}

export interface ExecutionDataValue {
  displayName?: string;
  value?: { [key: string]: any };
}

export type HttpStateExecutionData = DelegateResponseData & {
  httpUrl?: string;
  httpMethod?: string;
  httpResponseCode?: number;
  httpResponseBody?: string;
  assertionStatement?: string;
  assertionStatus?: string;
  header?: string;
  headers?: KeyValuePair[];
  useProxy?: boolean;
  warningMessage?: string;
  document?: Document;
  stateName?: string;
  stateType?: string;
  startTs?: number;
  endTs?: number;
  status?:
    | "ABORTED"
    | "DISCONTINUING"
    | "ERROR"
    | "FAILED"
    | "NEW"
    | "PAUSED"
    | "PAUSING"
    | "QUEUED"
    | "RESUMED"
    | "RUNNING"
    | "SCHEDULED"
    | "STARTING"
    | "SUCCESS"
    | "WAITING"
    | "SKIPPED"
    | "ABORTING"
    | "REJECTED"
    | "EXPIRED"
    | "PREPARING";
  errorMsg?: string;
  waitInterval?: number;
  element?: ContextElement;
  stateParams?: {
    [key: string]: { [key: string]: any };
  };
  delegateMetaInfo?: DelegateMetaInfo;
  templateVariable?: {
    [key: string]: { [key: string]: any };
  };
  type?: string;
  executionSummary?: {
    [key: string]: ExecutionDataValue;
  };
  executionDetails?: {
    [key: string]: ExecutionDataValue;
  };
};

export interface KeyValuePair {
  key?: string;
  value?: string;
}

export interface NamedNodeMap {
  length?: number;
}

export interface Node {
  attributes?: NamedNodeMap;
  prefix?: string;
  nodeType?: number;
  namespaceURI?: string;
  localName?: string;
  nodeName?: string;
  nodeValue?: string;
  parentNode?: Node;
  childNodes?: NodeList;
  firstChild?: Node;
  lastChild?: Node;
  previousSibling?: Node;
  nextSibling?: Node;
  ownerDocument?: Document;
  baseURI?: string;
  textContent?: string;
}

export interface NodeList {
  length?: number;
}

export type ScriptStateExecutionData = DelegateResponseData & {
  name?: string;
  activityId?: string;
  sweepingOutputEnvVariables?: {
    [key: string]: string;
  };
  secretOutputVars?: string[];
  stateName?: string;
  stateType?: string;
  startTs?: number;
  endTs?: number;
  status?:
    | "ABORTED"
    | "DISCONTINUING"
    | "ERROR"
    | "FAILED"
    | "NEW"
    | "PAUSED"
    | "PAUSING"
    | "QUEUED"
    | "RESUMED"
    | "RUNNING"
    | "SCHEDULED"
    | "STARTING"
    | "SUCCESS"
    | "WAITING"
    | "SKIPPED"
    | "ABORTING"
    | "REJECTED"
    | "EXPIRED"
    | "PREPARING";
  errorMsg?: string;
  waitInterval?: number;
  element?: ContextElement;
  stateParams?: {
    [key: string]: { [key: string]: any };
  };
  delegateMetaInfo?: DelegateMetaInfo;
  templateVariable?: {
    [key: string]: { [key: string]: any };
  };
  type?: string;
  executionSummary?: {
    [key: string]: ExecutionDataValue;
  };
  executionDetails?: {
    [key: string]: ExecutionDataValue;
  };
};

export interface TypeInfo {
  typeName?: string;
  typeNamespace?: string;
}

export interface EntitySetupUsageDTO {
  accountIdentifier?: string;
  referredEntity?: EntityDetail;
  referredByEntity: EntityDetail;
  detail?: SetupUsageDetail;
  createdAt?: number;
}

export interface PageEntitySetupUsageDTO {
  totalElements?: number;
  totalPages?: number;
  size?: number;
  content?: EntitySetupUsageDTO[];
  number?: number;
  first?: boolean;
  sort?: Sort;
  last?: boolean;
  numberOfElements?: number;
  pageable?: Pageable;
  empty?: boolean;
}

export interface ResponsePageEntitySetupUsageDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageEntitySetupUsageDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type SecretReferredByConnectorSetupUsageDetail = SetupUsageDetail & {
  fieldName?: string;
};

export interface SetupUsageDetail {
  [key: string]: any;
}

export interface EnvironmentResponseDTO {
  accountId?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  identifier?: string;
  name?: string;
  description?: string;
  color?: string;
  type?: "PreProduction" | "Production";
  deleted?: boolean;
  tags?: {
    [key: string]: string;
  };
  version?: number;
}

export interface ResponseEnvironmentResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EnvironmentResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EnvironmentRequestDTO {
  orgIdentifier: string;
  projectIdentifier: string;
  identifier: string;
  tags?: {
    [key: string]: string;
  };
  name?: string;
  description?: string;
  color?: string;
  type: "PreProduction" | "Production";
  version?: number;
}

export interface PageEnvironmentResponseDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: EnvironmentResponseDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageEnvironmentResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageEnvironmentResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface EnvironmentResponse {
  environment?: EnvironmentResponseDTO;
  createdAt?: number;
  lastModifiedAt?: number;
}

export interface ResponseEnvironmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EnvironmentResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageEnvironmentResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: EnvironmentResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageEnvironmentResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageEnvironmentResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Invite {
  id: string;
  name: string;
  email: string;
  roleBindings: RoleBinding[];
  inviteType: "USER_INITIATED_INVITE" | "ADMIN_INITIATED_INVITE";
  approved?: boolean;
}

export interface ResponseOptionalInvite {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: Invite;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RoleBinding {
  identifier?: string;
  roleIdentifier: string;
  roleName: string;
  resourceGroupIdentifier?: string;
  resourceGroupName?: string;
  managedRole: boolean;
}

export interface PageInvite {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: Invite[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageInvite {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageInvite;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ACLAggregateFilter {
  resourceGroupIdentifiers?: string[];
  roleIdentifiers?: string[];
}

export interface ResponseListInviteOperationResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: (
    | "ACCOUNT_INVITE_ACCEPTED_NEED_PASSWORD"
    | "ACCOUNT_INVITE_ACCEPTED"
    | "USER_INVITED_SUCCESSFULLY"
    | "USER_ALREADY_ADDED"
    | "USER_ALREADY_INVITED"
    | "FAIL"
  )[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface CreateInvite {
  users: string[];
  roleBindings: RoleBinding[];
  inviteType: "USER_INITIATED_INVITE" | "ADMIN_INITIATED_INVITE";
}

export interface GcpResponseDTO {
  clusterNames?: string[];
}

export interface ResponseGcpResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: GcpResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface Organization {
  identifier: string;
  name: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
}

export interface OrganizationAggregateDTO {
  organizationResponse: OrganizationResponse;
  projectsCount?: number;
  admins?: UserSearchDTO[];
  collaborators?: UserSearchDTO[];
}

export interface OrganizationResponse {
  organization: Organization;
  createdAt?: number;
  lastModifiedAt?: number;
  harnessManaged?: boolean;
}

export interface ResponseOrganizationAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: OrganizationAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserSearchDTO {
  name: string;
  email: string;
  uuid: string;
}

export interface Project {
  orgIdentifier?: string;
  identifier: string;
  name: string;
  color?: string;
  modules?: ("CD" | "CI" | "CORE" | "CV" | "CF" | "CE")[];
  description?: string;
  tags?: {
    [key: string]: string;
  };
}

export interface ProjectAggregateDTO {
  projectResponse: ProjectResponse;
  organization?: Organization;
  harnessManagedOrg?: boolean;
  admins?: UserSearchDTO[];
  collaborators?: UserSearchDTO[];
}

export interface ProjectResponse {
  project: Project;
  createdAt?: number;
  lastModifiedAt?: number;
}

export interface ResponseProjectAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ProjectAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type EmailConfigDTO = NotificationSettingConfigDTO & {
  groupEmail: string;
};

export type MicrosoftTeamsConfigDTO = NotificationSettingConfigDTO & {
  microsoftTeamsWebhookUrl: string;
};

export interface NotificationSettingConfigDTO {
  type?: "EMAIL" | "SLACK" | "PAGERDUTY" | "MSTEAMS";
}

export interface PageUserGroupAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserGroupAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export type PagerDutyConfigDTO = NotificationSettingConfigDTO & {
  pagerDutyKey: string;
};

export interface ResponsePageUserGroupAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserGroupAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RoleAssignmentMetadataDTO {
  identifier: string;
  roleIdentifier: string;
  roleName: string;
  resourceGroupIdentifier: string;
  resourceGroupName: string;
  managedRole: boolean;
}

export type SlackConfigDTO = NotificationSettingConfigDTO & {
  slackWebhookUrl: string;
};

export interface UserGroupAggregateDTO {
  userGroupDTO: UserGroupDTO;
  users?: UserSearchDTO[];
  roleAssignmentsMetadataDTO?: RoleAssignmentMetadataDTO[];
  lastModifiedAt?: number;
}

export interface UserGroupDTO {
  accountIdentifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  identifier?: string;
  name?: string;
  users?: string[];
  notificationConfigs?: NotificationSettingConfigDTO[];
  description?: string;
  tags?: {
    [key: string]: string;
  };
}

export interface ResponseListUserGroupAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserGroupAggregateDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface AggregateACLRequest {
  searchTerm?: string;
  resourceGroupFilter?: string[];
  roleFilter?: string[];
}

export interface ResponseUserGroupAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserGroupAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageOrganizationAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: OrganizationAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageOrganizationAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageOrganizationAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageProjectAggregateDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ProjectAggregateDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageProjectAggregateDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageProjectAggregateDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SecretFileDTO {
  account?: string;
  org?: string;
  project?: string;
  identifier?: string;
  secretManager?: string;
  name?: string;
  tags?: string[];
  description?: string;
  type: "SecretFile" | "SecretText" | "SSHKey";
}

export interface EncryptedDataDTO {
  type?: "SecretFile" | "SecretText" | "SSHKey";
  valueType?: "Inline" | "Reference";
  value?: string;
  draft?: boolean;
  account?: string;
  org?: string;
  project?: string;
  identifier?: string;
  secretManager?: string;
  secretManagerName?: string;
  name?: string;
  encryptionType?:
    | "LOCAL"
    | "KMS"
    | "GCP_KMS"
    | "AWS_SECRETS_MANAGER"
    | "AZURE_VAULT"
    | "CYBERARK"
    | "VAULT"
    | "GCP_SECRETS_MANAGER"
    | "CUSTOM"
    | "VAULT_SSH";
  tags?: string[];
  lastUpdatedAt?: number;
  description?: string;
}

export interface ResponseEncryptedDataDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: EncryptedDataDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseSecretManagerMetadataDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SecretManagerMetadataDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SecretManagerMetadataDTO {
  encryptionType?:
    | "LOCAL"
    | "KMS"
    | "GCP_KMS"
    | "AWS_SECRETS_MANAGER"
    | "AZURE_VAULT"
    | "CYBERARK"
    | "VAULT"
    | "GCP_SECRETS_MANAGER"
    | "CUSTOM"
    | "VAULT_SSH";
  spec?: SecretManagerMetadataSpecDTO;
}

export interface SecretManagerMetadataSpecDTO {
  [key: string]: any;
}

export type VaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  secretEngines?: VaultSecretEngineDTO[];
};

export interface VaultSecretEngineDTO {
  name?: string;
  description?: string;
  type?: string;
  version?: number;
}

export interface SecretManagerMetadataRequestDTO {
  encryptionType:
    | "LOCAL"
    | "KMS"
    | "GCP_KMS"
    | "AWS_SECRETS_MANAGER"
    | "AZURE_VAULT"
    | "CYBERARK"
    | "VAULT"
    | "GCP_SECRETS_MANAGER"
    | "CUSTOM"
    | "VAULT_SSH";
  orgIdentifier?: string;
  projectIdentifier?: string;
  identifier: string;
  spec: SecretManagerMetadataRequestSpecDTO;
}

export interface SecretManagerMetadataRequestSpecDTO {
  [key: string]: any;
}

export type VaultAppRoleCredentialDTO = VaultCredentialDTO & {
  appRoleId?: string;
  secretId?: string;
};

export type VaultAuthTokenCredentialDTO = VaultCredentialDTO & {
  authToken?: string;
};

export interface VaultCredentialDTO {
  [key: string]: any;
}

export type VaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  url: string;
  accessType: "APP_ROLE" | "TOKEN";
  spec?: VaultCredentialDTO;
};

export interface PageEncryptedDataDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: EncryptedDataDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageEncryptedDataDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageEncryptedDataDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SecretTextDTO {
  account?: string;
  org?: string;
  project?: string;
  identifier?: string;
  secretManager?: string;
  name?: string;
  tags?: string[];
  description?: string;
  type: "SecretFile" | "SecretText" | "SSHKey";
  valueType: "Inline" | "Reference";
  value?: string;
}

export interface ResponseSecretValidationResultDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SecretValidationResultDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SecretValidationResultDTO {
  success?: boolean;
  message?: string;
}

export type SSHKeyValidationMetadata = SecretValidationMetaData & {
  host: string;
};

export interface SecretValidationMetaData {
  type: "SecretFile" | "SecretText" | "SSHKey";
}

export interface BaseSSHSpecDTO {
  [key: string]: any;
}

export type KerberosConfigDTO = BaseSSHSpecDTO & {
  principal: string;
  realm: string;
  tgtGenerationMethod?: "KeyTabFilePath" | "Password";
  spec?: TGTGenerationSpecDTO;
};

export interface ResponseSecretResponseWrapper {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SecretResponseWrapper;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SSHAuthDTO {
  spec: BaseSSHSpecDTO;
  type: "SSH" | "Kerberos";
}

export type SSHConfigDTO = BaseSSHSpecDTO & {
  credentialType: "Password" | "KeyPath" | "KeyReference";
  spec: SSHCredentialSpecDTO;
};

export interface SSHCredentialSpecDTO {
  [key: string]: any;
}

export type SSHKeyPathCredentialDTO = SSHCredentialSpecDTO & {
  userName: string;
  keyPath: string;
  encryptedPassphrase?: string;
};

export type SSHKeyReferenceCredentialDTO = SSHCredentialSpecDTO & {
  userName: string;
  key?: string;
  encryptedPassphrase?: string;
};

export type SSHKeySpecDTO = SecretSpecDTO & {
  port?: number;
  auth: SSHAuthDTO;
};

export type SSHPasswordCredentialDTO = SSHCredentialSpecDTO & {
  userName: string;
  password: string;
};

export interface SecretDTOV2 {
  type: "SecretFile" | "SecretText" | "SSHKey";
  name: string;
  identifier: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  tags?: {
    [key: string]: string;
  };
  description?: string;
  spec: SecretSpecDTO;
}

export type SecretFileSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string;
};

export interface SecretResponseWrapper {
  secret: SecretDTOV2;
  createdAt?: number;
  updatedAt?: number;
  draft?: boolean;
}

export interface SecretSpecDTO {
  errorMessageForInvalidYaml?: string;
}

export type SecretTextSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string;
  valueType: "Inline" | "Reference";
  value?: string;
};

export interface TGTGenerationSpecDTO {
  [key: string]: any;
}

export type TGTKeyTabFilePathSpecDTO = TGTGenerationSpecDTO & {
  keyPath?: string;
};

export type TGTPasswordSpecDTO = TGTGenerationSpecDTO & {
  password?: string;
};

export interface SecretRequestWrapper {
  secret: SecretDTOV2;
}

export interface PageSecretResponseWrapper {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: SecretResponseWrapper[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageSecretResponseWrapper {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageSecretResponseWrapper;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseOrganizationResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: OrganizationResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface OrganizationRequest {
  organization: Organization;
}

export interface PageOrganizationResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: OrganizationResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageOrganizationResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageOrganizationResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseProjectResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ProjectResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ProjectRequest {
  project: Project;
}

export interface PageProjectResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ProjectResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageProjectResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageProjectResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseUserGroupDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserGroupDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseListUserGroupDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserGroupDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserGroupFilterDTO {
  databaseIdFilter?: string[];
  identifierFilter?: string[];
  userIdentifierFilter?: string[];
  accountIdentifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
}

export interface PageUserGroupDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserGroupDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageUserGroupDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserGroupDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageUserInfo {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserInfo[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageUserInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserInfo {
  uuid?: string;
  name?: string;
  email?: string;
  token?: string;
  defaultAccountId?: string;
  admin?: boolean;
  twoFactorAuthenticationEnabled?: boolean;
}

export interface ResponseServiceResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceResponseDTO {
  accountId?: string;
  identifier?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  name?: string;
  description?: string;
  deleted?: boolean;
  tags?: {
    [key: string]: string;
  };
  version?: number;
}

export interface ServiceRequestDTO {
  identifier: string;
  orgIdentifier: string;
  projectIdentifier: string;
  name?: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  version?: number;
}

export interface PageServiceResponseDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ServiceResponseDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageServiceResponseDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageServiceResponseDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseServiceResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: ServiceResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ServiceResponse {
  service?: ServiceResponseDTO;
  createdAt?: number;
  lastModifiedAt?: number;
}

export interface PageServiceResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: ServiceResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageServiceResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageServiceResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseTwoFactorAuthSettingsInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: TwoFactorAuthSettingsInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface TwoFactorAuthSettingsInfo {
  userId?: string;
  email?: string;
  twoFactorAuthenticationEnabled?: boolean;
  mechanism?: "TOTP";
  totpSecretKey?: string;
  totpqrurl?: string;
}

export interface ResponseUserInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageUserSearchDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserSearchDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageUserSearchDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserSearchDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PageProject {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: Project[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageProject {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageProject;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseUserAggregate {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: UserAggregate;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface UserAggregate {
  user: UserSearchDTO;
  roleBindings?: RoleBinding[];
}

export interface PageUserAggregate {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: UserAggregate[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageUserAggregate {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageUserAggregate;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface AdviserIssuer {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserAdviserIssuer;
  defaultInstanceForType?: AdviserIssuer;
  adviserTypeValue?: number;
  adviserType?:
    | "UNKNOWN"
    | "NEXT_STEP"
    | "RETRY"
    | "INTERVENTION_WAIT"
    | "END_PLAN"
    | "MARK_SUCCESS"
    | "UNRECOGNIZED";
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface AdviserIssuerOrBuilder {
  adviserTypeValue?: number;
  adviserType?:
    | "UNKNOWN"
    | "NEXT_STEP"
    | "RETRY"
    | "INTERVENTION_WAIT"
    | "END_PLAN"
    | "MARK_SUCCESS"
    | "UNRECOGNIZED";
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface ArtifactSummary {
  type?: string;
  displayName?: string;
}

export interface ArtifactsSummary {
  primary?: ArtifactSummary;
  sidecars?: ArtifactSummary[];
}

export interface AsyncExecutableResponse {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserAsyncExecutableResponse;
  defaultInstanceForType?: AsyncExecutableResponse;
  mode?:
    | "RUNNING_MODE"
    | "APPROVAL_WAITING_MODE"
    | "RESOURCE_WAITING_MODE"
    | "UNRECOGNIZED";
  callbackIdsList?: string[];
  callbackIdsCount?: number;
  logKeysList?: string[];
  logKeysCount?: number;
  unitsList?: string[];
  unitsCount?: number;
  modeValue?: number;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface AsyncExecutableResponseOrBuilder {
  mode?:
    | "RUNNING_MODE"
    | "APPROVAL_WAITING_MODE"
    | "RESOURCE_WAITING_MODE"
    | "UNRECOGNIZED";
  callbackIdsList?: string[];
  callbackIdsCount?: number;
  logKeysList?: string[];
  logKeysCount?: number;
  unitsList?: string[];
  unitsCount?: number;
  modeValue?: number;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export type CDStageExecutionSummaryDTO = StageExecutionSummaryDTO & {
  planExecutionId?: string;
  stageIdentifier?: string;
  serviceInfo?: ServiceExecutionSummary;
  stageName?: string;
  serviceDefinitionType?: string;
  executionStatus?:
    | "Running"
    | "Failed"
    | "NotStarted"
    | "Expired"
    | "Aborted"
    | "Queued"
    | "Paused"
    | "Waiting"
    | "InterventionWaiting"
    | "ApprovalWaiting"
    | "Success"
    | "Suspended"
    | "Skipped"
    | "Pausing"
    | "ApprovalRejected";
  startedAt?: number;
  endedAt?: number;
  serviceIdentifier?: string;
  envIdentifier?: string;
  errorInfo?: ExecutionErrorInfo;
};

export interface Child {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserChild;
  defaultInstanceForType?: Child;
  childNodeIdBytes?: ByteString;
  childNodeId?: string;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ChildChainExecutableResponse {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserChildChainExecutableResponse;
  defaultInstanceForType?: ChildChainExecutableResponse;
  nextChildId?: string;
  nextChildIdBytes?: ByteString;
  previousChildId?: string;
  previousChildIdBytes?: ByteString;
  passThroughData?: ByteString;
  lastLink?: boolean;
  suspend?: boolean;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ChildChainExecutableResponseOrBuilder {
  nextChildId?: string;
  nextChildIdBytes?: ByteString;
  previousChildId?: string;
  previousChildIdBytes?: ByteString;
  passThroughData?: ByteString;
  lastLink?: boolean;
  suspend?: boolean;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface ChildExecutableResponse {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserChildExecutableResponse;
  defaultInstanceForType?: ChildExecutableResponse;
  childNodeIdBytes?: ByteString;
  childNodeId?: string;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ChildExecutableResponseOrBuilder {
  childNodeIdBytes?: ByteString;
  childNodeId?: string;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface ChildOrBuilder {
  childNodeIdBytes?: ByteString;
  childNodeId?: string;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface ChildrenExecutableResponse {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserChildrenExecutableResponse;
  defaultInstanceForType?: ChildrenExecutableResponse;
  childrenCount?: number;
  childrenList?: Child[];
  childrenOrBuilderList?: ChildOrBuilder[];
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ChildrenExecutableResponseOrBuilder {
  childrenCount?: number;
  childrenList?: Child[];
  childrenOrBuilderList?: ChildOrBuilder[];
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface DelegateInfo {
  id?: string;
  name?: string;
  taskId?: string;
  taskName?: string;
}

export interface ExecutableResponse {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserExecutableResponse;
  defaultInstanceForType?: ExecutableResponse;
  async?: AsyncExecutableResponse;
  responseCase?:
    | "ASYNC"
    | "CHILD"
    | "CHILDREN"
    | "CHILDCHAIN"
    | "TASK"
    | "TASKCHAIN"
    | "SYNC"
    | "SKIPTASK"
    | "RESPONSE_NOT_SET";
  asyncOrBuilder?: AsyncExecutableResponseOrBuilder;
  child?: ChildExecutableResponse;
  childOrBuilder?: ChildExecutableResponseOrBuilder;
  children?: ChildrenExecutableResponse;
  childrenOrBuilder?: ChildrenExecutableResponseOrBuilder;
  childChain?: ChildChainExecutableResponse;
  childChainOrBuilder?: ChildChainExecutableResponseOrBuilder;
  taskOrBuilder?: TaskExecutableResponseOrBuilder;
  taskChain?: TaskChainExecutableResponse;
  taskChainOrBuilder?: TaskChainExecutableResponseOrBuilder;
  sync?: SyncExecutableResponse;
  syncOrBuilder?: SyncExecutableResponseOrBuilder;
  skipTask?: SkipTaskExecutableResponse;
  skipTaskOrBuilder?: SkipTaskExecutableResponseOrBuilder;
  task?: TaskExecutableResponse;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ExecutionErrorInfo {
  unknownFields?: UnknownFieldSet;
  message?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserExecutionErrorInfo;
  defaultInstanceForType?: ExecutionErrorInfo;
  messageBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ExecutionGraph {
  rootNodeId?: string;
  nodeMap?: {
    [key: string]: ExecutionNode;
  };
  nodeAdjacencyListMap?: {
    [key: string]: ExecutionNodeAdjacencyList;
  };
  representationStrategy?: "camelCase";
}

export interface ExecutionNode {
  uuid?: string;
  setupId?: string;
  name?: string;
  identifier?: string;
  baseFqn?: string;
  outcomes?: {
    [key: string]: { [key: string]: any };
  }[];
  stepParameters?: {
    [key: string]: { [key: string]: any };
  };
  startTs?: number;
  endTs?: number;
  stepType?: string;
  status?:
    | "Running"
    | "Failed"
    | "NotStarted"
    | "Expired"
    | "Aborted"
    | "Queued"
    | "Paused"
    | "Waiting"
    | "InterventionWaiting"
    | "ApprovalWaiting"
    | "Success"
    | "Suspended"
    | "Skipped"
    | "Pausing"
    | "ApprovalRejected";
  failureInfo?: FailureInfoDTO;
  skipInfo?: SkipInfo;
  nodeRunInfo?: NodeRunInfo;
  executableResponses?: ExecutableResponse[];
  taskIdToProgressDataMap?: {
    [key: string]: ProgressData[];
  };
  unitProgresses?: UnitProgress[];
  delegateInfoList?: DelegateInfo[];
  interruptHistories?: InterruptEffect[];
}

export interface ExecutionNodeAdjacencyList {
  children?: string[];
  nextIds?: string[];
}

export interface FailureInfoDTO {
  message?: string;
  failureTypeList?: (
    | "EXPIRED"
    | "DELEGATE_PROVISIONING"
    | "CONNECTIVITY"
    | "AUTHENTICATION"
    | "VERIFICATION_FAILURE"
    | "APPLICATION_ERROR"
    | "AUTHORIZATION_ERROR"
    | "TIMEOUT_ERROR"
  )[];
  responseMessages?: ResponseMessage[];
}

export interface InterruptConfig {
  unknownFields?: UnknownFieldSet;
  configCase?: "RETRYINTERRUPTCONFIG" | "CONFIG_NOT_SET";
  issuedBy?: IssuedBy;
  issuedByOrBuilder?: IssuedByOrBuilder;
  retryInterruptConfig?: RetryInterruptConfig;
  retryInterruptConfigOrBuilder?: RetryInterruptConfigOrBuilder;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserInterruptConfig;
  defaultInstanceForType?: InterruptConfig;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface InterruptEffect {
  interruptId: string;
  tookEffectAt: number;
  interruptType:
    | "UNKNOWN"
    | "ABORT"
    | "ABORT_ALL"
    | "PAUSE"
    | "PAUSE_ALL"
    | "RESUME"
    | "RESUME_ALL"
    | "RETRY"
    | "IGNORE"
    | "WAITING_FOR_MANUAL_INTERVENTION"
    | "MARK_FAILED"
    | "MARK_SUCCESS"
    | "NEXT_STEP"
    | "END_EXECUTION"
    | "MARK_EXPIRED"
    | "CUSTOM_FAILURE"
    | "UNRECOGNIZED";
  interruptConfig: InterruptConfig;
}

export interface IssuedBy {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserIssuedBy;
  defaultInstanceForType?: IssuedBy;
  manualIssuer?: ManualIssuer;
  manualIssuerOrBuilder?: ManualIssuerOrBuilder;
  adviserIssuer?: AdviserIssuer;
  adviserIssuerOrBuilder?: AdviserIssuerOrBuilder;
  timeoutIssuer?: TimeoutIssuer;
  timeoutIssuerOrBuilder?: TimeoutIssuerOrBuilder;
  issuerCase?:
    | "MANUALISSUER"
    | "ADVISERISSUER"
    | "TIMEOUTISSUER"
    | "ISSUER_NOT_SET";
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface IssuedByOrBuilder {
  manualIssuer?: ManualIssuer;
  manualIssuerOrBuilder?: ManualIssuerOrBuilder;
  adviserIssuer?: AdviserIssuer;
  adviserIssuerOrBuilder?: AdviserIssuerOrBuilder;
  timeoutIssuer?: TimeoutIssuer;
  timeoutIssuerOrBuilder?: TimeoutIssuerOrBuilder;
  issuerCase?:
    | "MANUALISSUER"
    | "ADVISERISSUER"
    | "TIMEOUTISSUER"
    | "ISSUER_NOT_SET";
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface ManualIssuer {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserManualIssuer;
  defaultInstanceForType?: ManualIssuer;
  userId?: string;
  emailId?: string;
  emailIdBytes?: ByteString;
  userIdBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ManualIssuerOrBuilder {
  userId?: string;
  emailId?: string;
  emailIdBytes?: ByteString;
  userIdBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface NGStageType {
  type?: string;
}

export interface NodeRunInfo {
  unknownFields?: UnknownFieldSet;
  evaluatedCondition?: boolean;
  whenCondition?: string;
  whenConditionBytes?: ByteString;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserNodeRunInfo;
  defaultInstanceForType?: NodeRunInfo;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export type ParallelStageExecutionSummaryDTO = StageExecutionSummaryDTO & {
  stageExecutions?: StageExecutionSummaryDTO[];
};

export interface ParserAdviserIssuer {
  [key: string]: any;
}

export interface ParserAsyncExecutableResponse {
  [key: string]: any;
}

export interface ParserChild {
  [key: string]: any;
}

export interface ParserChildChainExecutableResponse {
  [key: string]: any;
}

export interface ParserChildExecutableResponse {
  [key: string]: any;
}

export interface ParserChildrenExecutableResponse {
  [key: string]: any;
}

export interface ParserExecutableResponse {
  [key: string]: any;
}

export interface ParserExecutionErrorInfo {
  [key: string]: any;
}

export interface ParserInterruptConfig {
  [key: string]: any;
}

export interface ParserIssuedBy {
  [key: string]: any;
}

export interface ParserManualIssuer {
  [key: string]: any;
}

export interface ParserNodeRunInfo {
  [key: string]: any;
}

export interface ParserRetryInterruptConfig {
  [key: string]: any;
}

export interface ParserSkipInfo {
  [key: string]: any;
}

export interface ParserSkipTaskExecutableResponse {
  [key: string]: any;
}

export interface ParserSyncExecutableResponse {
  [key: string]: any;
}

export interface ParserTaskChainExecutableResponse {
  [key: string]: any;
}

export interface ParserTaskExecutableResponse {
  [key: string]: any;
}

export interface ParserTimeoutIssuer {
  [key: string]: any;
}

export interface ParserUnitProgress {
  [key: string]: any;
}

export interface PipelineExecutionDetail {
  pipelineExecution?: PipelineExecutionSummaryDTO;
  stageGraph?: ExecutionGraph;
  stageRollbackGraph?: ExecutionGraph;
}

export interface PipelineExecutionSummaryDTO {
  pipelineIdentifier?: string;
  pipelineName?: string;
  deploymentId?: string;
  planExecutionId?: string;
  executionStatus?:
    | "Running"
    | "Failed"
    | "NotStarted"
    | "Expired"
    | "Aborted"
    | "Queued"
    | "Paused"
    | "Waiting"
    | "InterventionWaiting"
    | "ApprovalWaiting"
    | "Success"
    | "Suspended"
    | "Skipped"
    | "Pausing"
    | "ApprovalRejected";
  inputSetYaml?: string;
  startedAt?: number;
  endedAt?: number;
  tags?: {
    [key: string]: string;
  };
  stageExecutionSummaryElements?: StageExecutionSummaryDTO[];
  errorMsg?: string;
  stageIdentifiers?: string[];
  serviceIdentifiers?: string[];
  envIdentifiers?: string[];
  serviceDefinitionTypes?: string[];
  stageTypes?: NGStageType[];
  errorInfo?: ExecutionErrorInfo;
  triggerInfo?: ExecutionTriggerInfo;
  successfulStagesCount?: number;
  runningStagesCount?: number;
  failedStagesCount?: number;
  totalStagesCount?: number;
}

export interface ProgressData {
  [key: string]: any;
}

export interface ResponsePipelineExecutionDetail {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PipelineExecutionDetail;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RetryInterruptConfig {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserRetryInterruptConfig;
  defaultInstanceForType?: RetryInterruptConfig;
  retryIdBytes?: ByteString;
  retryId?: string;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface RetryInterruptConfigOrBuilder {
  retryIdBytes?: ByteString;
  retryId?: string;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface ServiceExecutionSummary {
  identifier?: string;
  displayName?: string;
  deploymentType?: string;
  artifacts?: ArtifactsSummary;
}

export interface SkipInfo {
  unknownFields?: UnknownFieldSet;
  skipCondition?: string;
  skipConditionBytes?: ByteString;
  evaluatedCondition?: boolean;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserSkipInfo;
  defaultInstanceForType?: SkipInfo;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface SkipTaskExecutableResponse {
  unknownFields?: UnknownFieldSet;
  message?: string;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserSkipTaskExecutableResponse;
  defaultInstanceForType?: SkipTaskExecutableResponse;
  messageBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface SkipTaskExecutableResponseOrBuilder {
  message?: string;
  messageBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface StageExecutionSummaryDTO {
  [key: string]: any;
}

export interface SyncExecutableResponse {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserSyncExecutableResponse;
  defaultInstanceForType?: SyncExecutableResponse;
  logKeysList?: string[];
  logKeysCount?: number;
  unitsList?: string[];
  unitsCount?: number;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface SyncExecutableResponseOrBuilder {
  logKeysList?: string[];
  logKeysCount?: number;
  unitsList?: string[];
  unitsCount?: number;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface TaskChainExecutableResponse {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserTaskChainExecutableResponse;
  defaultInstanceForType?: TaskChainExecutableResponse;
  taskId?: string;
  taskName?: string;
  logKeysList?: string[];
  logKeysCount?: number;
  unitsList?: string[];
  unitsCount?: number;
  taskCategoryValue?: number;
  taskCategory?:
    | "UNKNOWN_CATEGORY"
    | "DELEGATE_TASK_V1"
    | "DELEGATE_TASK_V2"
    | "UNRECOGNIZED";
  taskNameBytes?: ByteString;
  chainEnd?: boolean;
  passThroughData?: ByteString;
  taskIdBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface TaskChainExecutableResponseOrBuilder {
  taskId?: string;
  taskName?: string;
  logKeysList?: string[];
  logKeysCount?: number;
  unitsList?: string[];
  unitsCount?: number;
  taskCategoryValue?: number;
  taskCategory?:
    | "UNKNOWN_CATEGORY"
    | "DELEGATE_TASK_V1"
    | "DELEGATE_TASK_V2"
    | "UNRECOGNIZED";
  taskNameBytes?: ByteString;
  chainEnd?: boolean;
  passThroughData?: ByteString;
  taskIdBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface TaskExecutableResponse {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserTaskExecutableResponse;
  defaultInstanceForType?: TaskExecutableResponse;
  taskId?: string;
  taskName?: string;
  logKeysList?: string[];
  logKeysCount?: number;
  unitsList?: string[];
  unitsCount?: number;
  taskCategoryValue?: number;
  taskCategory?:
    | "UNKNOWN_CATEGORY"
    | "DELEGATE_TASK_V1"
    | "DELEGATE_TASK_V2"
    | "UNRECOGNIZED";
  taskNameBytes?: ByteString;
  taskIdBytes?: ByteString;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface TaskExecutableResponseOrBuilder {
  taskId?: string;
  taskName?: string;
  logKeysList?: string[];
  logKeysCount?: number;
  unitsList?: string[];
  unitsCount?: number;
  taskCategoryValue?: number;
  taskCategory?:
    | "UNKNOWN_CATEGORY"
    | "DELEGATE_TASK_V1"
    | "DELEGATE_TASK_V2"
    | "UNRECOGNIZED";
  taskNameBytes?: ByteString;
  taskIdBytes?: ByteString;
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface TimeoutIssuer {
  unknownFields?: UnknownFieldSet;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserTimeoutIssuer;
  defaultInstanceForType?: TimeoutIssuer;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface TimeoutIssuerOrBuilder {
  unknownFields?: UnknownFieldSet;
  defaultInstanceForType?: Message;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
  initialized?: boolean;
}

export interface UnitProgress {
  unknownFields?: UnknownFieldSet;
  unitName?: string;
  unitNameBytes?: ByteString;
  statusValue?: number;
  status?:
    | "UNKNOWN"
    | "SUCCESS"
    | "FAILURE"
    | "RUNNING"
    | "QUEUED"
    | "SKIPPED"
    | "EXPIRED"
    | "UNRECOGNIZED";
  startTime?: number;
  endTime?: number;
  initialized?: boolean;
  serializedSize?: number;
  parserForType?: ParserUnitProgress;
  defaultInstanceForType?: UnitProgress;
  initializationErrorString?: string;
  descriptorForType?: Descriptor;
  allFields?: {
    [key: string]: { [key: string]: any };
  };
}

export interface ResponseListExecutionStatus {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: (
    | "Running"
    | "Failed"
    | "NotStarted"
    | "Expired"
    | "Aborted"
    | "Queued"
    | "Paused"
    | "Waiting"
    | "InterventionWaiting"
    | "ApprovalWaiting"
    | "Success"
    | "Suspended"
    | "Skipped"
    | "Pausing"
    | "ApprovalRejected"
  )[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponsePipelineExecutionInterrupt {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PipelineExecutionInterrupt;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface PipelineExecutionInterrupt {
  id?: string;
  type?: "Abort" | "Pause" | "Resume";
  planExecutionId?: string;
}

export interface PagePipelineExecutionSummaryDTO {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: PipelineExecutionSummaryDTO[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePagePipelineExecutionSummaryDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PagePipelineExecutionSummaryDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface CDStageModuleInfo {
  serviceInfo?: ServiceExecutionSummary;
  infraExecutionSummary?: InfraExecutionSummary;
  nodeExecutionId?: string;
}

export interface InfraExecutionSummary {
  identifier?: string;
  name?: string;
  type?: string;
}

export interface ResponseCDStageModuleInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: CDStageModuleInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface CDPipelineModuleInfo {
  serviceIdentifiers?: string[];
  envIdentifiers?: string[];
  serviceDefinitionTypes?: string[];
  environmentTypes?: ("PreProduction" | "Production")[];
  infrastructureTypes?: string[];
}

export interface ResponseCDPipelineModuleInfo {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: CDPipelineModuleInfo;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface JiraStatusCategoryNG {
  id: number;
  key: string;
  name: string;
}

export interface JiraStatusNG {
  id: string;
  name: string;
  statusCategory?: JiraStatusCategoryNG;
}

export interface ResponseListJiraStatusNG {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JiraStatusNG[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface JiraFieldAllowedValueNG {
  id?: string;
  name?: string;
  value?: string;
}

export interface JiraFieldNG {
  key: string;
  name: string;
  required?: boolean;
  schema: JiraFieldSchemaNG;
  allowedValues: JiraFieldAllowedValueNG[];
  custom?: boolean;
}

export interface JiraFieldSchemaNG {
  array?: boolean;
  typeStr: string;
  type: "string" | "number" | "date" | "datetime" | "timetracking" | "option";
  customType?: string;
}

export interface JiraIssueCreateMetadataNG {
  projects?: {
    [key: string]: JiraProjectNG;
  };
}

export interface JiraIssueTypeNG {
  id: string;
  name: string;
  description?: string;
  statuses: JiraStatusNG[];
  fields: {
    [key: string]: JiraFieldNG;
  };
  subTask?: boolean;
}

export interface JiraProjectNG {
  id: string;
  key: string;
  name: string;
  issuetypes: {
    [key: string]: JiraIssueTypeNG;
  };
}

export interface ResponseJiraIssueCreateMetadataNG {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JiraIssueCreateMetadataNG;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface JiraIssueUpdateMetadataNG {
  fields: {
    [key: string]: JiraFieldNG;
  };
}

export interface ResponseJiraIssueUpdateMetadataNG {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JiraIssueUpdateMetadataNG;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface JiraProjectBasicNG {
  id: string;
  key: string;
  name: string;
}

export interface ResponseListJiraProjectBasicNG {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JiraProjectBasicNG[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type AwsCodeCommitSCMDTO = SourceCodeManagerDTO & {
  authentication: AwsCodeCommitAuthenticationDTO;
};

export type AzureDevOpsSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication;
};

export type BitbucketSCMDTO = SourceCodeManagerDTO & {
  authentication?: BitbucketAuthentication;
};

export type GithubSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication;
};

export type GitlabSCMDTO = SourceCodeManagerDTO & {
  authentication: GitlabAuthentication;
};

export interface ResponseListSourceCodeManagerDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SourceCodeManagerDTO[];
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface SourceCodeManagerAuthentication {
  [key: string]: any;
}

export interface SourceCodeManagerDTO {
  id?: string;
  userIdentifier?: string;
  name: string;
  createdAt?: number;
  lastModifiedAt?: number;
  type?:
    | "BITBUCKET"
    | "GITHUB"
    | "GITLAB"
    | "AWS_CODE_COMMIT"
    | "AZURE_DEV_OPS";
  authentication?: SourceCodeManagerAuthentication;
}

export interface ResponseSourceCodeManagerDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: SourceCodeManagerDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface InputSetError {
  fieldName?: string;
  message?: string;
  identifierOfErrorSource?: string;
}

export interface InputSetErrorResponse {
  errors?: InputSetError[];
}

export interface InputSetErrorWrapper {
  errorPipelineYaml?: string;
  uuidToErrorResponseMap?: {
    [key: string]: InputSetErrorResponse;
  };
}

export interface InputSetResponse {
  accountId?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  pipelineIdentifier?: string;
  identifier?: string;
  inputSetYaml?: string;
  name?: string;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  inputSetErrorWrapper?: InputSetErrorWrapper;
  version?: number;
  errorResponse?: boolean;
}

export interface ResponseInputSetResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: InputSetResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface OverlayInputSetResponse {
  accountId?: string;
  orgIdentifier?: string;
  projectIdentifier?: string;
  pipelineIdentifier?: string;
  identifier?: string;
  name?: string;
  description?: string;
  inputSetReferences?: string[];
  overlayInputSetYaml?: string;
  tags?: {
    [key: string]: string;
  };
  invalidInputSetReferences?: {
    [key: string]: string;
  };
  version?: number;
  errorResponse?: boolean;
}

export interface ResponseOverlayInputSetResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: OverlayInputSetResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface InputSetConfig {
  identifier: string;
  name?: string;
  description?: string;
  pipeline: NgPipeline;
  tags?: {
    [key: string]: string;
  };
}

export interface OverlayInputSetConfig {
  identifier?: string;
  name?: string;
  description?: string;
  inputSetReferences?: string[];
  tags?: {
    [key: string]: string;
  };
}

export interface InputSetSummaryResponse {
  identifier?: string;
  name?: string;
  pipelineIdentifier?: string;
  description?: string;
  inputSetType?: "INPUT_SET" | "OVERLAY_INPUT_SET";
  tags?: {
    [key: string]: string;
  };
  version?: number;
}

export interface PageInputSetSummaryResponse {
  totalPages?: number;
  totalItems?: number;
  pageItemCount?: number;
  pageSize?: number;
  content?: InputSetSummaryResponse[];
  pageIndex?: number;
  empty?: boolean;
}

export interface ResponsePageInputSetSummaryResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageInputSetSummaryResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface InputSetTemplateResponse {
  inputSetTemplateYaml?: string;
}

export interface ResponseInputSetTemplateResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: InputSetTemplateResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface MergeInputSetResponse {
  pipelineYaml?: string;
  inputSetErrorWrapper?: InputSetErrorWrapper;
  errorResponse?: boolean;
}

export interface ResponseMergeInputSetResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: MergeInputSetResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface NGPipelineSummaryResponse {
  name?: string;
  identifier?: string;
  description?: string;
  numOfStages?: number;
  numOfErrors?: number;
  deployments?: number[];
  tags?: {
    [key: string]: string;
  };
  version?: number;
}

export interface PageNGPipelineSummaryResponse {
  totalElements?: number;
  totalPages?: number;
  size?: number;
  content?: NGPipelineSummaryResponse[];
  number?: number;
  first?: boolean;
  sort?: Sort;
  last?: boolean;
  numberOfElements?: number;
  pageable?: Pageable;
  empty?: boolean;
}

export interface ResponsePageNGPipelineSummaryResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PageNGPipelineSummaryResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseNGPipelineSummaryResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: NGPipelineSummaryResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export type ApprovalStageConfig = StageInfoConfig & {
  execution: ExecutionElementConfig;
};

export interface BarrierInfoConfig {
  identifier: string;
  name: string;
}

export interface CIProperties {
  codebase?: CodeBase;
}

export type DeploymentStageConfig = StageInfoConfig & {
  serviceConfig: ServiceConfig;
  infrastructure: PipelineInfrastructure;
  execution: ExecutionElementConfig;
};

export type FeatureStageConfig = StageInfoConfig & {};

export interface FlowControlConfig {
  barriers?: BarrierInfoConfig[];
}

export interface NGProperties {
  ci?: CIProperties;
}

export interface NotificationChannelWrapper {
  type?: string;
  spec?: PmsNotificationChannel;
}

export interface NotificationRules {
  name?: string;
  enabled?: boolean;
  pipelineEvents?: PipelineEvent[];
  notificationMethod?: NotificationChannelWrapper;
}

export interface ParallelStageElementConfig {
  sections: StageElementWrapperConfig[];
}

export interface PipelineConfig {
  pipeline?: PipelineInfoConfig;
}

export interface PipelineEvent {
  type?:
    | "AllEvents"
    | "PipelineStart"
    | "PipelineSuccess"
    | "PipelineFailed"
    | "PipelinePaused"
    | "StageSuccess"
    | "StageFailed"
    | "StageStart"
    | "StepFailed";
  forStages?: string[];
}

export interface PipelineInfoConfig {
  name: string;
  identifier: string;
  flowControl?: FlowControlConfig;
  description?: string;
  tags?: {
    [key: string]: string;
  };
  variables?: NGVariable[];
  properties?: NGProperties;
  stages?: StageElementWrapperConfig[];
  notificationRules?: NotificationRules[];
}

export type PmsEmailChannel = PmsNotificationChannel & {
  userGroups?: string[];
  recipients?: string[];
};

export type PmsMSTeamChannel = PmsNotificationChannel & {
  msTeamKeys?: string[];
  userGroups?: string[];
};

export interface PmsNotificationChannel {
  [key: string]: any;
}

export type PmsPagerDutyChannel = PmsNotificationChannel & {
  userGroups?: string[];
  integrationKey?: string;
};

export type PmsSlackChannel = PmsNotificationChannel & {
  userGroups?: string[];
  webhookUrl?: string;
};

export interface ResponsePipelineConfig {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PipelineConfig;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface StageElementConfig {
  identifier: string;
  name: string;
  description?: string;
  skipCondition?: string;
  failureStrategies?: FailureStrategyConfig[];
  variables?: NGVariable[];
  tags?: {
    [key: string]: string;
  };
  type: string;
  spec?: StageInfoConfig;
}

export interface StageElementWrapperConfig {
  stage?: StageElementConfig;
  parallel?: ParallelStageElementConfig;
}

export interface StageInfoConfig {
  execution?: ExecutionElementConfig;
}

export interface NGPipelineResponse {
  ngPipeline?: NgPipeline;
  executionsPlaceHolder?: string[];
  yamlPipeline?: string;
  version?: number;
}

export interface ResponseNGPipelineResponse {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: NGPipelineResponse;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface RestResponseUserInfo {
  metaData?: {
    [key: string]: { [key: string]: any };
  };
  resource?: UserInfo;
  responseMessages?: ResponseMessage[];
}

export interface OAuthSignupDTO {
  email?: string;
  name?: string;
  login?: string;
  utmInfo?: UtmInfo;
  module?: "CD" | "CI" | "CORE" | "CV" | "CF" | "CE";
}

export interface SignupDTO {
  email?: string;
  password?: string;
  utmInfo?: UtmInfo;
}

export interface JsonNode {
  array?: boolean;
  null?: boolean;
  object?: boolean;
  valueNode?: boolean;
  containerNode?: boolean;
  missingNode?: boolean;
  nodeType?:
    | "ARRAY"
    | "BINARY"
    | "BOOLEAN"
    | "MISSING"
    | "NULL"
    | "NUMBER"
    | "OBJECT"
    | "POJO"
    | "STRING";
  pojo?: boolean;
  number?: boolean;
  integralNumber?: boolean;
  floatingPointNumber?: boolean;
  short?: boolean;
  int?: boolean;
  long?: boolean;
  float?: boolean;
  double?: boolean;
  bigDecimal?: boolean;
  bigInteger?: boolean;
  textual?: boolean;
  boolean?: boolean;
  binary?: boolean;
}

export interface PartialSchemaDTO {
  schema?: JsonNode;
  nodeType?: string;
  nodeName?: string;
  namespace?: string;
}

export interface ResponsePartialSchemaDTO {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: PartialSchemaDTO;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseJsonNode {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: JsonNode;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface ResponseYamlSnippets {
  status?: "SUCCESS" | "FAILURE" | "ERROR";
  data?: YamlSnippets;
  metaData?: { [key: string]: any };
  correlationId?: string;
}

export interface YamlSnippetMetaData {
  name?: string;
  description?: string;
  version?: string;
  identifier?: string;
  tags?: string[];
  iconTag?: string;
}

export interface YamlSnippets {
  yamlSnippets?: YamlSnippetMetaData[];
}

export type SecretFileDTORequestBody = void;

export type DockerRequestDTORequestBody = DockerRequestDTO;

export type OrganizationRequestRequestBody = OrganizationRequest;

export type UploadSamlMetaDataRequestBody = void;

export type EnvironmentRequestDTORequestBody = EnvironmentRequestDTO;

export type GcrRequestDTORequestBody = GcrRequestDTO;

export type ModuleLicenseDTORequestBody = ModuleLicenseDTO;

export type MergeInputSetRequestRequestBody = MergeInputSetRequest;

export type ProjectRequestRequestBody = ProjectRequest;

export type GitSyncConfigRequestBody = GitSyncConfig;

export type SecretTextDTORequestBody = void;

export type DelegateProfileDetailsNgRequestBody = DelegateProfileDetailsNg;

export type UserGroupDTORequestBody = UserGroupDTO;

export type FilterDTORequestBody = FilterDTO;

export type OverlayInputSetConfigRequestBody = OverlayInputSetConfig;

export type NgPipelineRequestBody = NgPipeline;

export type ConnectorRequestBody = Connector;

export type UpdateWhitelistedDomainsBodyRequestBody = string[];

export type EcrRequestDTORequestBody = EcrRequestDTO;

export type SecretTextDTO2RequestBody = SecretTextDTO;

export type SecretRequestWrapperRequestBody = SecretRequestWrapper;

export type SecretRequestWrapper2RequestBody = void;

export type ServiceRequestDTORequestBody = ServiceRequestDTO;

export type ServiceRequestDTOArrayRequestBody = ServiceRequestDTO[];

export type SourceCodeManagerDTORequestBody = SourceCodeManagerDTO;

export type InputSetConfigRequestBody = InputSetConfig;

export interface SignupQueryParams {
  captchaToken?: string;
}

export type SignupProps = Omit<
  MutateProps<
    RestResponseUserInfo,
    Failure | Error,
    SignupQueryParams,
    SignupDTO,
    void
  >,
  "path" | "verb"
>;

export const Signup = (props: SignupProps) => (
  <Mutate<
    RestResponseUserInfo,
    Failure | Error,
    SignupQueryParams,
    SignupDTO,
    void
  >
    verb="POST"
    path={`/signup`}
    base={"/gateway/ng/api"}
    {...props}
  />
);

export type UseSignupProps = Omit<
  UseMutateProps<
    RestResponseUserInfo,
    Failure | Error,
    SignupQueryParams,
    SignupDTO,
    void
  >,
  "path" | "verb"
>;

export const useSignup = (props: UseSignupProps) =>
  useMutate<
    RestResponseUserInfo,
    Failure | Error,
    SignupQueryParams,
    SignupDTO,
    void
  >("POST", `/signup`, { base: "/gateway/ng/api", ...props });
